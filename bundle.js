/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].e;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			e: {},
/******/ 			i: moduleId,
/******/ 			l: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.e, module, module.e, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.e;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 26);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser
	
	var process = module.e = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(0).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate, __webpack_require__(1).clearImmediate))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * EventEmitter2
	 * https://github.com/hij1nx/EventEmitter2
	 *
	 * Copyright (c) 2013 hij1nx
	 * Licensed under the MIT license.
	 */
	;!function(undefined) {
	
	  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]";
	  };
	  var defaultMaxListeners = 10;
	
	  function init() {
	    this._events = {};
	    if (this._conf) {
	      configure.call(this, this._conf);
	    }
	  }
	
	  function configure(conf) {
	    if (conf) {
	
	      this._conf = conf;
	
	      conf.delimiter && (this.delimiter = conf.delimiter);
	      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
	      conf.wildcard && (this.wildcard = conf.wildcard);
	      conf.newListener && (this.newListener = conf.newListener);
	
	      if (this.wildcard) {
	        this.listenerTree = {};
	      }
	    }
	  }
	
	  function EventEmitter(conf) {
	    this._events = {};
	    this.newListener = false;
	    configure.call(this, conf);
	  }
	
	  //
	  // Attention, function return type now is array, always !
	  // It has zero elements if no any matches found and one or more
	  // elements (leafs) if there are matches
	  //
	  function searchListenerTree(handlers, type, tree, i) {
	    if (!tree) {
	      return [];
	    }
	    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
	        typeLength = type.length, currentType = type[i], nextType = type[i+1];
	    if (i === typeLength && tree._listeners) {
	      //
	      // If at the end of the event(s) list and the tree has listeners
	      // invoke those listeners.
	      //
	      if (typeof tree._listeners === 'function') {
	        handlers && handlers.push(tree._listeners);
	        return [tree];
	      } else {
	        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
	          handlers && handlers.push(tree._listeners[leaf]);
	        }
	        return [tree];
	      }
	    }
	
	    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
	      //
	      // If the event emitted is '*' at this part
	      // or there is a concrete match at this patch
	      //
	      if (currentType === '*') {
	        for (branch in tree) {
	          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
	          }
	        }
	        return listeners;
	      } else if(currentType === '**') {
	        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
	        if(endReached && tree._listeners) {
	          // The next element has a _listeners, add it to the handlers.
	          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
	        }
	
	        for (branch in tree) {
	          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
	            if(branch === '*' || branch === '**') {
	              if(tree[branch]._listeners && !endReached) {
	                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
	              }
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	            } else if(branch === nextType) {
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
	            } else {
	              // No match on this one, shift into the tree but not in the type array.
	              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
	            }
	          }
	        }
	        return listeners;
	      }
	
	      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
	    }
	
	    xTree = tree['*'];
	    if (xTree) {
	      //
	      // If the listener tree will allow any match for this part,
	      // then recursively explore all branches of the tree
	      //
	      searchListenerTree(handlers, type, xTree, i+1);
	    }
	
	    xxTree = tree['**'];
	    if(xxTree) {
	      if(i < typeLength) {
	        if(xxTree._listeners) {
	          // If we have a listener on a '**', it will catch all, so add its handler.
	          searchListenerTree(handlers, type, xxTree, typeLength);
	        }
	
	        // Build arrays of matching next branches and others.
	        for(branch in xxTree) {
	          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
	            if(branch === nextType) {
	              // We know the next element will match, so jump twice.
	              searchListenerTree(handlers, type, xxTree[branch], i+2);
	            } else if(branch === currentType) {
	              // Current node matches, move into the tree.
	              searchListenerTree(handlers, type, xxTree[branch], i+1);
	            } else {
	              isolatedBranch = {};
	              isolatedBranch[branch] = xxTree[branch];
	              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
	            }
	          }
	        }
	      } else if(xxTree._listeners) {
	        // We have reached the end and still on a '**'
	        searchListenerTree(handlers, type, xxTree, typeLength);
	      } else if(xxTree['*'] && xxTree['*']._listeners) {
	        searchListenerTree(handlers, type, xxTree['*'], typeLength);
	      }
	    }
	
	    return listeners;
	  }
	
	  function growListenerTree(type, listener) {
	
	    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	
	    //
	    // Looks for two consecutive '**', if so, don't add the event at all.
	    //
	    for(var i = 0, len = type.length; i+1 < len; i++) {
	      if(type[i] === '**' && type[i+1] === '**') {
	        return;
	      }
	    }
	
	    var tree = this.listenerTree;
	    var name = type.shift();
	
	    while (name) {
	
	      if (!tree[name]) {
	        tree[name] = {};
	      }
	
	      tree = tree[name];
	
	      if (type.length === 0) {
	
	        if (!tree._listeners) {
	          tree._listeners = listener;
	        }
	        else if(typeof tree._listeners === 'function') {
	          tree._listeners = [tree._listeners, listener];
	        }
	        else if (isArray(tree._listeners)) {
	
	          tree._listeners.push(listener);
	
	          if (!tree._listeners.warned) {
	
	            var m = defaultMaxListeners;
	
	            if (typeof this._events.maxListeners !== 'undefined') {
	              m = this._events.maxListeners;
	            }
	
	            if (m > 0 && tree._listeners.length > m) {
	
	              tree._listeners.warned = true;
	              console.error('(node) warning: possible EventEmitter memory ' +
	                            'leak detected. %d listeners added. ' +
	                            'Use emitter.setMaxListeners() to increase limit.',
	                            tree._listeners.length);
	              console.trace();
	            }
	          }
	        }
	        return true;
	      }
	      name = type.shift();
	    }
	    return true;
	  }
	
	  // By default EventEmitters will print a warning if more than
	  // 10 listeners are added to it. This is a useful default which
	  // helps finding memory leaks.
	  //
	  // Obviously not all Emitters should be limited to 10. This function allows
	  // that to be increased. Set to zero for unlimited.
	
	  EventEmitter.prototype.delimiter = '.';
	
	  EventEmitter.prototype.setMaxListeners = function(n) {
	    this._events || init.call(this);
	    this._events.maxListeners = n;
	    if (!this._conf) this._conf = {};
	    this._conf.maxListeners = n;
	  };
	
	  EventEmitter.prototype.event = '';
	
	  EventEmitter.prototype.once = function(event, fn) {
	    this.many(event, 1, fn);
	    return this;
	  };
	
	  EventEmitter.prototype.many = function(event, ttl, fn) {
	    var self = this;
	
	    if (typeof fn !== 'function') {
	      throw new Error('many only accepts instances of Function');
	    }
	
	    function listener() {
	      if (--ttl === 0) {
	        self.off(event, listener);
	      }
	      fn.apply(this, arguments);
	    }
	
	    listener._origin = fn;
	
	    this.on(event, listener);
	
	    return self;
	  };
	
	  EventEmitter.prototype.emit = function() {
	
	    this._events || init.call(this);
	
	    var type = arguments[0];
	
	    if (type === 'newListener' && !this.newListener) {
	      if (!this._events.newListener) { return false; }
	    }
	
	    // Loop through the *_all* functions and invoke them.
	    if (this._all) {
	      var l = arguments.length;
	      var args = new Array(l - 1);
	      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
	      for (i = 0, l = this._all.length; i < l; i++) {
	        this.event = type;
	        this._all[i].apply(this, args);
	      }
	    }
	
	    // If there is no 'error' event listener then throw.
	    if (type === 'error') {
	
	      if (!this._all &&
	        !this._events.error &&
	        !(this.wildcard && this.listenerTree.error)) {
	
	        if (arguments[1] instanceof Error) {
	          throw arguments[1]; // Unhandled 'error' event
	        } else {
	          throw new Error("Uncaught, unspecified 'error' event.");
	        }
	        return false;
	      }
	    }
	
	    var handler;
	
	    if(this.wildcard) {
	      handler = [];
	      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
	    }
	    else {
	      handler = this._events[type];
	    }
	
	    if (typeof handler === 'function') {
	      this.event = type;
	      if (arguments.length === 1) {
	        handler.call(this);
	      }
	      else if (arguments.length > 1)
	        switch (arguments.length) {
	          case 2:
	            handler.call(this, arguments[1]);
	            break;
	          case 3:
	            handler.call(this, arguments[1], arguments[2]);
	            break;
	          // slower
	          default:
	            var l = arguments.length;
	            var args = new Array(l - 1);
	            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
	            handler.apply(this, args);
	        }
	      return true;
	    }
	    else if (handler) {
	      var l = arguments.length;
	      var args = new Array(l - 1);
	      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
	
	      var listeners = handler.slice();
	      for (var i = 0, l = listeners.length; i < l; i++) {
	        this.event = type;
	        listeners[i].apply(this, args);
	      }
	      return (listeners.length > 0) || !!this._all;
	    }
	    else {
	      return !!this._all;
	    }
	
	  };
	
	  EventEmitter.prototype.on = function(type, listener) {
	
	    if (typeof type === 'function') {
	      this.onAny(type);
	      return this;
	    }
	
	    if (typeof listener !== 'function') {
	      throw new Error('on only accepts instances of Function');
	    }
	    this._events || init.call(this);
	
	    // To avoid recursion in the case that type == "newListeners"! Before
	    // adding it to the listeners, first emit "newListeners".
	    this.emit('newListener', type, listener);
	
	    if(this.wildcard) {
	      growListenerTree.call(this, type, listener);
	      return this;
	    }
	
	    if (!this._events[type]) {
	      // Optimize the case of one listener. Don't need the extra array object.
	      this._events[type] = listener;
	    }
	    else if(typeof this._events[type] === 'function') {
	      // Adding the second element, need to change to array.
	      this._events[type] = [this._events[type], listener];
	    }
	    else if (isArray(this._events[type])) {
	      // If we've already got an array, just append.
	      this._events[type].push(listener);
	
	      // Check for listener leak
	      if (!this._events[type].warned) {
	
	        var m = defaultMaxListeners;
	
	        if (typeof this._events.maxListeners !== 'undefined') {
	          m = this._events.maxListeners;
	        }
	
	        if (m > 0 && this._events[type].length > m) {
	
	          this._events[type].warned = true;
	          console.error('(node) warning: possible EventEmitter memory ' +
	                        'leak detected. %d listeners added. ' +
	                        'Use emitter.setMaxListeners() to increase limit.',
	                        this._events[type].length);
	          console.trace();
	        }
	      }
	    }
	    return this;
	  };
	
	  EventEmitter.prototype.onAny = function(fn) {
	
	    if (typeof fn !== 'function') {
	      throw new Error('onAny only accepts instances of Function');
	    }
	
	    if(!this._all) {
	      this._all = [];
	    }
	
	    // Add the function to the event listener collection.
	    this._all.push(fn);
	    return this;
	  };
	
	  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	  EventEmitter.prototype.off = function(type, listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('removeListener only takes instances of Function');
	    }
	
	    var handlers,leafs=[];
	
	    if(this.wildcard) {
	      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
	    }
	    else {
	      // does not use listeners(), so no side effect of creating _events[type]
	      if (!this._events[type]) return this;
	      handlers = this._events[type];
	      leafs.push({_listeners:handlers});
	    }
	
	    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
	      var leaf = leafs[iLeaf];
	      handlers = leaf._listeners;
	      if (isArray(handlers)) {
	
	        var position = -1;
	
	        for (var i = 0, length = handlers.length; i < length; i++) {
	          if (handlers[i] === listener ||
	            (handlers[i].listener && handlers[i].listener === listener) ||
	            (handlers[i]._origin && handlers[i]._origin === listener)) {
	            position = i;
	            break;
	          }
	        }
	
	        if (position < 0) {
	          continue;
	        }
	
	        if(this.wildcard) {
	          leaf._listeners.splice(position, 1);
	        }
	        else {
	          this._events[type].splice(position, 1);
	        }
	
	        if (handlers.length === 0) {
	          if(this.wildcard) {
	            delete leaf._listeners;
	          }
	          else {
	            delete this._events[type];
	          }
	        }
	        return this;
	      }
	      else if (handlers === listener ||
	        (handlers.listener && handlers.listener === listener) ||
	        (handlers._origin && handlers._origin === listener)) {
	        if(this.wildcard) {
	          delete leaf._listeners;
	        }
	        else {
	          delete this._events[type];
	        }
	      }
	    }
	
	    return this;
	  };
	
	  EventEmitter.prototype.offAny = function(fn) {
	    var i = 0, l = 0, fns;
	    if (fn && this._all && this._all.length > 0) {
	      fns = this._all;
	      for(i = 0, l = fns.length; i < l; i++) {
	        if(fn === fns[i]) {
	          fns.splice(i, 1);
	          return this;
	        }
	      }
	    } else {
	      this._all = [];
	    }
	    return this;
	  };
	
	  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;
	
	  EventEmitter.prototype.removeAllListeners = function(type) {
	    if (arguments.length === 0) {
	      !this._events || init.call(this);
	      return this;
	    }
	
	    if(this.wildcard) {
	      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
	
	      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
	        var leaf = leafs[iLeaf];
	        leaf._listeners = null;
	      }
	    }
	    else {
	      if (!this._events[type]) return this;
	      this._events[type] = null;
	    }
	    return this;
	  };
	
	  EventEmitter.prototype.listeners = function(type) {
	    if(this.wildcard) {
	      var handlers = [];
	      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
	      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
	      return handlers;
	    }
	
	    this._events || init.call(this);
	
	    if (!this._events[type]) this._events[type] = [];
	    if (!isArray(this._events[type])) {
	      this._events[type] = [this._events[type]];
	    }
	    return this._events[type];
	  };
	
	  EventEmitter.prototype.listenersAny = function() {
	
	    if(this._all) {
	      return this._all;
	    }
	    else {
	      return [];
	    }
	
	  };
	
	  if (true) {
	     // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return EventEmitter;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.e = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // CommonJS
	    exports.EventEmitter2 = EventEmitter;
	  }
	  else {
	    // Browser global.
	    window.EventEmitter2 = EventEmitter;
	  }
	}();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(9)
	var ieee754 = __webpack_require__(16)
	var isArray = __webpack_require__(13)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(array)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.e = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, global) {/**
	 * Highland: the high-level streams library
	 *
	 * Highland may be freely distributed under the Apache 2.0 license.
	 * http://github.com/caolan/highland
	 * Copyright (c) Caolan McMahon
	 *
	 */
	
	
	var inherits = __webpack_require__(22).inherits;
	var deprecate = __webpack_require__(20);
	var EventEmitter = __webpack_require__(4).EventEmitter;
	var Decoder = __webpack_require__(19).StringDecoder;
	
	/**
	 * The Stream constructor, accepts an array of values or a generator function
	 * as an optional argument. This is typically the entry point to the Highland
	 * APIs, providing a convenient way of chaining calls together.
	 *
	 * **Arrays -** Streams created from Arrays will emit each value of the Array
	 * and then emit a [nil](#nil) value to signal the end of the Stream.
	 *
	 * **Generators -** These are functions which provide values for the Stream.
	 * They are lazy and can be infinite, they can also be asynchronous (for
	 * example, making a HTTP request). You emit values on the Stream by calling
	 * `push(err, val)`, much like a standard Node.js callback. Once it has been
	 * called, the generator function will not be called again unless you call
	 * `next()`. This call to `next()` will signal you've finished processing the
	 * current data and allow for the generator function to be called again. If the
	 * Stream is still being consumed the generator function will then be called
	 * again.
	 *
	 * You can also redirect a generator Stream by passing a new source Stream
	 * to read from to next. For example: `next(other_stream)` - then any subsequent
	 * calls will be made to the new source.
	 *
	 * **Node Readable Stream -** Pass in a Node Readable Stream object to wrap
	 * it with the Highland API. Reading from the resulting Highland Stream will
	 * begin piping the data from the Node Stream to the Highland Stream.
	 *
	 * **EventEmitter / jQuery Elements -** Pass in both an event name and an
	 * event emitter as the two arguments to the constructor and the first
	 * argument emitted to the event handler will be written to the new Stream.
	 *
	 * You can pass a mapping hint as the third argument, which specifies how
	 * event arguments are pushed into the stream. If no mapping hint is provided,
	 * only the first value emitted with the event to the will be pushed onto the
	 * Stream.
	 *
	 * If `mappingHint` is a number, an array of that length will be pushed onto
	 * the stream, containing exactly that many parameters from the event. If it's
	 * an array, it's used as keys to map the arguments into an object which is
	 * pushed to the tream. If it is a function, it's called with the event
	 * arguments, and the returned value is pushed.
	 *
	 * **Promise -** Accepts an ES6 / jQuery style promise and returns a
	 * Highland Stream which will emit a single value (or an error).
	 *
	 * **Iterator -** Accepts an ES6 style iterator that implements the [iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_.22iterator.22_protocol):
	 * yields all the values from the iterator using its `next()` method and terminates when the
	 * iterator's done value returns true. If the iterator's `next()` method throws, the exception will be emitted as an error,
	 * and the stream will be ended with no further calls to `next()`.
	 *
	 * **Iterable -** Accepts an object that implements the [iterable protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_.22iterable.22_protocol),
	 * i.e., contains a method that returns an object that conforms to the iterator protocol. The stream will use the
	 * iterator defined in the `Symbol.iterator` property of the iterable object to generate emitted values.
	 *
	 * @id _(source)
	 * @section Stream Objects
	 * @name _(source)
	 * @param {Array | Function | Iterator | Iterable | Promise | Readable Stream | String} source - (optional) source to take values from from
	 * @param {EventEmitter | jQuery Element} eventEmitter - (optional) an event emitter. Only valid if `source` is a String.
	 * @param {Array | Function | Number} mappingHint - (optional) how to pass the
	 * arguments to the callback. Only valid if `source` is a String.
	 * @api public
	 *
	 * // from an Array
	 * _([1, 2, 3, 4]);
	 *
	 * // using a generator function
	 * _(function (push, next) {
	 *     push(null, 1);
	 *     push(err);
	 *     next();
	 * });
	 *
	 * // a stream with no source, can pipe node streams through it etc.
	 * var through = _();
	 *
	 * // wrapping a Node Readable Stream so you can easily manipulate it
	 * _(readable).filter(hasSomething).pipe(writeable);
	 *
	 * // creating a stream from events
	 * _('click', btn).each(handleEvent);
	 *
	 * // creating a stream from events with mapping
	 * _('request', httpServer, ['req', 'res']).each(handleEvent);
	 *
	 * // from a Promise object
	 * var foo = _($.getJSON('/api/foo'));
	 *
	 * //from an iterator
	 * var map = new Map([['a', 1], ['b', 2]]);
	 * var bar = _(map.values()).toArray(_.log);
	 * //=> [1, 2]
	 *
	 * //from an iterable
	 * var set = new Set([1, 2, 2, 3, 4]);
	 * var bar = _(set).toArray(_.log);
	 * //=> [ 1, 2, 3, 4]
	 */
	
	/*eslint-disable no-multi-spaces */
	exports = module.e = function (/*optional*/xs, /*optional*/ee, /*optional*/ mappingHint) {
	    /*eslint-enable no-multi-spaces */
	    return new Stream(xs, ee, mappingHint);
	};
	
	var _ = exports;
	
	// Create quick slice reference variable for speed
	var slice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;
	
	// ES5 detected value, used for switch between ES5 and ES3 code
	var isES5 = (function () {
	  'use strict';
	  return Function.prototype.bind && !this;
	}());
	
	
	_.isUndefined = function (x) {
	    return typeof x === 'undefined';
	};
	
	_.isFunction = function (x) {
	    return typeof x === 'function';
	};
	
	_.isObject = function (x) {
	    return typeof x === 'object' && x !== null;
	};
	
	_.isString = function (x) {
	    return typeof x === 'string';
	};
	
	_.isArray = Array.isArray || function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	};
	
	// setImmediate browser fallback
	if (typeof setImmediate === 'undefined') {
	    _.setImmediate = function (fn) {
	        setTimeout(fn, 0);
	    };
	}
	// check no process.stdout to detect browserify
	else if (typeof process === 'undefined' || !(process.stdout)) {
	    // modern browser - but not a direct alias for IE10 compatibility
	    _.setImmediate = function (fn) {
	        setImmediate(fn);
	    };
	}
	else {
	    _.setImmediate = setImmediate;
	}
	
	/**
	 * The end of stream marker. This is sent along the data channel of a Stream
	 * to tell consumers that the Stream has ended. See the example map code for
	 * an example of detecting the end of a Stream.
	 *
	 * Note: `nil` is setup as a global where possible. This makes it convenient
	 * to access, but more importantly lets Streams from different Highland
	 * instances work together and detect end-of-stream properly. This is mostly
	 * useful for NPM where you may have many different Highland versions installed.
	 *
	 * @id nil
	 * @section Utils
	 * @name _.nil
	 * @api public
	 *
	 * var map = function (iter, source) {
	 *     return source.consume(function (err, val, push, next) {
	 *         if (err) {
	 *             push(err);
	 *             next();
	 *         }
	 *         else if (val === _.nil) {
	 *             push(null, val);
	 *         }
	 *         else {
	 *             push(null, iter(val));
	 *             next();
	 *         }
	 *     });
	 * };
	 */
	
	// set up a global nil object in cases where you have multiple Highland
	// instances installed (often via npm)
	var _global = this;
	if (typeof global !== 'undefined') {
	    _global = global;
	}
	else if (typeof window !== 'undefined') {
	    _global = window;
	}
	if (!_global.nil) {
	    _global.nil = {};
	}
	var nil = _.nil = _global.nil;
	
	/**
	 * Transforms a function with specific arity (all arguments must be
	 * defined) in a way that it can be called as a chain of functions until
	 * the arguments list is saturated.
	 *
	 * This function is not itself curryable.
	 *
	 * @id curry
	 * @name _.curry(fn, [*arguments])
	 * @section Functions
	 * @param {Function} fn - the function to curry
	 * @param args.. - any number of arguments to pre-apply to the function
	 * @returns Function
	 * @api public
	 *
	 * fn = curry(function (a, b, c) {
	 *     return a + b + c;
	 * });
	 *
	 * fn(1)(2)(3) == fn(1, 2, 3)
	 * fn(1, 2)(3) == fn(1, 2, 3)
	 * fn(1)(2, 3) == fn(1, 2, 3)
	 */
	
	_.curry = function (fn /* args... */) {
	    var args = slice.call(arguments);
	    return _.ncurry.apply(this, [fn.length].concat(args));
	};
	
	/**
	 * Same as `curry` but with a specific number of arguments. This can be
	 * useful when functions do not explicitly define all its parameters.
	 *
	 * This function is not itself curryable.
	 *
	 * @id ncurry
	 * @name _.ncurry(n, fn, [args...])
	 * @section Functions
	 * @param {Number} n - the number of arguments to wait for before apply fn
	 * @param {Function} fn - the function to curry
	 * @param args... - any number of arguments to pre-apply to the function
	 * @returns Function
	 * @api public
	 *
	 * fn = ncurry(3, function () {
	 *     return Array.prototype.join.call(arguments, '.');
	 * });
	 *
	 * fn(1, 2, 3) == '1.2.3';
	 * fn(1, 2)(3) == '1.2.3';
	 * fn(1)(2)(3) == '1.2.3';
	 */
	
	_.ncurry = function (n, fn /* args... */) {
	    var largs = slice.call(arguments, 2);
	    if (largs.length >= n) {
	        return fn.apply(this, largs.slice(0, n));
	    }
	
	    return _.partial.apply(this, [_.ncurry, n, fn].concat(largs));
	};
	
	/**
	 * Partially applies the function (regardless of whether it has had curry
	 * called on it). This will always postpone execution until at least the next
	 * call of the partially applied function.
	 *
	 * @id partial
	 * @name _.partial(fn, args...)
	 * @section Functions
	 * @param {Function} fn - function to partial apply
	 * @param args... - the arguments to apply to the function
	 * @api public
	 *
	 * var addAll = function () {
	 *     var args = Array.prototype.slice.call(arguments);
	 *     return foldl1(add, args);
	 * };
	 * var f = partial(addAll, 1, 2);
	 * f(3, 4) == 10
	 */
	
	_.partial = function (f /* args... */) {
	    var args = slice.call(arguments, 1);
	    return function () {
	        return f.apply(this, args.concat(slice.call(arguments)));
	    };
	};
	
	/**
	 * Evaluates the function `fn` with the argument positions swapped. Only
	 * works with functions that accept two arguments.
	 *
	 * @id flip
	 * @name _.flip(fn, [x, y])
	 * @section Functions
	 * @param {Function} fn - function to flip argument application for
	 * @param x - parameter to apply to the right hand side of f
	 * @param y - parameter to apply to the left hand side of f
	 * @api public
	 *
	 * div(2, 4) == 0.5
	 * flip(div, 2, 4) == 2
	 * flip(div)(2, 4) == 2
	 */
	
	_.flip = _.curry(function (fn, x, y) { return fn(y, x); });
	
	/**
	 * Creates a composite function, which is the application of function1 to
	 * the results of function2. You can pass an arbitrary number of arguments
	 * and have them composed. This means you can't partially apply the compose
	 * function itself.
	 *
	 * @id compose
	 * @name _.compose(fn1, fn2, ...)
	 * @section Functions
	 * @api public
	 *
	 * var add1 = add(1);
	 * var mul3 = mul(3);
	 *
	 * var add1mul3 = compose(mul3, add1);
	 * add1mul3(2) == 9
	 */
	
	_.compose = function (/*functions...*/) {
	    var fns = slice.call(arguments).reverse();
	    return _.seq.apply(null, fns);
	};
	
	/**
	 * The reversed version of [compose](#compose). Where arguments are in the
	 * order of application.
	 *
	 * @id seq
	 * @name _.seq(fn1, fn2, ...)
	 * @section Functions
	 * @api public
	 *
	 * var add1 = add(1);
	 * var mul3 = mul(3);
	 *
	 * var add1mul3 = seq(add1, mul3);
	 * add1mul3(2) == 9
	 */
	
	_.seq = function () {
	    var fns = slice.call(arguments);
	    return function () {
	        if (!fns.length) {
	            return null;
	        }
	        var r = fns[0].apply(this, arguments);
	        for (var i = 1; i < fns.length; i++) {
	            r = fns[i].call(this, r);
	        }
	        return r;
	    };
	};
	
	function nop() {
	    // Do nothing.
	}
	
	function pipeReadable(xs, stream) {
	    // write any errors into the stream
	    xs.on('error', writeStreamError);
	    xs.pipe(stream);
	
	    // TODO: Replace with onDestroy in v3.
	    stream._destructors.push(function () {
	        if (xs.unpipe) {
	            xs.unpipe(stream);
	        }
	        xs.removeListener('error', writeStreamError);
	    });
	
	    function writeStreamError(err) {
	        stream.write(new StreamError(err));
	    }
	}
	
	function promiseStream(promise) {
	    return _(function (push) {
	        promise.then(function (value) {
	                push(null, value);
	                return push(null, nil);
	            },
	            function (err) {
	                push(err);
	                return push(null, nil);
	            });
	    });
	}
	
	function iteratorStream(it) {
	    return _(function (push, next) {
	        var iterElem, iterErr;
	        try {
	            iterElem = it.next();
	        }
	        catch (err) {
	            iterErr = err;
	        }
	
	        if (iterErr) {
	            push(iterErr);
	            push(null, _.nil);
	        }
	        else if (iterElem.done) {
	            if (!_.isUndefined(iterElem.value)) {
	                // generators can return a final
	                // value on completion using return
	                // keyword otherwise value will be
	                // undefined
	                push(null, iterElem.value);
	            }
	            push(null, _.nil);
	        }
	        else {
	            push(null, iterElem.value);
	            next();
	        }
	
	    });
	}
	
	function hintMapper(mappingHint) {
	    var mappingHintType = (typeof mappingHint);
	    var mapper;
	
	    if (mappingHintType === 'function') {
	        mapper = mappingHint;
	    }
	    else if (mappingHintType === 'number') {
	        mapper = function () {
	            return slice.call(arguments, 0, mappingHint);
	        };
	    }
	    else if (_.isArray(mappingHint)) {
	        mapper = function () {
	            var args = arguments;
	            return mappingHint.reduce(function (ctx, hint, idx) {
	                ctx[hint] = args[idx];
	                return ctx;
	            }, {});
	        };
	    }
	    else {
	        mapper = function (x) { return x; };
	    }
	
	    return mapper;
	}
	
	function pipeStream(src, dest, write, end, passAlongErrors) {
	    var resume = null;
	    var s = src.consume(function (err, x, push, next) {
	        var canContinue;
	        if (err) {
	            if (passAlongErrors) {
	                canContinue = write.call(dest, new StreamError(err));
	            }
	            else {
	                src.emit('error', err);
	                canContinue = true;
	            }
	        }
	        else if (x === nil) {
	            end.call(dest);
	            return;
	        }
	        else {
	            canContinue = write.call(dest, x);
	        }
	
	        if (canContinue !== false) {
	            next();
	        }
	        else {
	            resume = next;
	        }
	    });
	
	    dest.on('drain', onConsumerDrain);
	
	    // Since we don't keep a reference to piped-to streams,
	    // save a callback that will unbind the event handler.
	    src._destructors.push(function () {
	        dest.removeListener('drain', onConsumerDrain);
	    });
	
	    s.resume();
	    return dest;
	
	    function onConsumerDrain() {
	        if (resume) {
	            var oldResume = resume;
	            resume = null;
	            oldResume();
	        }
	    }
	}
	
	function generatorPush(stream, write) {
	    if (!write) {
	        write = stream.write;
	    }
	
	    return function (err, x) {
	        if (stream._nil_seen) {
	            throw new Error('Can not write to stream after nil');
	        }
	
	        if (x === nil) {
	            stream._nil_seen = true;
	        }
	
	        write.call(stream, err ? new StreamError(err) : x);
	    };
	}
	
	
	/**
	 * Actual Stream constructor wrapped the the main exported function
	 */
	
	/*eslint-disable no-multi-spaces */
	function Stream(/*optional*/xs, /*optional*/ee, /*optional*/mappingHint) {
	    /*eslint-enable no-multi-spaces */
	    if (xs && _.isStream(xs)) {
	        // already a Stream
	        return xs;
	    }
	
	    EventEmitter.call(this);
	    var self = this;
	
	    // used to detect Highland Streams using isStream(x), this
	    // will work even in cases where npm has installed multiple
	    // versions, unlike an instanceof check
	    self.__HighlandStream__ = true;
	
	    self.id = ('' + Math.random()).substr(2, 6);
	    this.paused = true;
	    this._incoming = [];
	    this._outgoing = [];
	    this._consumers = [];
	    this._observers = [];
	    this._destructors = [];
	    this._send_events = false;
	    this._nil_seen = false;
	    this._delegate = null;
	    this._is_observer = false;
	    this._in_consume_cb = false;
	    this._repeat_resume = false;
	    this.source = null;
	
	    // Old-style node Stream.pipe() checks for this
	    this.writable = true;
	
	    self.on('newListener', function (ev) {
	        if (ev === 'data') {
	            self._send_events = true;
	            _.setImmediate(self.resume.bind(self));
	        }
	        else if (ev === 'end') {
	            // this property avoids us checking the length of the
	            // listners subscribed to each event on each _send() call
	            self._send_events = true;
	        }
	    });
	
	    // TODO: write test to cover this removeListener code
	    self.on('removeListener', function (ev) {
	        if (ev === 'end' || ev === 'data') {
	            var end_listeners = self.listeners('end').length;
	            var data_listeners = self.listeners('data').length;
	            if (end_listeners + data_listeners === 0) {
	                // stop emitting events
	                self._send_events = false;
	            }
	        }
	    });
	
	    if (_.isUndefined(xs)) {
	        // nothing else to do
	        return this;
	    }
	    else if (_.isArray(xs)) {
	        self._incoming = xs.concat([nil]);
	    }
	    else if (_.isFunction(xs)) {
	        this._generator = xs;
	        this._generator_push = generatorPush(this);
	        this._generator_next = function (s) {
	            if (self._nil_seen) {
	                throw new Error('Can not call next after nil');
	            }
	
	            if (s) {
	                // we MUST pause to get the redirect object into the _incoming
	                // buffer otherwise it would be passed directly to _send(),
	                // which does not handle StreamRedirect objects!
	                var _paused = self.paused;
	                if (!_paused) {
	                    self.pause();
	                }
	                self.write(new StreamRedirect(s));
	                if (!_paused) {
	                    self.resume();
	                }
	            }
	            else {
	                self._generator_running = false;
	            }
	            if (!self.paused) {
	                self.resume();
	            }
	        };
	    }
	    else if (_.isObject(xs)) {
	        // check to see if we have a readable stream
	        if (_.isFunction(xs.on) && _.isFunction(xs.pipe)) {
	            pipeReadable(xs, self);
	        }
	        else if (_.isFunction(xs.then)) {
	            //probably a promise
	            return promiseStream(xs);
	        }
	        // must check iterators and iterables in this order
	        // because generators are both iterators and iterables:
	        // their Symbol.iterator method returns the `this` object
	        // and an infinite loop would result otherwise
	        else if (_.isFunction(xs.next)) {
	            //probably an iterator
	            return iteratorStream(xs);
	        }
	        else if (!_.isUndefined(_global.Symbol) && xs[_global.Symbol.iterator]) {
	            //probably an iterable
	            return iteratorStream(xs[_global.Symbol.iterator]());
	        }
	        else {
	            throw new Error(
	                'Object was not a stream, promise, iterator or iterable: ' + (typeof xs)
	            );
	        }
	    }
	    else if (_.isString(xs)) {
	        var mapper = hintMapper(mappingHint);
	
	        ee.on(xs, function () {
	            var ctx = mapper.apply(this, arguments);
	            self.write(ctx);
	        });
	    }
	    else {
	        throw new Error(
	            'Unexpected argument type to Stream(): ' + (typeof xs)
	        );
	    }
	}
	inherits(Stream, EventEmitter);
	
	/**
	 * adds a top-level _.foo(mystream) style export for Stream methods
	 */
	
	function exposeMethod(name) {
	    var f = Stream.prototype[name];
	    var n = f.length;
	    _[name] = _.ncurry(n + 1, function () {
	        var args = slice.call(arguments);
	        var s = _(args.pop());
	        return f.apply(s, args);
	    });
	}
	
	/**
	 * Used as an Error marker when writing to a Stream's incoming buffer
	 */
	
	function StreamError(err) {
	    this.__HighlandStreamError__ = true;
	    this.error = err;
	}
	
	/**
	 * Used as a Redirect marker when writing to a Stream's incoming buffer
	 */
	
	function StreamRedirect(to) {
	    this.__HighlandStreamRedirect__ = true;
	    this.to = to;
	}
	
	/**
	 * Returns true if `x` is a Highland Stream.
	 *
	 * @id isStream
	 * @section Utils
	 * @name _.isStream(x)
	 * @param x - the object to test
	 * @returns {Boolean}
	 * @api public
	 *
	 * _.isStream('foo')  // => false
	 * _.isStream(_([1,2,3]))  // => true
	 */
	
	_.isStream = function (x) {
	    return _.isObject(x) && !!x.__HighlandStream__;
	};
	
	_._isStreamError = function (x) {
	    return _.isObject(x) && !!x.__HighlandStreamError__;
	};
	
	_._isStreamRedirect = function (x) {
	    return _.isObject(x) && !!x.__HighlandStreamRedirect__;
	};
	
	/**
	 * Sends errors / data to consumers, observers and event handlers
	 */
	
	Stream.prototype._send = function (err, x) {
	    //console.log(['_send', this.id, err, x]);
	    var token;
	
	    if (x === nil) {
	        this.ended = true;
	    }
	    if (this._consumers.length) {
	        token = err ? new StreamError(err) : x;
	        // this._consumers may be changed from under us,
	        // so we keep a copy.
	        var consumers = this._consumers;
	        for (var i = 0, len = consumers.length; i < len; i++) {
	            consumers[i].write(token);
	        }
	    }
	    if (this._observers.length) {
	        token = err ? new StreamError(err) : x;
	        // this._observers may be changed from under us,
	        // so we keep a copy.
	        var observers = this._observers;
	        for (var j = 0, len2 = observers.length; j < len2; j++) {
	            observers[j].write(token);
	        }
	    }
	    if (this._send_events) {
	        if (err) {
	            this.emit('error', err);
	        }
	        else if (x === nil) {
	            this.emit('end');
	        }
	        else {
	            this.emit('data', x);
	        }
	    }
	};
	
	/**
	 * Pauses the stream. All Highland Streams start in the paused state.
	 *
	 * It is unlikely that you will need to manually call this method.
	 *
	 * @id pause
	 * @section Stream Objects
	 * @name Stream.pause()
	 * @api public
	 *
	 * var xs = _(generator);
	 * xs.pause();
	 */
	
	Stream.prototype.pause = function () {
	    //console.log(['pause', this.id]);
	    this.paused = true;
	    if (!this._is_observer && this.source) {
	        this.source._checkBackPressure();
	    }
	};
	
	/**
	 * When there is a change in downstream consumers, it will often ask
	 * the parent Stream to re-check it's state and pause/resume accordingly.
	 */
	
	Stream.prototype._checkBackPressure = function () {
	    if (!this._consumers.length) {
	        this._repeat_resume = false;
	        return this.pause();
	    }
	    for (var i = 0, len = this._consumers.length; i < len; i++) {
	        if (this._consumers[i].paused) {
	            this._repeat_resume = false;
	            return this.pause();
	        }
	    }
	    return this.resume();
	};
	
	/**
	 * Starts pull values out of the incoming buffer and sending them downstream,
	 * this will exit early if this causes a downstream consumer to pause.
	 */
	
	Stream.prototype._readFromBuffer = function () {
	    //console.log(['_readFromBuffer', this.id, this.paused, this._incoming]);
	    var len = this._incoming.length;
	    var i = 0;
	    while (i < len && !this.paused) {
	        var x = this._incoming[i];
	        if (_._isStreamError(x)) {
	            this._send(x.error);
	        }
	        else if (_._isStreamRedirect(x)) {
	            this._redirect(x.to);
	        }
	        else {
	            this._send(null, x);
	        }
	        i++;
	    }
	    // remove processed data from _incoming buffer
	    this._incoming.splice(0, i);
	};
	
	/**
	 * Starts pull values out of the incoming buffer and sending them downstream,
	 * this will exit early if this causes a downstream consumer to pause.
	 */
	
	Stream.prototype._sendOutgoing = function () {
	    //console.log(['_sendOutgoing', this.id, this.paused, this._outgoing]);
	    var len = this._outgoing.length;
	    var i = 0;
	    while (i < len && !this.paused) {
	        var x = this._outgoing[i];
	        if (_._isStreamError(x)) {
	            Stream.prototype._send.call(this, x.error);
	        }
	        else if (_._isStreamRedirect(x)) {
	            this._redirect(x.to);
	        }
	        else {
	            Stream.prototype._send.call(this, null, x);
	        }
	        i++;
	    }
	    // remove processed data from _outgoing buffer
	    this._outgoing.splice(0, i);
	};
	
	/**
	 * Resumes a paused Stream. This will either read from the Stream's incoming
	 * buffer or request more data from an upstream source. Never call this method
	 * on a stream that has been consumed (via a call to [consume](#consume) or any
	 * other transform).
	 *
	 * @id resume
	 * @section Stream Objects
	 * @name Stream.resume()
	 * @api public
	 *
	 * var xs = _(generator);
	 * xs.resume();
	 */
	
	Stream.prototype.resume = function () {
	    //console.log(['resume', this.id]);
	    if (this._resume_running || this._in_consume_cb) {
	        //console.log(['resume already processing _incoming buffer, ignore resume call']);
	        // already processing _incoming buffer, ignore resume call
	        this._repeat_resume = true;
	        return;
	    }
	    this._resume_running = true;
	    do {
	        // use a repeat flag to avoid recursing resume() calls
	        this._repeat_resume = false;
	        this.paused = false;
	
	        // send values from outgoing buffer first
	        this._sendOutgoing();
	
	        // send values from incoming buffer before reading from source
	        this._readFromBuffer();
	
	        // we may have paused while reading from buffer
	        if (!this.paused && !this._is_observer) {
	            // ask parent for more data
	            if (this.source) {
	                //console.log(['ask parent for more data']);
	                this.source._checkBackPressure();
	            }
	            // run _generator to fill up _incoming buffer
	            else if (this._generator) {
	                //console.log(['run generator to fill up _incoming buffer']);
	                this._runGenerator();
	            }
	            else {
	                // perhaps a node stream is being piped in
	                this.emit('drain');
	            }
	        }
	    } while (this._repeat_resume);
	    this._resume_running = false;
	};
	
	/**
	 * Ends a Stream. This is the same as sending a [nil](#nil) value as data.
	 * You shouldn't need to call this directly, rather it will be called by
	 * any [Node Readable Streams](http://nodejs.org/api/stream.html#stream_class_stream_readable)
	 * you pipe in.
	 *
	 * Only call this function on streams that were constructed with no source
	 * (i.e., with `_()`).
	 *
	 * @id end
	 * @section Stream Objects
	 * @name Stream.end()
	 * @api public
	 *
	 * mystream.end();
	 */
	
	Stream.prototype.end = function () {
	    this.write(nil);
	};
	
	/**
	 * Pipes a Highland Stream to a [Node Writable Stream](http://nodejs.org/api/stream.html#stream_class_stream_writable)
	 * (Highland Streams are also Node Writable Streams). This will pull all the
	 * data from the source Highland Stream and write it to the destination,
	 * automatically managing flow so that the destination is not overwhelmed
	 * by a fast source.
	 *
	 * This function returns the destination so you can chain together pipe calls.
	 *
	 * Like [Readable#pipe](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options),
	 * this function will throw errors if there is no `error` handler installed on
	 * the stream. Use [through](#through) if you are piping to another Highland
	 * stream and want errors as well as values to be propagated.
	 *
	 * @id pipe
	 * @section Consumption
	 * @name Stream.pipe(dest)
	 * @param {Writable Stream} dest - the destination to write all data to
	 * @api public
	 *
	 * var source = _(generator);
	 * var dest = fs.createWriteStream('myfile.txt')
	 * source.pipe(dest);
	 *
	 * // chained call
	 * source.pipe(through).pipe(dest);
	 */
	
	Stream.prototype.pipe = function (dest) {
	    // stdout and stderr are special case writables that cannot be closed
	    var canClose = dest !== process.stdout && dest !== process.stderr;
	
	    var end;
	    if (canClose) {
	        end = dest.end;
	    }
	    else {
	        end = nop;
	    }
	
	    return pipeStream(this, dest, dest.write, end, false);
	};
	
	/**
	 * Destroys a stream by unlinking it from any consumers and sources. This will
	 * stop all consumers from receiving events from this stream and removes this
	 * stream as a consumer of any source stream.
	 *
	 * This function calls end() on the stream and unlinks it from any piped-to streams.
	 *
	 * @id destroy
	 * @section Stream Objects
	 * @name Stream.destroy()
	 * @api public
	 */
	
	Stream.prototype.destroy = function () {
	    var self = this;
	    this.end();
	    _(this._consumers).each(function (consumer) {
	        self._removeConsumer(consumer);
	    });
	    _(this._observers).each(function (observer) {
	        self._removeObserver(observer);
	    });
	
	    if (this.source) {
	        var source = this.source;
	        source._removeConsumer(this);
	        source._removeObserver(this);
	    }
	    _(this._destructors).each(function (destructor) {
	        destructor.call(self);
	    });
	};
	
	/**
	 * Runs the generator function for this Stream. If the generator is already
	 * running (it has been called and not called next() yet) then this function
	 * will do nothing.
	 */
	
	Stream.prototype._runGenerator = function () {
	    //console.log(['_runGenerator', this.id]);
	    // if _generator already running, exit
	    if (this._generator_running) {
	        return;
	    }
	    this._generator_running = true;
	    this._generator(this._generator_push, this._generator_next);
	};
	
	/**
	 * Performs the redirect from one Stream to another. In order for the
	 * redirect to happen at the appropriate time, it is put on the incoming
	 * buffer as a StreamRedirect object, and this function is called
	 * once it is read from the buffer.
	 */
	
	Stream.prototype._redirect = function (to) {
	    //console.log(['_redirect', this.id, '=>', to.id]);
	    // coerce to Stream
	    to = _(to);
	
	    while (to._delegate) {
	        to = to._delegate;
	    }
	
	    to._consumers = this._consumers.map(function (c) {
	        c.source = to;
	        return c;
	    });
	
	    // TODO: copy _observers
	    this._consumers = [];
	    //[this.consume = function () {
	    //    return to.consume.apply(to, arguments);
	    //};
	    //this._removeConsumer = function () {
	    //    return to._removeConsumer.apply(to, arguments);
	    //};
	
	    // this will cause a memory leak as long as the root object is around
	    to._delegate_source = this._delegate_source || this;
	    to._delegate_source._delegate = to;
	
	    if (this.paused) {
	        to.pause();
	    }
	    else {
	        this.pause();
	        to._checkBackPressure();
	    }
	};
	
	/**
	 * Adds a new consumer Stream, which will accept data and provide backpressure
	 * to this Stream. Adding more than one consumer will cause an exception to be
	 * thrown as the backpressure strategy must be explicitly chosen by the
	 * developer (through calling fork or observe).
	 */
	
	Stream.prototype._addConsumer = function (s) {
	    if (this._consumers.length) {
	        throw new Error(
	            'Stream already being consumed, you must either fork() or observe()'
	        );
	    }
	    s.source = this;
	    this._consumers.push(s);
	    this._checkBackPressure();
	};
	
	/**
	 * Removes a consumer from this Stream.
	 */
	
	Stream.prototype._removeConsumer = function (s) {
	    var src = this;
	    while (src._delegate) {
	        src = src._delegate;
	    }
	    src._consumers = src._consumers.filter(function (c) {
	        return c !== s;
	    });
	    if (s.source === src) {
	        s.source = null;
	    }
	    src._checkBackPressure();
	};
	
	/**
	 * Removes an observer from this Stream.
	 */
	
	Stream.prototype._removeObserver = function (s) {
	    this._observers = this._observers.filter(function (o) {
	        return o !== s;
	    });
	    if (s.source === this) {
	        s.source = null;
	    }
	};
	
	/**
	 * Consumes values from a Stream (once resumed) and returns a new Stream for
	 * you to optionally push values onto using the provided push / next functions.
	 *
	 * This function forms the basis of many higher-level Stream operations.
	 * It will not cause a paused stream to immediately resume, but behaves more
	 * like a 'through' stream, handling values as they are read.
	 *
	 * @id consume
	 * @section Transforms
	 * @name Stream.consume(f)
	 * @param {Function} f - the function to handle errors and values
	 * @api public
	 *
	 * var filter = function (f, source) {
	 *     return source.consume(function (err, x, push, next) {
	 *         if (err) {
	 *             // pass errors along the stream and consume next value
	 *             push(err);
	 *             next();
	 *         }
	 *         else if (x === _.nil) {
	 *             // pass nil (end event) along the stream
	 *             push(null, x);
	 *         }
	 *         else {
	 *             // pass on the value only if the value passes the predicate
	 *             if (f(x)) {
	 *                 push(null, x);
	 *             }
	 *             next();
	 *         }
	 *     });
	 * };
	 */
	
	Stream.prototype.consume = function (f) {
	    var self = this;
	    while (self._delegate) {
	        self = self._delegate;
	    }
	    var s = new Stream();
	    var _send = s._send;
	    var push = function (err, x) {
	        //console.log(['push', err, x, s.paused]);
	        if (s._nil_seen) {
	            throw new Error('Can not write to stream after nil');
	        }
	        if (x === nil) {
	            // ended, remove consumer from source
	            s._nil_seen = true;
	            self._removeConsumer(s);
	        }
	        if (s.paused) {
	            if (err) {
	                s._outgoing.push(new StreamError(err));
	            }
	            else {
	                s._outgoing.push(x);
	            }
	        }
	        else {
	            _send.call(s, err, x);
	        }
	    };
	    var async;
	    var next_called;
	    var next = function (s2) {
	        //console.log(['next', async]);
	        if (s._nil_seen) {
	            throw new Error('Can not call next after nil');
	        }
	        if (s2) {
	            // we MUST pause to get the redirect object into the _incoming
	            // buffer otherwise it would be passed directly to _send(),
	            // which does not handle StreamRedirect objects!
	            var _paused = s.paused;
	            if (!_paused) {
	                s.pause();
	            }
	            s.write(new StreamRedirect(s2));
	            if (!_paused) {
	                s.resume();
	            }
	        }
	        else if (async) {
	            s.resume();
	        }
	        else {
	            next_called = true;
	        }
	    };
	    s._send = function (err, x) {
	        async = false;
	        next_called = false;
	        s._in_consume_cb = true;
	
	        f(err, x, push, next);
	
	        s._in_consume_cb = false;
	        async = true;
	
	        // Don't pause if x is nil -- as next will never be called after
	        if (!next_called && x !== nil) {
	            s.pause();
	        }
	
	        if (s._repeat_resume) {
	            s._repeat_resume = false;
	            s.resume();
	        }
	    };
	    self._addConsumer(s);
	    self._already_consumed = true;
	    return s;
	};
	exposeMethod('consume');
	
	/**
	 * Consumes a single item from the Stream. Unlike consume, this function will
	 * not provide a new stream for you to push values onto, and it will unsubscribe
	 * as soon as it has a single error, value or nil from the source.
	 *
	 * You probably won't need to use this directly, but it is used internally by
	 * some functions in the Highland library.
	 *
	 * @id pull
	 * @section Consumption
	 * @name Stream.pull(f)
	 * @param {Function} f - the function to handle data
	 * @api public
	 *
	 * xs.pull(function (err, x) {
	 *     // do something
	 * });
	 */
	
	Stream.prototype.pull = function (f) {
	    var s = this.consume(function (err, x) {
	        s.source._removeConsumer(s);
	        f(err, x);
	    });
	    s.id = 'pull:' + s.id;
	    s.resume();
	};
	
	/**
	 * Writes a value to the Stream. If the Stream is paused it will go into the
	 * Stream's incoming buffer, otherwise it will be immediately processed and
	 * sent to the Stream's consumers (if any). Returns false if the Stream is
	 * paused, true otherwise. This lets Node's pipe method handle back-pressure.
	 *
	 * You shouldn't need to call this yourself, but it may be called by Node
	 * functions which treat Highland Streams as a [Node Writable Stream](http://nodejs.org/api/stream.html#stream_class_stream_writable).
	 *
	 * Only call this function on streams that were constructed with no source
	 * (i.e., with `_()`).
	
	 * @id write
	 * @section Stream Objects
	 * @name Stream.write(x)
	 * @param x - the value to write to the Stream
	 * @api public
	 *
	 * var xs = _();
	 * xs.write(1);
	 * xs.write(2);
	 * xs.end();
	 *
	 * xs.toArray(function (ys) {
	 *     // ys will be [1, 2]
	 * });
	 *
	 * // Do *not* do this.
	 * var xs2 = _().toArray(_.log);
	 * xs2.write(1); // This call is illegal.
	 */
	
	Stream.prototype.write = function (x) {
	    if (this.paused) {
	        this._incoming.push(x);
	    }
	    else {
	        if (_._isStreamError(x)) {
	            this._send(x.error);
	        }
	        else {
	            this._send(null, x);
	        }
	    }
	    return !this.paused;
	};
	
	/**
	 * Forks a stream, allowing you to add additional consumers with shared
	 * back-pressure. A stream forked to multiple consumers will only pull values
	 * from it's source as fast as the slowest consumer can handle them.
	 *
	 * *Deprecation warning:* It is currently possible to `fork` a stream after
	 * [consuming](#consume) it (e.g., via a [transform](#Transforms)). This will
	 * no longer be possible in the next major release. If you are going to `fork`
	 * a stream, always call `fork` on it.
	 *
	 * @id fork
	 * @section Higher-order Streams
	 * @name Stream.fork()
	 * @api public
	 *
	 * var xs = _([1, 2, 3, 4]);
	 * var ys = xs.fork();
	 * var zs = xs.fork();
	 *
	 * // no values will be pulled from xs until zs also resume
	 * ys.resume();
	 *
	 * // now both ys and zs will get values from xs
	 * zs.resume();
	 */
	
	// Hack our way around the fact that util.deprecate is all-or-nothing for a
	// function.
	var warnForkAfterConsume = deprecate(function () {
	}, 'Highland: Calling Stream.fork() on a stream that has already been consumed is deprecated. Always call fork() on a stream that is meant to be forked.');
	
	Stream.prototype.fork = function () {
	    if (this._already_consumed) {
	        // Trigger deprecation warning.
	        warnForkAfterConsume();
	    }
	
	    var s = new Stream();
	    s.id = 'fork:' + s.id;
	    s.source = this;
	    this._consumers.push(s);
	    this._checkBackPressure();
	    return s;
	};
	
	/**
	 * Observes a stream, allowing you to handle values as they are emitted, without
	 * adding back-pressure or causing data to be pulled from the source. This can
	 * be useful when you are performing two related queries on a stream where one
	 * would block the other. Just be aware that a slow observer could fill up it's
	 * buffer and cause memory issues. Where possible, you should use [fork](#fork).
	 *
	 * @id observe
	 * @section Higher-order Streams
	 * @name Stream.observe()
	 * @api public
	 *
	 * var xs = _([1, 2, 3, 4]);
	 * var ys = xs.fork();
	 * var zs = xs.observe();
	 *
	 * // now both zs and ys will receive data as fast as ys can handle it
	 * ys.resume();
	 */
	
	Stream.prototype.observe = function () {
	    var s = new Stream();
	    s.id = 'observe:' + s.id;
	    s.source = this;
	    s._is_observer = true;
	    this._observers.push(s);
	    return s;
	};
	
	/**
	 * Extracts errors from a Stream and applies them to an error handler
	 * function. Returns a new Stream with the errors removed (unless the error
	 * handler chooses to rethrow them using `push`). Errors can also be
	 * transformed and put back onto the Stream as values.
	 *
	 * @id errors
	 * @section Transforms
	 * @name Stream.errors(f)
	 * @param {Function} f - the function to pass all errors to
	 * @api public
	 *
	 * getDocument.errors(function (err, push) {
	 *     if (err.statusCode === 404) {
	 *         // not found, return empty doc
	 *         push(null, {});
	 *     }
	 *     else {
	 *         // otherwise, re-throw the error
	 *         push(err);
	 *     }
	 * });
	 */
	
	Stream.prototype.errors = function (f) {
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            f(err, push);
	            next();
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else {
	            push(null, x);
	            next();
	        }
	    });
	};
	exposeMethod('errors');
	
	/**
	 * Like the [errors](#errors) method, but emits a Stream end marker after
	 * an Error is encountered.
	 *
	 * @id stopOnError
	 * @section Transforms
	 * @name Stream.stopOnError(f)
	 * @param {Function} f - the function to handle an error
	 * @api public
	 *
	 * brokenStream.stopOnError(function (err) {
	 *     //console.error('Something broke: ' + err);
	 * });
	 */
	
	Stream.prototype.stopOnError = function (f) {
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            f(err, push);
	            push(null, nil);
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else {
	            push(null, x);
	            next();
	        }
	    });
	};
	exposeMethod('stopOnError');
	
	/**
	 * Iterates over every value from the Stream, calling the iterator function
	 * on each of them. This method consumes the Stream.
	 *
	 * If an error from the Stream reaches the `each` call, it will emit an
	 * error event (which will cause it to throw if unhandled).
	 *
	 * While `each` consumes the stream, it is possible to chain [done](#done) (and
	 * *only* `done`) after it.
	 *
	 * @id each
	 * @section Consumption
	 * @name Stream.each(f)
	 * @param {Function} f - the iterator function
	 * @api public
	 *
	 * _([1, 2, 3, 4]).each(function (x) {
	 *     // will be called 4 times with x being 1, 2, 3 and 4
	 * });
	 */
	
	Stream.prototype.each = function (f) {
	    var self = this;
	    var s = this.consume(function (err, x, push, next) {
	        if (err) {
	            self.emit('error', err);
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else {
	            f(x);
	            next();
	        }
	    });
	    s.resume();
	    return s;
	};
	exposeMethod('each');
	
	/**
	 * Applies all values from a Stream as arguments to a function. This method consumes the stream.
	 * `f` will always be called when the `nil` token is encountered, even when the stream is empty.
	 *
	 * @id apply
	 * @section Consumption
	 * @name Stream.apply(f)
	 * @param {Function} f - the function to apply arguments to
	 * @api public
	 *
	 * _([1, 2, 3]).apply(function (a, b, c) {
	 *     // a === 1
	 *     // b === 2
	 *     // c === 3
	 * });
	 *
	 * _([1, 2, 3]).apply(function (a) {
	 *     // arguments.length === 3
	 *     // a === 1
	 * });
	 */
	
	Stream.prototype.apply = function (f) {
	    return this.toArray(function (args) {
	        f.apply(null, args);
	    });
	};
	exposeMethod('apply');
	
	/**
	 * Collects all values from a Stream into an Array and calls a function with
	 * the result. This method consumes the stream.
	 *
	 * If an error from the Stream reaches the `toArray` call, it will emit an
	 * error event (which will cause it to throw if unhandled).
	 *
	 * @id toArray
	 * @section Consumption
	 * @name Stream.toArray(f)
	 * @param {Function} f - the callback to provide the completed Array to
	 * @api public
	 *
	 * _([1, 2, 3, 4]).toArray(function (x) {
	 *     // parameter x will be [1,2,3,4]
	 * });
	 */
	
	Stream.prototype.toArray = function (f) {
	    var self = this;
	    return this.collect().pull(function (err, x) {
	        if (err) {
	            self.emit('error', err);
	        }
	        else {
	            f(x);
	        }
	    });
	};
	
	/**
	 * Calls a function once the Stream has ended. This method consumes the stream.
	 * If the Stream has already ended, the function is called immediately.
	 *
	 * If an error from the Stream reaches the `done` call, it will emit an
	 * error event (which will cause it to throw if unhandled).
	 *
	 * As a special case, it is possible to chain `done` after a call to
	 * [each](#each) even though both methods consume the stream.
	 *
	 * @id done
	 * @section Consumption
	 * @name Stream.done(f)
	 * @param {Function} f - the callback
	 * @api public
	 *
	 * var total = 0;
	 * _([1, 2, 3, 4]).each(function (x) {
	 *     total += x;
	 * }).done(function () {
	 *     // total will be 10
	 * });
	 */
	
	Stream.prototype.done = function (f) {
	    if (this.ended) {
	        f();
	        return null;
	    }
	    var self = this;
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            self.emit('error', err);
	        }
	        else if (x === nil) {
	            f();
	        }
	        else {
	            next();
	        }
	    }).resume();
	};
	
	/**
	 * Creates a new Stream of transformed values by applying a function to each
	 * value from the source. The transformation function can be replaced with
	 * a non-function value for convenience, and it will emit that value
	 * for every data event on the source Stream.
	 *
	 * *Deprecation warning:* The use of the convenience non-function argument for
	 * `map` is deprecated and will be removed in the next major version.
	 *
	 * @id map
	 * @section Transforms
	 * @name Stream.map(f)
	 * @param {Function} f - the transformation function or value to map to
	 * @api public
	 *
	 * var doubled = _([1, 2, 3, 4]).map(function (x) {
	 *     return x * 2;
	 * });
	 */
	
	// Hack our way around the fact that util.deprecate is all-or-nothing for a
	// function.
	var warnMapWithValue = deprecate(function() {
	}, 'Highland: Calling Stream.map() with a non-function argument is deprecated.');
	
	Stream.prototype.map = function (f) {
	    if (!_.isFunction(f)) {
	        warnMapWithValue();
	        var val = f;
	        f = function () {
	            return val;
	        };
	    }
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(err, x);
	        }
	        else {
	            var fnVal, fnErr;
	            try {
	                fnVal = f(x);
	            }
	            catch (e) {
	                fnErr = e;
	            }
	            push(fnErr, fnVal);
	            next();
	        }
	    });
	};
	exposeMethod('map');
	
	/**
	 * Creates a new Stream which applies a function to each value from the source
	 * and re-emits the source value. Useful when you want to mutate the value or
	 * perform side effects
	 *
	 * @id doto
	 * @section Transforms
	 * @name Stream.doto(f)
	 * @param {Function} f - the function to apply
	 * @api public
	 *
	 * var appended = _([[1], [2], [3], [4]]).doto(function (x) {
	 *     x.push(1);
	 * });
	 *
	 * _([1, 2, 3]).doto(console.log)
	 * // 1
	 * // 2
	 * // 3
	 * // => 1, 2, 3
	 */
	
	Stream.prototype.doto = function (f) {
	    return this.map(function (x) {
	        f(x);
	        return x;
	    });
	};
	exposeMethod('doto');
	
	/**
	 * An alias for the [doto](#doto) method.
	 *
	 * @id tap
	 * @section Transforms
	 * @name Stream.tap(f)
	 * @param {Function} f - the function to apply
	 * @api public
	 *
	 * _([1, 2, 3]).tap(console.log)
	 */
	
	Stream.prototype.tap = Stream.prototype.doto;
	_.tap = _.doto;
	
	/**
	 * Limits number of values through the stream to a maximum of number of values
	 * per window. Errors are not limited but allowed to pass through as soon as
	 * they are read from the source.
	 *
	 * @id ratelimit
	 * @section Transforms
	 * @name Stream.ratelimit(num, ms)
	 * @param {Number} num - the number of operations to perform per window
	 * @param {Number} ms - the window of time to limit the operations in (in ms)
	 * @api public
	 *
	 * _([1, 2, 3, 4, 5]).ratelimit(2, 100);
	 *
	 * // after 0ms => 1, 2
	 * // after 100ms => 1, 2, 3, 4
	 * // after 200ms => 1, 2, 3, 4, 5
	 */
	
	Stream.prototype.ratelimit = function (num, ms) {
	    if (num < 1) {
	        throw new Error('Invalid number of operations per ms: ' + num);
	    }
	    var sent = 0;
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else {
	            if (sent < num) {
	                sent++;
	                push(null, x);
	                next();
	            }
	            else {
	                setTimeout(function () {
	                    sent = 1;
	                    push(null, x);
	                    next();
	                }, ms);
	            }
	        }
	    });
	};
	exposeMethod('ratelimit');
	
	/**
	 * Creates a new Stream of values by applying each item in a Stream to an
	 * iterator function which must return a (possibly empty) Stream. Each item on
	 * these result Streams are then emitted on a single output Stream.
	 *
	 * This transform is functionally equivalent to `.map(f).sequence()`.
	 *
	 * @id flatMap
	 * @section Higher-order Streams
	 * @name Stream.flatMap(f)
	 * @param {Function} f - the iterator function
	 * @api public
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 * filenames.flatMap(readFile)
	 */
	
	Stream.prototype.flatMap = function (f) {
	    return this.map(f).sequence();
	};
	exposeMethod('flatMap');
	
	/**
	 * Retrieves values associated with a given property from all elements in
	 * the collection.
	 *
	 * @id pluck
	 * @section Transforms
	 * @name Stream.pluck(property)
	 * @param {String} prop - the property to which values should be associated
	 * @api public
	 *
	 * var docs = [
	 *     {type: 'blogpost', title: 'foo'},
	 *     {type: 'blogpost', title: 'bar'},
	 *     {type: 'comment', title: 'baz'}
	 * ];
	 *
	 * _(docs).pluck('title').toArray(function (xs) {
	 *    // xs is now ['foo', 'bar', 'baz']
	 * });
	 */
	
	Stream.prototype.pluck = function (prop) {
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(err, x);
	        }
	        else if (_.isObject(x)) {
	            push(null, x[prop]);
	            next();
	        }
	        else {
	            push(new Error(
	                'Expected Object, got ' + (typeof x)
	            ));
	            next();
	        }
	    });
	};
	exposeMethod('pluck');
	
	/**
	 * Only applies the transformation strategy on Objects.
	 * This helper is used in `pick` and `pickBy`
	 **/
	
	var objectOnly = _.curry(function(strategy, x) {
	    if (_.isObject(x)) {
	        return strategy(x);
	    }
	    else {
	        throw new Error(
	            'Expected Object, got ' + (typeof x)
	        );
	    }
	});
	
	
	/**
	 *
	 * Retrieves copies of all the elements in the collection
	 * that satisfy a given predicate. Note: When using ES3,
	 * only enumerable elements are selected. Both enumerable
	 * and non-enumerable elements are selected when using ES5.
	 *
	 * @id pickBy
	 * @section Transforms
	 * @name Stream.pickBy(f)
	 * @param {Function} f - the predicate function
	 * @api public
	 *
	 *  var dogs = [
	 *      {breed: 'chihuahua', name: 'Princess', age: 5},
	 *      {breed: 'labrador', name: 'Rocky', age: 3},
	 *      {breed: 'german-shepherd', name: 'Waffles', age: 9}
	 *  ];
	
	 *  _(dogs).pickBy(function (key, value) {
	 *      return value > 4;
	 *  }).toArray(function (xs) {
	 *    // xs is now:
	 *    [
	 *      { age: 5 },
	 *      {},
	 *      { age: 9 }
	 *    ]
	 *  });
	 */
	
	Stream.prototype.pickBy = function (f) {
	    return this.map(objectOnly(function (x) {
	        var out = {};
	
	        // prevents testing overridden properties multiple times.
	        var seen = isES5 ? Object.create(null) : {};
	        var obj = x;  // variable used to traverse prototype chain
	        function testAndAdd (prop) {
	            if (seen[prop] !== true && f(prop, x[prop])) {
	                out[prop] = x[prop];
	                seen[prop] = true;
	            }
	        }
	        if (isES5) {
	            do {
	                Object.getOwnPropertyNames(obj).forEach(testAndAdd);
	                obj = Object.getPrototypeOf(obj);
	            } while (obj);
	        }
	        else {
	            for (var k in x) {
	                testAndAdd(k);
	            }
	        }
	        return out;
	    }));
	};
	exposeMethod('pickBy');
	
	/**
	 *
	 * Retrieves copies of all elements in the collection,
	 * with only the whitelisted keys. If one of the whitelisted
	 * keys does not exist, it will be ignored.
	 *
	 * @id pick
	 * @section Transforms
	 * @name Stream.pick(properties)
	 * @param {Array} properties - property names to white filter
	 * @api public
	 *
	 * var dogs = [
	 *      {breed: 'chihuahua', name: 'Princess', age: 5},
	 *      {breed: 'labrador', name: 'Rocky', age: 3},
	 *      {breed: 'german-shepherd', name: 'Waffles', age: 9}
	 * ];
	 *
	 * _(dogs).pick(['breed', 'age']).toArray(function (xs) {
	 *       // xs is now:
	 *       [
	 *           {breed: 'chihuahua', age: 5},
	 *           {breed: 'labrador', age: 3},
	 *           {breed: 'german-shepherd', age: 9}
	 *       ]
	 * });
	 *
	 * _(dogs).pick(['owner']).toArray(function (xs) {
	 *      // xs is now:
	 *      [
	 *          {},
	 *          {},
	 *          {}
	 *      ]
	 * });*/
	
	Stream.prototype.pick = function (properties) {
	    return this.map(objectOnly(function(x) {
	        var out = {};
	        for (var i = 0, length = properties.length; i < length; i++) {
	            var p = properties[i];
	            if (p in x) {
	                out[p] = x[p];
	            }
	        }
	        return out;
	    }));
	};
	exposeMethod('pick');
	
	/**
	 * Creates a new Stream that includes only the values that pass a truth test.
	 *
	 * @id filter
	 * @section Transforms
	 * @name Stream.filter(f)
	 * @param {Function} f - the truth test function
	 * @api public
	 *
	 * var evens = _([1, 2, 3, 4]).filter(function (x) {
	 *     return x % 2 === 0;
	 * });
	 */
	
	Stream.prototype.filter = function (f) {
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(err, x);
	        }
	        else {
	            var fnVal, fnErr;
	            try {
	                fnVal = f(x);
	            }
	            catch (e) {
	                fnErr = e;
	            }
	
	            if (fnErr) {
	                push(fnErr);
	            }
	            else if (fnVal) {
	                push(null, x);
	            }
	            next();
	        }
	    });
	};
	exposeMethod('filter');
	
	/**
	 * Filters using a predicate which returns a Stream. If you need to check
	 * against an asynchronous data source when filtering a Stream, this can
	 * be convenient. The Stream returned from the filter function should have
	 * a Boolean as it's first value (all other values on the Stream will be
	 * disregarded).
	 *
	 * @id flatFilter
	 * @section Higher-order Streams
	 * @name Stream.flatFilter(f)
	 * @param {Function} f - the truth test function which returns a Stream
	 * @api public
	 *
	 * var checkExists = _.wrapCallback(fs.access);
	 *
	 * filenames.flatFilter(checkExists)
	 */
	
	Stream.prototype.flatFilter = function (f) {
	    return this.flatMap(function (x) {
	        return f(x).take(1).otherwise(errorStream())
	        .flatMap(function (bool) {
	            return _(bool ? [x] : []);
	        });
	    });
	
	    function errorStream() {
	        return _(function (push) {
	            push(new Error('Stream returned by function was empty.'));
	            push(null, _.nil);
	        });
	    }
	};
	exposeMethod('flatFilter');
	
	/**
	 * The inverse of [filter](#filter).
	 *
	 * @id reject
	 * @section Transforms
	 * @name Stream.reject(f)
	 * @param {Function} f - the truth test function
	 * @api public
	 *
	 * var odds = _([1, 2, 3, 4]).reject(function (x) {
	 *     return x % 2 === 0;
	 * });
	 */
	
	Stream.prototype.reject = function (f) {
	    return this.filter(_.compose(_.not, f));
	};
	exposeMethod('reject');
	
	/**
	 * A convenient form of [filter](#filter), which returns the first object from a
	 * Stream that passes the provided truth test.
	 *
	 * @id find
	 * @section Transforms
	 * @name Stream.find(f)
	 * @param {Function} f - the truth test function which returns a Stream
	 * @api public
	 *
	 * var docs = [
	 *     {type: 'blogpost', title: 'foo'},
	 *     {type: 'blogpost', title: 'bar'},
	 *     {type: 'comment', title: 'foo'}
	 * ];
	 *
	 * var f = function (x) {
	 *     return x.type == 'blogpost';
	 * };
	 *
	 * _(docs).find(f);
	 * // => {type: 'blogpost', title: 'foo'}
	 *
	 * // example with partial application
	 * var firstBlogpost = _.find(f);
	 *
	 * firstBlogpost(docs)
	 * // => {type: 'blogpost', title: 'foo'}
	 */
	
	Stream.prototype.find = function (f) {
	    return this.filter(f).take(1);
	};
	exposeMethod('find');
	
	/**
	 * A convenient form of [where](#where), which returns the first object from a
	 * Stream that matches a set of property values. findWhere is to [where](#where) as [find](#find) is to [filter](#filter).
	 *
	 * @id findWhere
	 * @section Transforms
	 * @name Stream.findWhere(props)
	 * @param {Object} props - the properties to match against
	 * @api public
	 *
	 * var docs = [
	 *     {type: 'blogpost', title: 'foo'},
	 *     {type: 'blogpost', title: 'bar'},
	 *     {type: 'comment', title: 'foo'}
	 * ];
	 *
	 * _(docs).findWhere({type: 'blogpost'})
	 * // => {type: 'blogpost', title: 'foo'}
	 *
	 * // example with partial application
	 * var firstBlogpost = _.findWhere({type: 'blogpost'});
	 *
	 * firstBlogpost(docs)
	 * // => {type: 'blogpost', title: 'foo'}
	 */
	
	Stream.prototype.findWhere = function (props) {
	    return this.where(props).take(1);
	};
	exposeMethod('findWhere');
	
	
	/**
	 * A convenient form of [reduce](#reduce), which groups items based on a function or property name
	 *
	 * @id group
	 * @section Transforms
	 * @name Stream.group(f)
	 * @param {Function | String} f - the function or property name on which to group,
	 *                              toString() is called on the result of a function.
	 * @api public
	 *
	 * var docs = [
	 *     {type: 'blogpost', title: 'foo'},
	 *     {type: 'blogpost', title: 'bar'},
	 *     {type: 'comment', title: 'foo'}
	 * ];
	 *
	 * var f = function (x) {
	 *     return x.type;
	 * };
	 *
	 * _(docs).group(f); OR _(docs).group('type');
	 * // => {
	 * // =>    'blogpost': [{type: 'blogpost', title: 'foo'}, {type: 'blogpost', title: 'bar'}]
	 * // =>    'comment': [{type: 'comment', title: 'foo'}]
	 * // =>  }
	 *
	 */
	
	Stream.prototype.group = function (f) {
	    var lambda = _.isString(f) ? _.get(f) : f;
	    return this.reduce({}, function (m, o) {
	        var key = lambda(o);
	        if (!hasOwn.call(m, key)) { m[key] = []; }
	        m[key].push(o);
	        return m;
	    });
	};
	exposeMethod('group');
	
	/**
	 * Filters a Stream to drop all non-truthy values.
	 *
	 * @id compact
	 * @section Transforms
	 * @name Stream.compact()
	 * @api public
	 *
	 * var compacted = _([0, 1, false, 3, null, undefined, 6]).compact();
	 * // => 1, 3, 6
	 */
	
	Stream.prototype.compact = function () {
	    return this.filter(function (x) {
	        return x;
	    });
	};
	exposeMethod('compact');
	
	/**
	 * A convenient form of [filter](#filter), which returns all objects from a Stream
	 * which match a set of property values.
	 *
	 * @id where
	 * @section Transforms
	 * @name Stream.where(props)
	 * @param {Object} props - the properties to match against
	 * @api public
	 *
	 * var docs = [
	 *     {type: 'blogpost', title: 'foo'},
	 *     {type: 'blogpost', title: 'bar'},
	 *     {type: 'comment', title: 'foo'}
	 * ];
	 *
	 * _(docs).where({title: 'foo'})
	 * // => {type: 'blogpost', title: 'foo'}
	 * // => {type: 'comment', title: 'foo'}
	 *
	 * // example with partial application
	 * var getBlogposts = _.where({type: 'blogpost'});
	 *
	 * getBlogposts(docs)
	 * // => {type: 'blogpost', title: 'foo'}
	 * // => {type: 'blogpost', title: 'bar'}
	 */
	
	Stream.prototype.where = function (props) {
	    return this.filter(function (x) {
	        for (var k in props) {
	            if (x[k] !== props[k]) {
	                return false;
	            }
	        }
	        return true;
	    });
	};
	exposeMethod('where');
	
	/**
	 * Filters out all duplicate values from the stream and keeps only the first
	 * occurence of each value, using the provided function to define equality.
	 *
	 * Note:
	 *
	 * - Memory: In order to guarantee that each unique item is chosen only once,
	 *   we need to keep an internal buffer of all unique values. This may outgrow
	 *   the available memory if you are not cautious about the size of your stream
	 *   and the number of unique objects you may receive on it.
	 * - Errors: The comparison function should never throw an error. However, if
	 *   it does, this transform will emit an error for each all that throws. This
	 *   means that one value may turn into multiple errors.
	 *
	 * @id uniqBy
	 * @section Transforms
	 * @name Stream.uniqBy(compare)
	 * @param {Function} compare - custom equality predicate
	 * @api public
	 *
	 * var colors = [ 'blue', 'red', 'red', 'yellow', 'blue', 'red' ]
	 *
	 * _(colors).uniqBy(function(a, b) { return a[1] === b[1]; })
	 * // => 'blue'
	 * // => 'red'
	 *
	 */
	
	Stream.prototype.uniqBy = function (compare) {
	    var uniques = [];
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(err, x);
	        }
	        else {
	            var seen = false;
	            var hasErr;
	            for (var i = 0, len = uniques.length; i < len; i++) {
	                try {
	                    seen = compare(x, uniques[i]);
	                }
	                catch (e) {
	                    hasErr = e;
	                    seen = true;
	                }
	                if (seen) {
	                    break;
	                }
	            }
	            if (!seen) {
	                uniques.push(x);
	                push(null, x);
	            }
	            if (hasErr) {
	                push(hasErr);
	            }
	            next();
	        }
	    });
	};
	exposeMethod('uniqBy');
	
	/**
	 * Filters out all duplicate values from the stream and keeps only the first
	 * occurence of each value, using `===` to define equality.
	 *
	 * Like [uniqBy](#uniqBy), this transform needs to store a buffer containing
	 * all unique values that has been encountered. Be careful about using this
	 * transform on a stream that has many unique values.
	 *
	 * @id uniq
	 * @section Transforms
	 * @name Stream.uniq()
	 * @api public
	 *
	 * var colors = [ 'blue', 'red', 'red', 'yellow', 'blue', 'red' ]
	 *
	 * _(colors).uniq()
	 * // => 'blue'
	 * // => 'red'
	 * // => 'yellow'
	 */
	
	Stream.prototype.uniq = function () {
	    if (!_.isUndefined(_global.Set)) {
	        var uniques = new Set(),
	            size = uniques.size;
	
	        return this.consume(function (err, x, push, next) {
	            if (err) {
	                push(err);
	                next();
	            }
	            else if (x === nil) {
	                push(err, x);
	            }
	            // pass NaN through as Set does not respect strict
	            // equality in this case.
	            else if (x !== x) {
	                push(null, x);
	                next();
	            }
	            else {
	                uniques.add(x);
	                if (uniques.size > size) {
	                    size = uniques.size;
	                    push(null, x);
	                }
	                next();
	            }
	        });
	    }
	    return this.uniqBy(function (a, b) {
	        return a === b;
	    });
	};
	exposeMethod('uniq');
	
	/**
	 * Takes a `finite` stream of streams and returns a stream where the first
	 * element from each separate stream is combined into a single data event,
	 * followed by the second elements of each stream and so on until the shortest
	 * input stream is exhausted.
	 *
	 * *Note:* This transform will be renamed `zipAll` in the next major version
	 * release.
	 *
	 * @id zipAll0
	 * @section Higher-order Streams
	 * @name Stream.zipAll0()
	 * @api public
	 *
	 * _([
	 *     _([1, 2, 3]),
	 *     _([4, 5, 6]),
	 *     _([7, 8, 9]),
	 *     _([10, 11, 12])
	 * ]).zipAll0()
	 * // => [ [ 1, 4, 7, 10 ], [ 2, 5, 8, 11 ], [ 3, 6, 9, 12 ] ]
	 *
	 * // shortest stream determines length of output stream
	 * _([
	 *     _([1, 2, 3, 4]),
	 *     _([5, 6, 7, 8]),
	 *     _([9, 10, 11, 12]),
	 *     _([13, 14])
	 * ]).zipAll0()
	 * // => [ [ 1, 5, 9, 13 ], [ 2, 6, 10, 14 ] ]
	 */
	
	Stream.prototype.zipAll0 = function () {
	    var returned = 0;
	    var z = [];
	    var finished = false;
	
	    function nextValue(index, max, src, push, next) {
	        src.pull(function (err, x) {
	            if (err) {
	                push(err);
	                nextValue(index, max, src, push, next);
	            }
	            else if (x === _.nil) {
	                if (!finished) {
	                    finished = true;
	                    push(null, nil);
	                }
	            }
	            else {
	                returned++;
	                z[index] = x;
	                if (returned === max) {
	                    push(null, z);
	                    next();
	                }
	            }
	        });
	    }
	
	    return this.collect().flatMap(function (array) {
	        if (!array.length) {
	            return _([]);
	        }
	
	        return _(function (push, next) {
	            returned = 0;
	            z = [];
	            for (var i = 0, length = array.length; i < length; i++) {
	                nextValue(i, length, array[i], push, next);
	            }
	        });
	    });
	
	};
	exposeMethod('zipAll0');
	
	/**
	 * Takes a stream and a `finite` stream of `N` streams
	 * and returns a stream of the corresponding `(N+1)`-tuples.
	 *
	 * *Note:* This transform will be renamed `zipEach` in the next major version
	 * release.
	 *
	 * @id zipAll
	 * @section Higher-order Streams
	 * @name Stream.zipAll(ys)
	 * @param {Array | Stream} ys - the array of streams to combine values with
	 * @api public
	 *
	 * _([1,2,3]).zipAll([[4, 5, 6], [7, 8, 9], [10, 11, 12]])
	 * // => [ [ 1, 4, 7, 10 ], [ 2, 5, 8, 11 ], [ 3, 6, 9, 12 ] ]
	 *
	 * // shortest stream determines length of output stream
	 * _([1, 2, 3, 4]).zipAll([[5, 6, 7, 8], [9, 10, 11, 12], [13, 14]])
	 * // => [ [ 1, 5, 9, 13 ], [ 2, 6, 10, 14 ] ]
	 */
	
	Stream.prototype.zipAll = function (ys) {
	    return _([this]).concat(_(ys).map(_)).zipAll0();
	};
	exposeMethod('zipAll');
	
	/**
	 * Takes two Streams and returns a Stream of corresponding pairs. The size of
	 * the resulting stream is the smaller of the two source streams.
	 *
	 * @id zip
	 * @section Higher-order Streams
	 * @name Stream.zip(ys)
	 * @param {Array | Stream} ys - the other stream to combine values with
	 * @api public
	 *
	 * _(['a', 'b', 'c']).zip([1, 2, 3])  // => ['a', 1], ['b', 2], ['c', 3]
	 *
	 * _(['a', 'b', 'c']).zip(_([1]))  // => ['a', 1]
	 */
	
	Stream.prototype.zip = function (ys) {
	    return _([this, _(ys)]).zipAll0();
	};
	exposeMethod('zip');
	
	/**
	 * Takes one Stream and batches incoming data into arrays of given length
	 *
	 * @id batch
	 * @section Transforms
	 * @name Stream.batch(n)
	 * @param {Number} n - length of the array to batch
	 * @api public
	 *
	 * _([1, 2, 3, 4, 5]).batch(2)  // => [1, 2], [3, 4], [5]
	 */
	
	Stream.prototype.batch = function (n) {
	    return this.batchWithTimeOrCount(-1, n);
	};
	exposeMethod('batch');
	
	/**
	 * Takes one Stream and batches incoming data within a maximum time frame
	 * into arrays of a maximum length.
	 *
	 * @id batchWithTimeOrCount
	 * @section Transforms
	 * @name Stream.batchWithTimeOrCount(ms, n)
	 * @param {Number} ms - the maximum milliseconds to buffer a batch
	 * @param {Number} n - the maximum length of the array to batch
	 * @api public
	 *
	 * _(function (push) {
	 *     push(1);
	 *     push(2);
	 *     push(3);
	 *     setTimeout(push, 20, 4);
	 * }).batchWithTimeOrCount(10, 2)
	 *
	 * // => [1, 2], [3], [4]
	 */
	
	Stream.prototype.batchWithTimeOrCount = function (ms, n) {
	    var batched = [],
	        timeout;
	
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            if (batched.length > 0) {
	                push(null, batched);
	                clearTimeout(timeout);
	            }
	
	            push(null, nil);
	        }
	        else {
	            batched.push(x);
	
	            if (batched.length === n) {
	                push(null, batched);
	                batched = [];
	                clearTimeout(timeout);
	            }
	            else if (batched.length === 1 && ms >= 0) {
	                timeout = setTimeout(function () {
	                    push(null, batched);
	                    batched = [];
	                }, ms);
	            }
	
	            next();
	        }
	    });
	};
	exposeMethod('batchWithTimeOrCount');
	
	/**
	 * Creates a new Stream with the separator interspersed between the elements of the source.
	 *
	 * `intersperse` is effectively the inverse of [splitBy](#splitBy).
	 *
	 * @id intersperse
	 * @section Transforms
	 * @name Stream.intersperse(sep)
	 * @param {String} sep - the value to intersperse between the source elements
	 * @api public
	 *
	 * _(['ba', 'a', 'a']).intersperse('n')  // => ba, n, a, n, a
	 * _(['mississippi']).splitBy('ss').intersperse('ss')  // => mi, ss, i, ss, ippi
	 * _(['foo']).intersperse('bar')  // => foo
	 */
	
	Stream.prototype.intersperse = function (separator) {
	    var started = false;
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else {
	            if (started) {
	                push(null, separator);
	            }
	            else {
	                started = true;
	            }
	            push(null, x);
	            next();
	        }
	    });
	};
	exposeMethod('intersperse');
	
	/**
	 * Splits the source Stream by a separator and emits the pieces in between, much like splitting a string.
	 *
	 * `splitBy` is effectively the inverse of [intersperse](#intersperse).
	 *
	 * @id splitBy
	 * @section Transforms
	 * @name Stream.splitBy(sep)
	 * @param {String | RegExp} sep - the separator to split on
	 * @api public
	 *
	 * _(['mis', 'si', 's', 'sippi']).splitBy('ss')  // => mi, i, ippi
	 * _(['ba', 'a', 'a']).intersperse('n').splitBy('n')  // => ba, a, a
	 * _(['foo']).splitBy('bar')  // => foo
	 */
	
	Stream.prototype.splitBy = function (sep) {
	    var decoder = new Decoder();
	    var buffer = false;
	
	    function drain(x, push) {
	        buffer = (buffer || '') + decoder.write(x);
	        var pieces = buffer.split(sep);
	        buffer = pieces.pop();
	
	        pieces.forEach(function (piece) {
	            push(null, piece);
	        });
	    }
	
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            if (_.isString(buffer)) {
	                drain(decoder.end(), push);
	                push(null, buffer);
	            }
	            push(null, nil);
	        }
	        else {
	            drain(x, push);
	            next();
	        }
	    });
	};
	exposeMethod('splitBy');
	
	/**
	 * [splitBy](#splitBy) over newlines.
	 *
	 * @id split
	 * @section Transforms
	 * @name Stream.split()
	 * @api public
	 *
	 * _(['a\n', 'b\nc\n', 'd', '\ne']).split()  // => a, b, c, d, e
	 * _(['a\r\nb\nc']]).split()  // => a, b, c
	 */
	
	Stream.prototype.split = function () {
	    return this.splitBy(/\r?\n/);
	};
	exposeMethod('split');
	
	/**
	 * Creates a new Stream with the values from the source in the range of `start` (inclusive) to `end` (exclusive).
	 * `start` and `end` must be of type `Number`, if `start` is not a `Number` it will default to `0`
	 * and, likewise, `end` will default to `Infinity`: this could result in the whole stream being be
	 * returned.
	 *
	 * @id slice
	 * @section Transforms
	 * @name Stream.slice(start, end)
	 * @param {Number} start - integer representing index to start reading from source (inclusive)
	 * @param {Number} stop - integer representing index to stop reading from source (exclusive)
	 * @api public
	 *
	 * _([1, 2, 3, 4]).slice(1, 3) // => 2, 3
	 */
	
	Stream.prototype.slice = function(start, end) {
	    var index = 0;
	    start = typeof start != 'number' || start < 0 ? 0 : start;
	    end = typeof end != 'number' ? Infinity : end;
	
	    if (start === 0 && end === Infinity) {
	        return this;
	    }
	    else if (start >= end) {
	        return _([]);
	    }
	    var s = this.consume(function (err, x, push, next) {
	        var done = x === nil;
	        if (err) {
	            push(err);
	        }
	        else if (!done && index++ >= start) {
	            push(null, x);
	        }
	
	        if (!done && index < end) {
	            next();
	        }
	        else {
	            push(null, nil);
	        }
	    });
	    s.id = 'slice:' + s.id;
	    return s;
	};
	exposeMethod('slice');
	
	/**
	 * Creates a new Stream with the first `n` values from the source. `n` must be of type `Number`,
	 * if not the whole stream will be returned.
	 *
	 * @id take
	 * @section Transforms
	 * @name Stream.take(n)
	 * @param {Number} n - integer representing number of values to read from source
	 * @api public
	 *
	 * _([1, 2, 3, 4]).take(2) // => 1, 2
	 */
	
	Stream.prototype.take = function (n) {
	    var s = this.slice(0, n);
	    s.id = 'take:' + s.id;
	    return s;
	};
	exposeMethod('take');
	
	/**
	 * Acts as the inverse of [`take(n)`](#take) - instead of returning the first `n` values, it ignores the
	 * first `n` values and then emits the rest. `n` must be of type `Number`, if not the whole stream will
	 * be returned. All errors (even ones emitted before the nth value) will be emitted.
	 *
	 * @id drop
	 * @section Transforms
	 * @name Stream.drop(n)
	 * @param {Number} n - integer representing number of values to read from source
	 * @api public
	 *
	 * _([1, 2, 3, 4]).drop(2) // => 3, 4
	 */
	
	Stream.prototype.drop = function (n) {
	    return this.slice(n, Infinity);
	};
	exposeMethod('drop');
	
	/**
	 * Creates a new Stream with only the first value from the source.
	 *
	 * @id head
	 * @section Transforms
	 * @name Stream.head()
	 * @api public
	 *
	 * _([1, 2, 3, 4]).head() // => 1
	 */
	
	Stream.prototype.head = function () {
	    return this.take(1);
	};
	exposeMethod('head');
	
	/**
	 * Drops all values from the Stream apart from the last one (if any).
	 *
	 * @id last
	 * @section Transforms
	 * @name Stream.last()
	 * @api public
	 *
	 * _([1, 2, 3, 4]).last()  // => 4
	 */
	
	Stream.prototype.last = function () {
	    var nothing = {};
	    var prev = nothing;
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            if (prev !== nothing) {
	                push(null, prev);
	            }
	            push(null, nil);
	        }
	        else {
	            prev = x;
	            next();
	        }
	    });
	};
	exposeMethod('last');
	
	/**
	 * Collects all values together then emits each value individually in sorted
	 * order. The method for sorting the elements is defined by the comparator
	 * function supplied as a parameter.
	 *
	 * The comparison function takes two arguments `a` and `b` and should return
	 *
	 * - a negative number if `a` should sort before `b`.
	 * - a positive number if `a` should sort after `b`.
	 * - zero if `a` and `b` may sort in any order (i.e., they are equal).
	 *
	 * This function must also define a [partial
	 * order](https://en.wikipedia.org/wiki/Partially_ordered_set). If it does not,
	 * the resulting ordering is undefined.
	 *
	 * @id sortBy
	 * @section Transforms
	 * @name Stream.sortBy(f)
	 * @param {Function} f - the comparison function
	 * @api public
	 *
	 * var sorts = _([3, 1, 4, 2]).sortBy(function (a, b) {
	 *     return b - a;
	 * }).toArray(_.log);
	 *
	 * //=> [4, 3, 2, 1]
	 */
	
	Stream.prototype.sortBy = function (f) {
	    return this.collect().invoke('sort', [f]).sequence();
	};
	exposeMethod('sortBy');
	
	/**
	 * Collects all values together then emits each value individually but in sorted order.
	 * The method for sorting the elements is ascending lexical.
	 *
	 * @id sort
	 * @section Transforms
	 * @name Stream.sort()
	 * @api public
	 *
	 * var sorted = _(['b', 'z', 'g', 'r']).sort().toArray(_.log);
	 * // => ['b', 'g', 'r', 'z']
	 */
	
	Stream.prototype.sort = function () {
	    return this.sortBy();
	};
	exposeMethod('sort');
	
	
	/**
	 * Transforms a stream using an arbitrary target transform.
	 *
	 * If `target` is a function, this transform passes the current Stream to it,
	 * returning the result.
	 *
	 * If `target` is a [Duplex
	 * Stream](https://nodejs.org/api/stream.html#stream_class_stream_duplex_1),
	 * this transform pipes the current Stream through it. It will always return a
	 * Highland Stream (instead of the piped to target directly as in
	 * [pipe](#pipe)). Any errors emitted will be propagated as Highland errors.
	 *
	 * @id through
	 * @section Higher-order Streams
	 * @name Stream.through(target)
	 * @param {Function | Duplex Stream} target - the stream to pipe through or a
	 * function to call.
	 * @api public
	 *
	 * function oddDoubler(s) {
	 *     return s.filter(function (x) {
	 *         return x % 2; // odd numbers only
	 *     })
	 *     .map(function (x) {
	 *         return x * 2;
	 *     });
	 * }
	 *
	 * _([1, 2, 3, 4]).through(oddDoubler).toArray(function (xs) {
	 *     // xs will be [2, 6]
	 * });
	 *
	 * // Can also be used with Node Through Streams
	 * _(filenames).through(jsonParser).map(function (obj) {
	 *     // ...
	 * });
	 *
	 * // All errors will be propagated as Highland errors
	 * _(['zz{"a": 1}']).through(jsonParser).errors(function (err) {
	 *   console.log(err); // => SyntaxError: Unexpected token z
	 * });
	 */
	
	Stream.prototype.through = function (target) {
	    var output;
	
	    if (_.isFunction(target)) {
	        return target(this);
	    }
	    else {
	        target.pause();
	        output = _();
	        this.on('error', writeErr);
	        target.on('error', writeErr);
	        return this.pipe(target).pipe(output);
	    }
	
	    function writeErr(err) {
	        output.write(new StreamError(err));
	    }
	};
	exposeMethod('through');
	
	/**
	 * Creates a 'Through Stream', which passes data through a pipeline
	 * of functions or other through Streams. This is particularly useful
	 * when combined with partial application of Highland functions to expose a
	 * Node-compatible Through Stream.
	 *
	 * This is not a method on a Stream, and it only exposed at the top-level
	 * as `_.pipeline`. It takes an arbitrary number of arguments.
	 *
	 * @id pipeline
	 * @section Higher-order Streams
	 * @name _.pipeline(...)
	 * @api public
	 *
	 * var through = _.pipeline(
	 *     _.map(parseJSON),
	 *     _.filter(isBlogpost),
	 *     _.reduce(collectCategories)
	 *     _.through(otherPipeline)
	 * );
	 *
	 * readStream.pipe(through).pipe(outStream);
	 *
	 * // Alternatively, you can use pipeline to manipulate a stream in
	 * // the chained method call style:
	 *
	 * var through2 = _.pipeline(function (s) {
	 *     return s.map(parseJSON).filter(isBlogpost); // etc.
	 * });
	 */
	
	_.pipeline = function (/*through...*/) {
	    if (!arguments.length) {
	        return _();
	    }
	    var start = arguments[0], rest, startHighland;
	    if (!_.isStream(start) && !_.isFunction(start.resume)) {
	        // not a Highland stream or Node stream, start with empty stream
	        start = _();
	        startHighland = start;
	        rest = slice.call(arguments);
	    }
	    else {
	        // got a stream as first argument, co-erce to Highland stream
	        startHighland = _(start);
	        rest = slice.call(arguments, 1);
	    }
	
	    var end = rest.reduce(function (src, dest) {
	        return src.through(dest);
	    }, startHighland);
	
	    var wrapper = _(function (push, next) {
	        end.pull(function (err, x) {
	            push(err, x);
	            if (x !== nil) {
	                next();
	            }
	        });
	    });
	
	    wrapper.write = function (x) {
	        return start.write(x);
	    };
	
	    wrapper.end = function () {
	        return start.end();
	    };
	
	    start.on('drain', function () {
	        wrapper.emit('drain');
	    });
	
	    return wrapper;
	};
	
	/**
	 * Reads values from a Stream of Streams or Arrays, emitting them on a single
	 * output Stream. This can be thought of as a [flatten](#flatten), just one
	 * level deep, often used for resolving asynchronous actions such as a HTTP
	 * request or reading a file.
	 *
	 * @id sequence
	 * @section Higher-order Streams
	 * @name Stream.sequence()
	 * @api public
	 *
	 * var nums = _([
	 *     _([1, 2, 3]),
	 *     _([4, 5, 6])
	 * ]);
	 *
	 * nums.sequence()  // => 1, 2, 3, 4, 5, 6
	 *
	 * // using sequence to read from files in series
	 * var readFile = _.wrapCallback(fs.readFile);
	 * filenames.map(readFile).sequence()
	 */
	
	Stream.prototype.sequence = function () {
	    var original = this;
	    var curr = this;
	    return _(function (push, next) {
	        curr.pull(function (err, x) {
	            if (err) {
	                push(err);
	                return next();
	            }
	            else if (_.isArray(x)) {
	                if (onOriginalStream()) {
	                    // just send all values from array directly
	                    x.forEach(function (y) {
	                        push(null, y);
	                    });
	                }
	                else {
	                    push(null, x);
	                }
	                return next();
	            }
	            else if (_.isStream(x)) {
	                if (onOriginalStream()) {
	                    // switch to reading new stream
	                    curr = x;
	                    return next();
	                }
	                else {
	                    // sequence only goes 1 level deep
	                    push(null, x);
	                    return next();
	                }
	            }
	            else if (x === nil) {
	                if (onOriginalStream()) {
	                    push(null, nil);
	                }
	                else {
	                    // resume reading from original
	                    curr = original;
	                    return next();
	                }
	            }
	            else {
	                if (onOriginalStream()) {
	                    // we shouldn't be getting non-stream (or array)
	                    // values from the top-level stream
	                    push(new Error(
	                        'Expected Stream, got ' + (typeof x)
	                    ));
	                    return next();
	                }
	                else {
	                    push(null, x);
	                    return next();
	                }
	            }
	        });
	    });
	
	    function onOriginalStream() {
	        return curr === original;
	    }
	};
	exposeMethod('sequence');
	
	/**
	 * An alias for the [sequence](#sequence) method.
	 *
	 * @id series
	 * @section Higher-order Streams
	 * @name Stream.series()
	 * @api public
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 * filenames.map(readFile).series()
	 */
	
	Stream.prototype.series = Stream.prototype.sequence;
	_.series = _.sequence;
	
	/**
	 * Recursively reads values from a Stream which may contain nested Streams
	 * or Arrays. As values or errors are encountered, they are emitted on a
	 * single output Stream.
	 *
	 * @id flatten
	 * @section Higher-order Streams
	 * @name Stream.flatten()
	 * @api public
	 *
	 * _([1, [2, 3], [[4]]]).flatten();  // => 1, 2, 3, 4
	 *
	 * var nums = _(
	 *     _([1, 2, 3]),
	 *     _([4, _([5, 6]) ])
	 * );
	 *
	 * nums.flatten();  // => 1, 2, 3, 4, 5, 6
	 */
	
	Stream.prototype.flatten = function () {
	    var curr = this;
	    var stack = [];
	    return _(function (push, next) {
	        curr.pull(function (err, x) {
	            if (err) {
	                push(err);
	                return next();
	            }
	            if (_.isArray(x)) {
	                x = _(x);
	            }
	            if (_.isStream(x)) {
	                stack.push(curr);
	                curr = x;
	                next();
	            }
	            else if (x === nil) {
	                if (stack.length) {
	                    curr = stack.pop();
	                    next();
	                }
	                else {
	                    push(null, nil);
	                }
	            }
	            else {
	                push(null, x);
	                next();
	            }
	        });
	    });
	};
	exposeMethod('flatten');
	
	/**
	 * Takes a Stream of Streams and reads from them in parallel, buffering
	 * the results until they can be returned to the consumer in their original
	 * order.
	 *
	 * @id parallel
	 * @section Higher-order Streams
	 * @name Stream.parallel(n)
	 * @param {Number} n - the maximum number of concurrent reads/buffers
	 * @api public
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 * var filenames = _(['foo.txt', 'bar.txt', 'baz.txt']);
	 *
	 * // read from up to 10 files at once
	 * filenames.map(readFile).parallel(10);
	 */
	
	Stream.prototype.parallel = function (n) {
	    var source = this;
	    var running = [];
	    var ended = false;
	    var reading_source = false;
	
	    if (typeof n !== 'number') {
	        throw new Error('Must specify a number to parallel().');
	    }
	
	    if (n <= 0) {
	        throw new Error('The parallelism factor must be positive');
	    }
	
	    return _(function (push, next) {
	        if (running.length < n && !ended && !reading_source) {
	            // get another stream if not already waiting for one
	            reading_source = true;
	            source.pull(function (err, x) {
	                reading_source = false;
	                if (err) {
	                    push(err);
	                }
	                else if (x === nil) {
	                    ended = true;
	                }
	                else if (!_.isStream(x)) {
	                    push(new Error('Expected Stream, got ' + (typeof x)));
	                }
	                else {
	                    // got a new source, add it to the running array
	                    var run = {stream: x, buffer: []};
	                    running.push(run);
	                    x.consume(function (_err, y, _push, _next) {
	                        if (running[0] === run) {
	                            // current output stream
	                            if (y === nil) {
	                                // remove self from running and check
	                                // to see if we need to read from source again
	                                running.shift();
	                                flushBuffer();
	                                next();
	
	                            }
	                            else {
	                                // push directly onto parallel output stream
	                                push(_err, y);
	                            }
	                        }
	                        else {
	                            // we're reading ahead, buffer the output
	                            run.buffer.push([_err, y]);
	                        }
	                        if (y !== nil) {
	                            // keep reading until we hit nil
	                            _next();
	                        }
	                    }).resume();
	                }
	                // check if we need to get any more streams
	                return next();
	            });
	        }
	        else if (!running.length && ended) {
	            // nothing more to do
	            push(null, nil);
	        }
	
	        function flushBuffer() {
	            while (running.length && running[0].buffer.length) {
	                var buf = running[0].buffer;
	                for (var i = 0; i < buf.length; i++) {
	                    if (buf[i][1] === nil) {
	                        // this stream has ended
	                        running.shift();
	                        break;
	                    }
	                    else {
	                        // send the buffered output
	                        push.apply(null, buf[i]);
	                    }
	                }
	                buf.length = 0;
	            }
	        }
	        // else wait for more data to arrive from running streams
	    });
	};
	exposeMethod('parallel');
	
	/**
	 * Switches source to an alternate Stream if the current Stream is empty.
	 *
	 * @id otherwise
	 * @section Higher-order Streams
	 * @name Stream.otherwise(ys)
	 * @param {Stream | Function} ys - alternate stream (or stream-returning function) to use if this stream is empty
	 * @api public
	 *
	 * _([1,2,3]).otherwise(['foo'])  // => 1, 2, 3
	 * _([]).otherwise(['foo'])       // => 'foo'
	 *
	 * _.otherwise(_(['foo']), _([1,2,3]))    // => 1, 2, 3
	 * _.otherwise(_(['foo']), _([]))         // => 'foo'
	 */
	
	Stream.prototype.otherwise = function (ys) {
	    var xs = this;
	    return xs.consume(function (err, x, push, next) {
	        if (err) {
	            // got an error, just keep going
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            // hit the end without redirecting to xs, use alternative
	            if (_.isFunction(ys)) {
	                next(ys());
	            }
	            else {
	                next(ys);
	            }
	        }
	        else {
	            // got a value, push it, then redirect to xs
	            push(null, x);
	            next(xs);
	        }
	    });
	};
	exposeMethod('otherwise');
	
	/**
	 * Adds a value to the end of a Stream.
	 *
	 * @id append
	 * @section Transforms
	 * @name Stream.append(y)
	 * @param y - the value to append to the Stream
	 * @api public
	 *
	 * _([1, 2, 3]).append(4)  // => 1, 2, 3, 4
	 */
	
	Stream.prototype.append = function (y) {
	    return this.consume(function (err, x, push, next) {
	        if (x === nil) {
	            push(null, y);
	            push(null, _.nil);
	        }
	        else {
	            push(err, x);
	            next();
	        }
	    });
	};
	exposeMethod('append');
	
	/**
	 * Boils down a Stream to a single value. The memo is the initial state
	 * of the reduction, and each successive step of it should be returned by
	 * the iterator function. The iterator is passed two arguments:
	 * the memo and the next value.
	 *
	 * If the iterator throws an error, the reduction stops and the resulting
	 * stream will emit that error instead of a value.
	 *
	 * *Note:* The order of the `memo` and `iterator` arguments will be flipped in
	 * the next major version release.
	 *
	 * @id reduce
	 * @section Transforms
	 * @name Stream.reduce(memo, iterator)
	 * @param memo - the initial state of the reduction
	 * @param {Function} iterator - the function which reduces the values
	 * @api public
	 *
	 * var add = function (a, b) {
	 *     return a + b;
	 * };
	 *
	 * _([1, 2, 3, 4]).reduce(0, add)  // => 10
	 */
	
	Stream.prototype.reduce = function (z, f) {
	    // This can't be implemented with scan(), because we don't know if the
	    // errors that we see from the scan were thrown by the iterator or just
	    // passed through from the source stream.
	    return this.consume(function (err, x, push, next) {
	        if (x === nil) {
	            push(null, z);
	            push(null, _.nil);
	        }
	        else if (err) {
	            push(err);
	            next();
	        }
	        else {
	            try {
	                z = f(z, x);
	            }
	            catch (e) {
	                push(e);
	                push(null, _.nil);
	                return;
	            }
	
	            next();
	        }
	    });
	};
	exposeMethod('reduce');
	
	/**
	 * Same as [reduce](#reduce), but uses the first element as the initial
	 * state instead of passing in a `memo` value.
	 *
	 * @id reduce1
	 * @section Transforms
	 * @name Stream.reduce1(iterator)
	 * @param {Function} iterator - the function which reduces the values
	 * @api public
	 *
	 * _([1, 2, 3, 4]).reduce1(add)  // => 10
	 */
	
	Stream.prototype.reduce1 = function (f) {
	    var self = this;
	    return _(function (push, next) {
	        self.pull(function (err, x) {
	            if (err) {
	                push(err);
	                next();
	            }
	            else if (x === nil) {
	                push(null, nil);
	            }
	            else {
	                next(self.reduce(x, f));
	            }
	        });
	    });
	};
	exposeMethod('reduce1');
	
	/**
	 * Groups all values into an Array and passes down the stream as a single
	 * data event. This is a bit like doing [toArray](#toArray), but instead
	 * of accepting a callback and consuming the stream, it passes the value on.
	 *
	 * @id collect
	 * @section Transforms
	 * @name Stream.collect()
	 * @api public
	 *
	 * _(['foo', 'bar']).collect().toArray(function (xs) {
	 *     // xs will be [['foo', 'bar']]
	 * });
	 */
	
	Stream.prototype.collect = function () {
	    var xs = [];
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(null, xs);
	            push(null, nil);
	        }
	        else {
	            xs.push(x);
	            next();
	        }
	    });
	};
	exposeMethod('collect');
	
	/**
	 * Like [reduce](#reduce), but emits each intermediate value of the
	 * reduction as it is calculated.
	 *
	 * If the iterator throws an error, the scan will stop and the stream will
	 * emit that error. Any intermediate values that were produced before the
	 * error will still be emitted.
	 *
	 * *Note:* The order of the `memo` and `iterator` arguments will be flipped in
	 * the next major version release.
	 *
	 * @id scan
	 * @section Transforms
	 * @name Stream.scan(memo, iterator)
	 * @param memo - the initial state of the reduction
	 * @param {Function} iterator - the function which reduces the values
	 * @api public
	 *
	 * _([1, 2, 3, 4]).scan(0, add)  // => 0, 1, 3, 6, 10
	 */
	
	Stream.prototype.scan = function (z, f) {
	    var self = this;
	    return _([z]).concat(
	        self.consume(function (err, x, push, next) {
	            if (x === nil) {
	                push(null, _.nil);
	            }
	            else if (err) {
	                push(err);
	                next();
	            }
	            else {
	                try {
	                    z = f(z, x);
	                }
	                catch (e) {
	                    push(e);
	                    push(null, _.nil);
	                    return;
	                }
	
	                push(null, z);
	                next();
	            }
	        })
	    );
	};
	exposeMethod('scan');
	
	/**
	 * Same as [scan](#scan), but uses the first element as the initial
	 * state instead of passing in a `memo` value.
	 *
	 * @id scan1
	 * @section Transforms
	 * @name Stream.scan1(iterator)
	 * @param {Function} iterator - the function which reduces the values
	 * @api public
	 *
	 * _([1, 2, 3, 4]).scan1(add)  // => 1, 3, 6, 10
	 */
	
	Stream.prototype.scan1 = function (f) {
	    var self = this;
	    return _(function (push, next) {
	        self.pull(function (err, x) {
	            if (err) {
	                push(err);
	                next();
	            }
	            else if (x === nil) {
	                push(null, nil);
	            }
	            else {
	                next(self.scan(x, f));
	            }
	        });
	    });
	};
	exposeMethod('scan1');
	
	function HighlandTransform(push) {
	    this.push = push;
	}
	
	HighlandTransform.prototype['@@transducer/init'] = function () {
	    return this.push;
	};
	
	HighlandTransform.prototype['@@transducer/result'] = function (push) {
	    // Don't push nil here. Otherwise, we can't catch errors from `result`
	    // and propagate them. The `transduce` implementation will do it.
	    return push;
	};
	
	HighlandTransform.prototype['@@transducer/step'] = function (push, input) {
	    push(null, input);
	    return push;
	};
	
	/**
	 * Applies the transformation defined by the the given *transducer* to the
	 * stream. A transducer is any function that follows the
	 * [Transducer Protocol](https://github.com/cognitect-labs/transducers-js#transformer-protocol).
	 * See
	 * [transduce-js](https://github.com/cognitect-labs/transducers-js#transducers-js)
	 * for more details on what transducers actually are.
	 *
	 * The `result` object that is passed in through the
	 * [Transformer Protocol](https://github.com/cognitect-labs/transducers-js#transformer-protocol)
	 * will be the `push` function provided by the [consume](#consume) transform.
	 *
	 * Like [scan](#scan), if the transducer throws an exception, the transform
	 * will stop and emit that error. Any intermediate values that were produced
	 * before the error will still be emitted.
	 *
	 * @id transduce
	 * @section Transforms
	 * @name Stream.transduce(xf)
	 * @param {Function} xf - The transducer.
	 * @api public
	 *
	 * var xf = require('transducer-js').map(_.add(1));
	 * _([1, 2, 3, 4]).transduce(xf);
	 * // => [2, 3, 4, 5]
	 */
	
	Stream.prototype.transduce = function transduce(xf) {
	    var transform = null,
	        memo = null;
	
	    return this.consume(function (err, x, push, next) {
	        if (transform == null) {
	            transform = xf(new HighlandTransform(push));
	            memo = transform['@@transducer/init']();
	        }
	
	        if (err) {
	            // Pass through errors, like we always do.
	            push(err);
	            next();
	        }
	        else if (x === _.nil) {
	            // Push may be different from memo depending on the transducer that
	            // we get.
	            runResult(push, memo);
	        }
	        else {
	            var res = runStep(push, memo, x);
	
	            if (!res) {
	                return;
	            }
	
	            memo = res;
	            if (memo['@@transducer/reduced']) {
	                runResult(memo['@@transducer/value']);
	            }
	            else {
	                next();
	            }
	        }
	    });
	
	    function runResult(push, _memo) {
	        try {
	            transform['@@transducer/result'](_memo);
	        }
	        catch (e) {
	            push(e);
	        }
	        push(null, _.nil);
	    }
	
	    function runStep(push, _memo, x) {
	        try {
	            return transform['@@transducer/step'](_memo, x);
	        }
	        catch (e) {
	            push(e);
	            push(null, _.nil);
	            return null;
	        }
	    }
	};
	exposeMethod('transduce');
	
	/**
	 * Concatenates a Stream to the end of this Stream.
	 *
	 * Be aware that in the top-level export, the args may be in the reverse
	 * order to what you'd expect `_([a], [b]) => b, a`, as this follows the
	 * convention of other top-level exported functions which do `x` to `y`.
	 *
	 * @id concat
	 * @section Higher-order Streams
	 * @name Stream.concat(ys)
	 * @param {Stream | Array} ys - the values to concatenate onto this Stream
	 * @api public
	 *
	 * _([1, 2]).concat([3, 4])  // => 1, 2, 3, 4
	 * _.concat([3, 4], [1, 2])  // => 1, 2, 3, 4
	 */
	
	Stream.prototype.concat = function (ys) {
	    ys = _(ys);
	    return this.consume(function (err, x, push, next) {
	        if (x === nil) {
	            next(ys);
	        }
	        else {
	            push(err, x);
	            next();
	        }
	    });
	};
	exposeMethod('concat');
	
	/**
	 * Takes a Stream of Streams and merges their values and errors into a
	 * single new Stream. The merged stream ends when all source streams have
	 * ended.
	 *
	 * Note that no guarantee is made with respect to the order in which
	 * values for each stream end up in the merged stream. Values in the
	 * merged stream will, however, respect the order they were emitted from
	 * their respective streams.
	 *
	 * @id merge
	 * @section Higher-order Streams
	 * @name Stream.merge()
	 * @api public
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 *
	 * var txt = _(['foo.txt', 'bar.txt']).map(readFile)
	 * var md = _(['baz.md']).map(readFile)
	 *
	 * _([txt, md]).merge();
	 * // => contents of foo.txt, bar.txt and baz.txt in the order they were read
	 */
	
	Stream.prototype.merge = function () {
	    var self = this;
	    var srcs = [];
	
	    var srcsNeedPull = [],
	        first = true,
	        async = false;
	
	    return _(function (push, next) {
	        if (first) {
	            first = false;
	            getSourcesSync(push, next);
	        }
	
	        if (srcs.length === 0) {
	            push(null, nil);
	        }
	        else if (srcsNeedPull.length) {
	            pullFromAllSources(push, next);
	            next();
	        }
	        else {
	            async = true;
	        }
	    });
	
	    // Make a handler for the main merge loop.
	    function srcPullHandler(push, next, src) {
	        return function (err, x) {
	            if (err) {
	                push(err);
	                srcsNeedPull.push(src);
	            }
	            else if (x === nil) {
	                srcs = srcs.filter(function (s) {
	                    return s !== src;
	                });
	            }
	            else {
	                if (src === self) {
	                    srcs.push(x);
	                    srcsNeedPull.push(x);
	                    srcsNeedPull.unshift(self);
	                }
	                else {
	                    push(null, x);
	                    srcsNeedPull.push(src);
	                }
	            }
	
	            if (async) {
	                async = false;
	                next();
	            }
	        };
	    }
	
	
	    function pullFromAllSources(push, next) {
	        var _srcs = srcsNeedPull;
	        srcsNeedPull = [];
	        _srcs.forEach(function (src) {
	            src.pull(srcPullHandler(push, next, src));
	        });
	    }
	
	    // Pulls as many sources as possible from self synchronously.
	    function getSourcesSync(push, next) {
	        // Shadows the outer async variable.
	        var asynchronous;
	        var done = false;
	
	        var pull_cb = function(err, x) {
	            asynchronous = false;
	            if (done) {
	                // This means the pull was async. Handle like
	                // regular async.
	                srcPullHandler(push, next, self)(err, x);
	            }
	            else {
	                if (err) {
	                    push(err);
	                }
	                else if (x === nil) {
	                    done = true;
	                }
	                else {
	                    srcs.push(x);
	                    srcsNeedPull.push(x);
	                }
	            }
	        };
	
	        while (!done) {
	            asynchronous = true;
	            self.pull(pull_cb);
	
	            // Async behavior, record self as a src and return.
	            if (asynchronous) {
	                done = true;
	                srcs.unshift(self);
	            }
	        }
	    }
	
	};
	exposeMethod('merge');
	
	/**
	 * Takes a Stream of Streams and merges their values and errors into a
	 * single new Stream, limitting the number of unpaused streams that can
	 * running at any one time.
	 *
	 * Note that no guarantee is made with respect to the order in which
	 * values for each stream end up in the merged stream. Values in the
	 * merged stream will, however, respect the order they were emitted from
	 * their respective streams.
	 *
	 * @id mergeWithLimit
	 * @section Higher-order Streams
	 * @name Stream.mergeWithLimit(n)
	 * @param {Number} n - the maximum number of streams to run in parallel
	 * @api public
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 *
	 * var txt = _(['foo.txt', 'bar.txt']).flatMap(readFile)
	 * var md = _(['baz.md']).flatMap(readFile)
	 * var js = _(['bosh.js']).flatMap(readFile)
	 *
	 * _([txt, md, js]).mergeWithLimit(2);
	 * // => contents of foo.txt, bar.txt, baz.txt and bosh.js in the order
	 * // they were read, but bosh.js is not read until either foo.txt and bar.txt
	 * // has completely been read or baz.txt has been read
	 */
	
	
	Stream.prototype.mergeWithLimit = function (n){
	    var self = this;
	    var processCount = 0;
	    var waiting = false;
	    if (typeof n !== 'number' || n < 1) {
	        throw new Error('mergeWithLimit expects a positive number, but got: ' + n);
	    }
	    if (n === Infinity) {
	        return this.merge();
	    }
	    return _(function(push, next){
	        self.pull(function(err, x){
	            var done = x === nil;
	            if (err){
	                push(err);
	                next();
	            }
	            else if (x === nil) {
	                push(null, nil);
	            }
	            else {
	                processCount++;
	                push(err, x);
	                // console.log('start', x.id);
	                x.once('end', function(){
	                    processCount--;
	                    // console.log('end', x.id);
	                    if (waiting) {
	                        // console.log('get more');
	                        waiting = false;
	                        next();
	                    }
	                });
	                if (!done && processCount < n) {
	                    next();
	                }
	                else {
	                    // console.log('wait till something ends');
	                    waiting = true;
	                }
	            }
	
	        });
	    }).merge();
	};
	exposeMethod('mergeWithLimit');
	
	/**
	 * Calls a named method on each object from the Stream - returning
	 * a new stream with the result of those calls.
	 *
	 * @id invoke
	 * @section Transforms
	 * @name Stream.invoke(method, args)
	 * @param {String} method - the method name to call
	 * @param {Array} args - the arguments to call the method with
	 * @api public
	 *
	 * _(['foo', 'bar']).invoke('toUpperCase', [])  // => FOO, BAR
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 * filenames.flatMap(readFile).invoke('toString', ['utf8']);
	 */
	
	Stream.prototype.invoke = function (method, args) {
	    return this.map(function (x) {
	        return x[method].apply(x, args);
	    });
	};
	exposeMethod('invoke');
	
	/**
	 * Takes a Stream of callback-accepting node-style functions,
	 * [wraps](#wrapCallback) each one into a stream-returning function,
	 * calls them with the arguments provided, and returns the results
	 * as a Stream.
	 *
	 * This can be used as a control flow shortcut and draws parallels
	 * with some control flow functions from [async](https://github.com/caolan/async).
	 * A few rough correspondences include:
	 *
	 * - `.nfcall([]).series()` to `async.series()`
	 * - `.nfcall([]).parallel(n)` to `async.parallelLimit(n)`
	 * - `.nfcall(args)` to `async.applyEach(..., args)`
	 * - `.nfcall(args).series()` to `async.applyEachSeries(..., args)`
	 *
	 * @id nfcall
	 * @section Transforms
	 * @name Stream.nfcall(args)
	 * @param {Array} args - the arguments to call each function with
	 * @api public
	 *
	 * _([
	 *   function (callback) {
	 *     setTimeout(function () {
	 *       callback(null, 'one');
	 *     }, 200);
	 *   },
	 *   function (callback) {
	 *     setTimeout(function () {
	 *       callback(null, 'two');
	 *     }, 100);
	 *   }
	 * ]).nfcall([]).parallel(2).toArray(function (xs) {
	 *   // xs is ['one', 'two'] even though second function had a shorter timeout
	 * });
	 *
	 * _([enableSearch, updateSchema]).nfcall(['bucket']).toArray(callback);
	 * // does roughly the same as
	 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
	 *
	 * _([
	 *   fs.appendFile,
	 *   fs.appendFile
	 * ]).nfcall(['example.txt', 'hello']).series().toArray(function() {
	 *   // example.txt now contains 'hellohello'
	 * });
	 *
	 */
	
	Stream.prototype.nfcall = function (args) {
	    return this.map(function (x) {
	        return _.wrapCallback(x).apply(x, args);
	    });
	};
	exposeMethod('nfcall');
	
	/**
	 * Ensures that only one data event is push downstream (or into the buffer)
	 * every `ms` milliseconds, any other values are dropped.
	 *
	 * @id throttle
	 * @section Transforms
	 * @name Stream.throttle(ms)
	 * @param {Number} ms - the minimum milliseconds between each value
	 * @api public
	 *
	 * _('mousemove', document).throttle(1000);
	 */
	
	Stream.prototype.throttle = function (ms) {
	    var last = 0 - ms;
	    return this.consume(function (err, x, push, next) {
	        var now = new Date().getTime();
	        if (err) {
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            push(null, nil);
	        }
	        else if (now - ms >= last) {
	            last = now;
	            push(null, x);
	            next();
	        }
	        else {
	            next();
	        }
	    });
	};
	exposeMethod('throttle');
	
	/**
	 * Holds off pushing data events downstream until there has been no more
	 * data for `ms` milliseconds. Sends the last value that occurred before
	 * the delay, discarding all other values.
	 *
	 * @id debounce
	 * @section Transforms
	 * @name Stream.debounce(ms)
	 * @param {Number} ms - the milliseconds to wait before sending data
	 * @api public
	 *
	 * // sends last keyup event after user has stopped typing for 1 second
	 * $('keyup', textbox).debounce(1000);
	 */
	
	Stream.prototype.debounce = function (ms) {
	    var t = null;
	    var nothing = {};
	    var last = nothing;
	
	    return this.consume(function (err, x, push, next) {
	        if (err) {
	            // let errors through regardless
	            push(err);
	            next();
	        }
	        else if (x === nil) {
	            if (t) {
	                clearTimeout(t);
	            }
	            if (last !== nothing) {
	                push(null, last);
	            }
	            push(null, nil);
	        }
	        else {
	            last = x;
	            if (t) {
	                clearTimeout(t);
	            }
	            t = setTimeout(push.bind(this, null, x), ms);
	            next();
	        }
	    });
	};
	exposeMethod('debounce');
	
	/**
	 * Creates a new Stream, which when read from, only returns the last
	 * seen value from the source. The source stream does not experience
	 * back-pressure. Useful if you're using a Stream to model a changing
	 * property which you need to query periodically.
	 *
	 * @id latest
	 * @section Transforms
	 * @name Stream.latest()
	 * @api public
	 *
	 * // slowThing will always get the last known mouse position
	 * // when it asks for more data from the mousePosition stream
	 * mousePosition.latest().map(slowThing)
	 */
	
	Stream.prototype.latest = function () {
	    var nothing = {},
	        latest = nothing,
	        errors = [],
	        ended = false,
	        onValue = null;
	
	    this.consume(function (err, x, push, next) {
	        if (onValue != null) {
	            var cb = onValue;
	            onValue = null;
	            cb(err, x);
	        }
	
	        if (err) {
	            errors.push(err);
	            next();
	        }
	        else if (x === nil) {
	            ended = true;
	        }
	        else {
	            latest = x;
	            next();
	        }
	    }).resume();
	
	    return _(function (push, next) {
	        var oldErrors = errors;
	        errors = [];
	
	        if (!oldErrors.length && latest === nothing && !ended) {
	            // We haven't gotten any data yet. We can't call next
	            // because that might cause the stream to call the generator
	            // again, resulting in an infinite loop. Thus, we stick a
	            // a callback to be called whenever we get a value.
	            onValue = function (err, x) {
	                push(err, x);
	                if (x !== nil) {
	                    next();
	                }
	            };
	        }
	        else {
	            oldErrors.forEach(push);
	            if (latest !== nothing) {
	                push(null, latest);
	            }
	            if (ended) {
	                push(null, nil);
	            }
	            else {
	                next();
	            }
	        }
	    });
	};
	exposeMethod('latest');
	
	/**
	 * Returns values from an Object as a Stream. Reads properties
	 * lazily, so if you don't read from all keys on an object, not
	 * all properties will be read from (may have an effect where getters
	 * are used).
	 *
	 * @id values
	 * @section Objects
	 * @name _.values(obj)
	 * @param {Object} obj - the object to return values from
	 * @api public
	 *
	 * _.values({foo: 1, bar: 2, baz: 3})  // => 1, 2, 3
	 */
	
	_.values = function (obj) {
	    return _.keys(obj).map(function (k) {
	        return obj[k];
	    });
	};
	
	/**
	 * Returns keys from an Object as a Stream.
	 *
	 * @id keys
	 * @section Objects
	 * @name _.keys(obj)
	 * @param {Object} obj - the object to return keys from
	 * @api public
	 *
	 * _.keys({foo: 1, bar: 2, baz: 3})  // => 'foo', 'bar', 'baz'
	 */
	
	function keys (obj) {
	    var keysArray = [];
	    for (var k in obj) {
	        if (hasOwn.call(obj, k)) {
	            keysArray.push(k);
	        }
	    }
	    return keysArray;
	}
	
	_.keys = function (obj) {
	    return _(keys(obj));
	};
	
	/**
	 * Returns key/value pairs for an Object as a Stream. Reads properties
	 * lazily, so if you don't read from all keys on an object, not
	 * all properties will be read from (may have an effect where getters
	 * are used).
	 *
	 * @id pairs
	 * @section Objects
	 * @name _.pairs(obj)
	 * @param {Object} obj - the object to return key/value pairs from
	 * @api public
	 *
	 * _.pairs({foo: 1, bar: 2})  // => ['foo', 1], ['bar', 2]
	 */
	
	_.pairs = function (obj) {
	    return _.keys(obj).map(function (k) {
	        return [k, obj[k]];
	    });
	};
	
	/**
	 * Extends one object with the properties of another. **Note:** The
	 * arguments are in the reverse order of other libraries such as
	 * underscore. This is so it follows the convention of other functions in
	 * this library and so you can more meaningfully partially apply it.
	 *
	 * @id extend
	 * @section Objects
	 * @name _.extend(a, b)
	 * @param {Object} a - the properties to extend b with
	 * @param {Object} b - the original object to extend
	 * @api public
	 *
	 * _.extend({name: 'bar'}, {name: 'foo', price: 20})
	 * // => {name: 'bar', price: 20}
	 *
	 * // example of partial application
	 * var publish = _.extend({published: true});
	 *
	 * publish({title: 'test post'})
	 * // => {title: 'test post', published: true}
	 */
	
	_.extend = _.curry(function (extensions, target) {
	    for (var k in extensions) {
	        if (hasOwn.call(extensions, k)) {
	            target[k] = extensions[k];
	        }
	    }
	    return target;
	});
	
	/**
	 * Returns a property from an object.
	 *
	 * @id get
	 * @section Objects
	 * @name _.get(prop, obj)
	 * @param {String} prop - the property to return
	 * @param {Object} obj - the object to read properties from
	 * @api public
	 *
	 * var obj = {foo: 'bar', baz: 123};
	 * _.get('foo', obj) // => 'bar'
	 *
	 * // making use of partial application
	 * var posts = [
	 *   {title: 'one'},
	 *   {title: 'two'},
	 *   {title: 'three'}
	 * ];
	 *
	 * _(posts).map(_.get('title'))  // => 'one', 'two', 'three'
	 */
	
	_.get = _.curry(function (prop, obj) {
	    return obj[prop];
	});
	
	/**
	 * Updates a property on an object, returning the updated object.
	 *
	 * @id set
	 * @section Objects
	 * @name _.set(prop, value, obj)
	 * @param {String} prop - the property to return
	 * @param value - the value to set the property to
	 * @param {Object} obj - the object to set properties on
	 * @api public
	 *
	 * var obj = {foo: 'bar', baz: 123};
	 * _.set('foo', 'wheeee', obj) // => {foo: 'wheeee', baz: 123}
	 *
	 * // making use of partial application
	 * var publish = _.set('published', true);
	 *
	 * publish({title: 'example'})  // => {title: 'example', published: true}
	 */
	
	_.set = _.curry(function (prop, val, obj) {
	    obj[prop] = val;
	    return obj;
	});
	
	/**
	 * Logs values to the console, a simple wrapper around `console.log` that
	 * it suitable for passing to other functions by reference without having to
	 * call `bind`.
	 *
	 * @id log
	 * @section Utils
	 * @name _.log(args..)
	 * @api public
	 *
	 * _.log('Hello, world!');
	 *
	 * _([1, 2, 3, 4]).each(_.log);
	 */
	
	_.log = function () {
	    console.log.apply(console, arguments);
	};
	
	/**
	 * Wraps a node-style async function which accepts a callback, transforming
	 * it to a function which accepts the same arguments minus the callback and
	 * returns a Highland Stream instead. The wrapped function keeps its context,
	 * so you can safely use it as a method without binding (see the second
	 * example below).
	 *
	 * `wrapCallback` also accepts an optional `mappingHint`, which specifies how
	 * callback arguments are pushed to the stream. This can be used to handle
	 * non-standard callback protocols that pass back more than one value.
	 *
	 * `mappingHint` can be a function, number, or array. See the documentation on
	 * [EventEmitter Stream Objects](#Stream Objects) for details on the mapping
	 * hint. If `mappingHint` is a function, it will be called with all but the
	 * first argument that is passed to the callback. The first is still assumed to
	 * be the error argument.
	 *
	 * @id wrapCallback
	 * @section Utils
	 * @name _.wrapCallback(f)
	 * @param {Function} f - the node-style function to wrap
	 * @param {Array | Function | Number} mappingHint - (optional) how to pass the
	 * arguments to the callback
	 * @api public
	 *
	 * var fs = require('fs');
	 *
	 * var readFile = _.wrapCallback(fs.readFile);
	 *
	 * readFile('example.txt').apply(function (data) {
	 *     // data is now the contents of example.txt
	 * });
	 *
	 * function Reader(file) {
	 *     this.file = file;
	 * }
	 *
	 * Reader.prototype.read = function(cb) {
	 *     fs.readFile(this.file, cb);
	 * };
	 *
	 * Reader.prototype.readStream = _.wrapCallback(Reader.prototype.read);
	 */
	
	/*eslint-disable no-multi-spaces */
	_.wrapCallback = function (f, /*optional*/mappingHint) {
	    /*eslint-enable no-multi-spaces */
	    var mapper = hintMapper(mappingHint);
	
	    return function () {
	        var self = this;
	        var args = slice.call(arguments);
	        return _(function (push) {
	            var cb = function (err) {
	                if (err) {
	                    push(err);
	                }
	                else {
	                    var cbArgs = slice.call(arguments, 1);
	                    var v = mapper.apply(this, cbArgs);
	                    push(null, v);
	                }
	                push(null, nil);
	            };
	            f.apply(self, args.concat([cb]));
	        });
	    };
	};
	
	/**
	 * Takes an object or a constructor function and returns that object or
	 * constructor with streamified versions of its function properties.
	 * Passed constructors will also have their prototype functions
	 * streamified.  This is useful for wrapping many node style async
	 * functions at once, and for preserving those functions' context.
	 *
	 * @id streamifyAll
	 * @section Utils
	 * @name _.streamifyAll(source)
	 * @param {Object | Function} source - the function or object with
	 * node-style function properties.
	 * @api public
	 *
	 * var fs = _.streamifyAll(require('fs'));
	 *
	 * fs.readFileStream('example.txt').apply(function (data) {
	 *     // data is now the contents of example.txt
	 * });
	 */
	
	function isClass (fn) {
	    if (!(typeof fn === 'function' && fn.prototype)) { return false; }
	    var getKeys = isES5 ? Object.getOwnPropertyNames : keys;
	    var allKeys = getKeys(fn.prototype);
	    return allKeys.length > 0 && !(allKeys.length === 1 &&
	            allKeys[0] === 'constructor');
	}
	
	function inheritedKeys (obj) {
	    var allProps = {};
	    var curr = obj;
	    var handleProp = function (prop) {
	        allProps[prop] = true;
	    };
	    while (Object.getPrototypeOf(curr)) {
	        var props = Object.getOwnPropertyNames(curr);
	        props.forEach(handleProp);
	        curr = Object.getPrototypeOf(curr);
	    }
	    return keys(allProps);
	}
	
	function streamifyAll (inp, suffix) {
	    // will not streamify inherited functions in ES3
	    var getKeys = isES5 ? inheritedKeys : keys;
	    var allKeys = getKeys(inp);
	
	    for (var i = 0, len = allKeys.length; i < len; i++) {
	        var key = allKeys[i];
	        var val;
	
	        // will skip context aware getters
	        try {
	            val = inp[key];
	        }
	        catch (e) {
	            // Ignore
	        }
	
	        if (val && typeof val === 'function' && !isClass(val) &&
	                !val.__HighlandStreamifiedFunction__) {
	
	            var streamified = _.wrapCallback(val);
	            streamified.__HighlandStreamifiedFunction__ = true;
	            inp[key + suffix] = streamified;
	        }
	    }
	    return inp;
	}
	
	_.streamifyAll = function (arg) {
	    if (typeof arg !== 'function' && typeof arg !== 'object') {
	        throw new TypeError('takes an object or a constructor function');
	    }
	    var suffix = 'Stream';
	
	    var ret = streamifyAll(arg, suffix);
	    if (isClass(arg)) {
	        ret.prototype = streamifyAll(arg.prototype, suffix);
	    }
	    return ret;
	};
	
	/**
	 * Add two values. Can be partially applied.
	 *
	 * @id add
	 * @section Operators
	 * @name _.add(a, b)
	 * @api public
	 *
	 * _.add(1, 2) === 3
	 * _.add(1)(5) === 6
	 */
	
	_.add = _.curry(function (a, b) {
	    return a + b;
	});
	
	/**
	 * Perform logical negation on a value. If `x` is truthy then returns false,
	 * otherwise returns true.
	 *
	 * @id not
	 * @section Operators
	 * @name _.not(x)
	 * @param x - the value to negate
	 * @api public
	 *
	 * _.not(true)   // => false
	 * _.not(false)  // => true
	 */
	
	_.not = function (x) {
	    return !x;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate, __webpack_require__(0), (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.e = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.e = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	module.e = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			Object.defineProperty(module, "exports", {
				enumerable: true,
				configurable: false,
				get: function() { return module.e; },
				set: function(v) { return module.e = v; }
			});
			Object.defineProperty(module, "loaded", {
				enumerable: true,
				configurable: false,
				get: function() { return module.l; }
			});
			Object.defineProperty(module, "id", {
				enumerable: true,
				configurable: false,
				get: function() { return module.i; }
			});
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// Polyfills
	__webpack_require__(15).polyfill();
	__webpack_require__(17);
	
	// Requires
	var _ = __webpack_require__(5);
	var cytoscape = __webpack_require__(14);
	var queue = __webpack_require__(18);
	var obo = __webpack_require__(10);
	
	// Config
	// TODO its own file, maybe bring in with webpack, etc.
	var config = {
	  dev: {
	    BASE_URL: ''
	  },
	  prod: {
	    BASE_URL: 'https://thejmazz.github.io/ontoscope-phylify'
	  }
	};
	if (false) config = config.dev;else config = config.prod;
	
	var startTime = Date.now();
	
	// TODO explain this section
	// TODO better var names. e.g. buffer size is not really buffer size.
	var TERMS_BUFFER_SIZE = 200;
	var termsBufferCounter = 0;
	var termsBuffer = [];
	var chunks = 0;
	// Queue
	var q = queue({ concurrency: 1 });
	// Temp counter until 'eventedness' in parser is resolved
	var index = 0;
	
	fetch(config.BASE_URL + '/ff-phase2-140729.obo').then(function (response) {
	  if (response.status >= 400) {
	    throw new Error('Bad response from server');
	  }
	
	  // TODO handle last 170 terms
	  _(obo.terms(response.text())).each(function (term) {
	    termsBuffer[index] = { data: { id: term.id } };
	    termsBufferCounter++;
	
	    if (termsBufferCounter === TERMS_BUFFER_SIZE) {
	      // Buffer filled, use it 
	
	      q.push(function (cb) {
	        setTimeout(function () {
	          chunks++;
	          var start = (chunks - 1) * TERMS_BUFFER_SIZE;
	          var end = chunks * TERMS_BUFFER_SIZE;
	          var chunkBuffer = termsBuffer.slice(start, end);
	
	          var sTime = Date.now();
	          cy.add(chunkBuffer);
	          var layout = window.cy.elements().makeLayout({ name: 'grid' });
	          layout.run();
	          var delta = Date.now() - sTime;
	          console.log('Added chunk of ' + chunkBuffer.length + ' vertices in ' + delta + ' ms');
	
	          if (chunks === 6000 / TERMS_BUFFER_SIZE) {
	            var totalTime = (Date.now() - startTime) / 1000;
	
	            console.log('Finished queue in ' + totalTime + ' s.');
	          }
	
	          cb();
	        }, 0);
	      });
	
	      // and restart counter
	      termsBufferCounter = 0;
	    }
	
	    // TODO on end
	    if (index === 6000) {
	      console.log('Starting queue..');
	      // TODO start queue as data streams
	      q.start();
	    }
	
	    index++;
	  });
	});
	
	// TODO css..
	document.documentElement.style.height = '100%';
	document.body.style.margin = '0';
	document.body.style.height = '100%';
	
	// Create and append container dom element
	var containerDiv = document.createElement('div');
	// containerDiv.id = 'cy'
	containerDiv.style.height = '100%';
	document.body.appendChild(containerDiv);
	
	var cy = cytoscape({
	  container: containerDiv,
	
	  elements: [{ // node a
	    data: { id: 'a' }
	  }, { // node b
	    data: { id: 'b' }
	  }, { // edge ab
	    data: { id: 'ab', source: 'a', target: 'b' }
	  }],
	
	  style: [// the stylesheet for the graph
	  {
	    selector: 'node',
	    style: {
	      'background-color': '#666',
	      'label': 'data(id)'
	    }
	  }, {
	    selector: 'edge',
	    style: {
	      'width': 3,
	      'line-color': '#ccc',
	      'target-arrow-color': '#ccc',
	      'target-arrow-shape': 'triangle'
	    }
	  }],
	
	  layout: {
	    name: 'grid',
	    rows: 1
	  }
	});
	// TODO not end up depending on this by accident...
	window.cy = cy;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	;(function (exports) {
	  'use strict'
	
	  var i
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  var lookup = []
	  for (i = 0; i < code.length; i++) {
	    lookup[i] = code[i]
	  }
	  var revLookup = []
	
	  for (i = 0; i < code.length; ++i) {
	    revLookup[code.charCodeAt(i)] = i
	  }
	  revLookup['-'.charCodeAt(0)] = 62
	  revLookup['_'.charCodeAt(0)] = 63
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
	  function decode (elt) {
	    var v = revLookup[elt.charCodeAt(0)]
	    return v !== undefined ? v : -1
	  }
	
	  function b64ToByteArray (b64) {
	    var i, j, l, tmp, placeHolders, arr
	
	    if (b64.length % 4 > 0) {
	      throw new Error('Invalid string. Length must be a multiple of 4')
	    }
	
	    // the number of equal signs (place holders)
	    // if there are two placeholders, than the two characters before it
	    // represent one byte
	    // if there is only one, then the three characters before it represent 2 bytes
	    // this is just a cheap hack to not do indexOf twice
	    var len = b64.length
	    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0
	
	    // base64 is 4/3 + up to two characters of the original data
	    arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
	    // if there are placeholders, only get up to the last complete 4 chars
	    l = placeHolders > 0 ? b64.length - 4 : b64.length
	
	    var L = 0
	
	    function push (v) {
	      arr[L++] = v
	    }
	
	    for (i = 0, j = 0; i < l; i += 4, j += 3) {
	      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
	      push((tmp & 0xFF0000) >> 16)
	      push((tmp & 0xFF00) >> 8)
	      push(tmp & 0xFF)
	    }
	
	    if (placeHolders === 2) {
	      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
	      push(tmp & 0xFF)
	    } else if (placeHolders === 1) {
	      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
	      push((tmp >> 8) & 0xFF)
	      push(tmp & 0xFF)
	    }
	
	    return arr
	  }
	
	  function encode (num) {
	    return lookup[num]
	  }
	
	  function tripletToBase64 (num) {
	    return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
	  }
	
	  function encodeChunk (uint8, start, end) {
	    var temp
	    var output = []
	    for (var i = start; i < end; i += 3) {
	      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	      output.push(tripletToBase64(temp))
	    }
	    return output.join('')
	  }
	
	  function uint8ToBase64 (uint8) {
	    var i
	    var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes
	    var output = ''
	    var parts = []
	    var temp, length
	    var maxChunkLength = 16383 // must be multiple of 3
	
	    // go through the array every three bytes, we'll deal with trailing stuff later
	
	    for (i = 0, length = uint8.length - extraBytes; i < length; i += maxChunkLength) {
	      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > length ? length : (i + maxChunkLength)))
	    }
	
	    // pad the end with zeros, but make sure to not forget the extra bytes
	    switch (extraBytes) {
	      case 1:
	        temp = uint8[uint8.length - 1]
	        output += encode(temp >> 2)
	        output += encode((temp << 4) & 0x3F)
	        output += '=='
	        break
	      case 2:
	        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
	        output += encode(temp >> 10)
	        output += encode((temp >> 4) & 0x3F)
	        output += encode((temp << 2) & 0x3F)
	        output += '='
	        break
	      default:
	        break
	    }
	
	    parts.push(output)
	
	    return parts.join('')
	  }
	
	  exports.toByteArray = b64ToByteArray
	  exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	module.e = __webpack_require__(12)


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @license
	 * lodash 4.5.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash -d -o ./foo/lodash.js`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '4.5.1';
	
	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256,
	      FLIP_FLAG = 512;
	
	  /** Used to compose bitmasks for comparison styles. */
	  var UNORDERED_COMPARE_FLAG = 1,
	      PARTIAL_COMPARE_FLAG = 2;
	
	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;
	
	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;
	
	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
	
	  /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);
	
	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0x/i;
	
	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;
	
	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	      rsComboSymbolsRange = '\\u20d0-\\u20f0',
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;
	
	  /** Used to compose unicode capture groups. */
	  var rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';
	
	  /** Used to compose unicode regexes. */
	  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');
	
	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
	
	  /** Used to match non-compound words composed of alphanumeric characters. */
	  var reBasicWord = /[a-zA-Z0-9]+/g;
	
	  /** Used to match complex or compound words. */
	  var reComplexWord = RegExp([
	    rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
	    rsUpper + '?' + rsLowerMisc + '+',
	    rsUpper + '+',
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');
	
	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_',
	    'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[mapTag] = cloneableTags[numberTag] =
	  cloneableTags[objectTag] = cloneableTags[regexpTag] =
	  cloneableTags[setTag] = cloneableTags[stringTag] =
	  cloneableTags[symbolTag] = cloneableTags[uint8Tag] =
	  cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =
	  cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };
	
	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;
	
	  /** Detect free variable `exports`. */
	  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	    ? exports
	    : undefined;
	
	  /** Detect free variable `module`. */
	  var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	    ? module
	    : undefined;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = (freeModule && freeModule.exports === freeExports)
	    ? freeExports
	    : undefined;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
	
	  /** Detect free variable `self`. */
	  var freeSelf = checkGlobal(objectTypes[typeof self] && self);
	
	  /** Detect free variable `window`. */
	  var freeWindow = checkGlobal(objectTypes[typeof window] && window);
	
	  /** Detect `this` as the global object. */
	  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
	
	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal ||
	    ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	      freeSelf || thisGlobal || Function('return this')();
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    map.set(pair[0], pair[1]);
	    return map;
	  }
	
	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    set.add(value);
	    return set;
	  }
	
	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {...*} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    var length = args.length;
	    switch (length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }
	
	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * Creates a new array concatenating `array` with `other`.
	   *
	   * @private
	   * @param {Array} array The first array to concatenate.
	   * @param {Array} other The second array to concatenate.
	   * @returns {Array} Returns the new concatenated array.
	   */
	  function arrayConcat(array, other) {
	    var index = -1,
	        length = array.length,
	        othIndex = -1,
	        othLength = other.length,
	        result = Array(length + othLength);
	
	    while (++index < length) {
	      result[index] = array[index];
	    }
	    while (++othIndex < othLength) {
	      result[index++] = other[othIndex];
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array.length;
	
	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    return !!array.length && baseIndexOf(array, value, 0) > -1;
	  }
	
	  /**
	   * A specialized version of `_.includesWith` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array.length,
	        result = Array(length);
	
	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }
	
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;
	
	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array.length;
	
	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * The base implementation of methods like `_.max` and `_.min` which accepts a
	   * `comparator` to determine the extremum value.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The iteratee invoked per iteration.
	   * @param {Function} comparator The comparator used to compare values.
	   * @returns {*} Returns the extremum value.
	   */
	  function baseExtremum(array, iteratee, comparator) {
	    var index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var value = array[index],
	          current = iteratee(value);
	
	      if (current != null && (computed === undefined
	            ? current === current
	            : comparator(current, computed)
	          )) {
	        var computed = current,
	            result = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of methods like `_.find` and `_.findKey`, without
	   * support for iteratee shorthands, which iterates over `collection` using
	   * `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @param {boolean} [retKey] Specify returning the key of the found element instead of the element itself.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFind(collection, predicate, eachFunc, retKey) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = retKey ? key : value;
	        return false;
	      }
	    });
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }
	
	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define
	   * the sort order of `array` and replaces criteria objects with their
	   * corresponding values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;
	
	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }
	
	  /**
	   * The base implementation of `_.sum` without support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);
	
	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the new array of key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }
	
	  /**
	   * The base implementation of `_.unary` without support for storing wrapper metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }
	
	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;
	
	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	
	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Checks if `value` is a global object.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	   */
	  function checkGlobal(value) {
	    return (value && value.Object === Object) ? value : null;
	  }
	
	  /**
	   * Compares values to sort them in ascending order.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function compareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;
	
	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;
	
	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }
	
	  /**
	   * Used by `_.orderBy` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	   * specify an order of "desc" for descending or "asc" for ascending sort order
	   * of corresponding values.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]|string[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;
	
	    while (++index < length) {
	      var result = compareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * (order == 'desc' ? -1 : 1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }
	
	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;
	
	    while (length--) {
	      if (array[length] === placeholder) {
	        result++;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * Checks if `value` is a host object in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	   */
	  function isHostObject(value) {
	    // Many host objects are `Object` objects that can coerce to strings
	    // despite having improperly defined `toString` methods.
	    var result = false;
	    if (value != null && typeof value.toString != 'function') {
	      try {
	        result = !!(value + '');
	      } catch (e) {}
	    }
	    return result;
	  }
	
	  /**
	   * Checks if `value` is a valid array-like index.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	   */
	  function isIndex(value, length) {
	    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	    length = length == null ? MAX_SAFE_INTEGER : length;
	    return value > -1 && value % 1 == 0 && value < length;
	  }
	
	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];
	
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	
	  /**
	   * Converts `map` to an array.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	
	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Converts `set` to an array.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	
	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    if (!(string && reHasComplexSymbol.test(string))) {
	      return string.length;
	    }
	    var result = reComplexSymbol.lastIndex = 0;
	    while (reComplexSymbol.test(string)) {
	      result++;
	    }
	    return result;
	  }
	
	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return string.match(reComplexSymbol);
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Use `context` to mock `Date#getTime` use in `_.now`.
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
	
	    /** Built-in constructor references. */
	    var Date = context.Date,
	        Error = context.Error,
	        Math = context.Math,
	        RegExp = context.RegExp,
	        TypeError = context.TypeError;
	
	    /** Used for built-in method references. */
	    var arrayProto = context.Array.prototype,
	        objectProto = context.Object.prototype;
	
	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = context.Function.prototype.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);
	
	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objectToString = objectProto.toString;
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Reflect = context.Reflect,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        clearTimeout = context.clearTimeout,
	        enumerate = Reflect ? Reflect.enumerate : undefined,
	        getPrototypeOf = Object.getPrototypeOf,
	        getOwnPropertySymbols = Object.getOwnPropertySymbols,
	        iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice;
	
	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = Object.keys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;
	
	    /* Built-in method references that are verified to be native. */
	    var Map = getNative(context, 'Map'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to detect maps, sets, and weakmaps. */
	    var mapCtorString = Map ? funcToString.call(Map) : '',
	        setCtorString = Set ? funcToString.call(Set) : '',
	        weakMapCtorString = WeakMap ? funcToString.call(WeakMap) : '';
	
	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = Symbol ? symbolProto.valueOf : undefined,
	        symbolToString = Symbol ? symbolProto.toString : undefined;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chaining. Methods that operate on and return arrays, collections, and
	     * functions can be chained together. Methods that retrieve a single value or
	     * may return a primitive value will automatically end the chain sequence and
	     * return the unwrapped value. Otherwise, the value must be unwrapped with
	     * `_#value`.
	     *
	     * Explicit chaining, which must be unwrapped with `_#value` in all cases,
	     * may be enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization to merge iteratee calls; this avoids the creation
	     * of intermediate arrays and can greatly reduce the number of iteratee executions.
	     * Sections of a chain sequence qualify for shortcut fusion if the section is
	     * applied to an array of at least two hundred elements and any iteratees
	     * accept only one argument. The heuristic for whether a section qualifies
	     * for shortcut fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`, `difference`,
	     * `differenceBy`, `differenceWith`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flattenDepth`,
	     * `flip`, `flow`, `flowRight`, `fromPairs`, `functions`, `functionsIn`,
	     * `groupBy`, `initial`, `intersection`, `intersectionBy`, `intersectionWith`,
	     * `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`, `keys`, `keysIn`,
	     * `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`, `memoize`,
	     * `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`, `nthArg`,
	     * `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`, `overEvery`,
	     * `overSome`, `partial`, `partialRight`, `partition`, `pick`, `pickBy`, `plant`,
	     * `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`, `pullAt`, `push`,
	     * `range`, `rangeRight`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
	     * `sampleSize`, `set`, `setWith`, `shuffle`, `slice`, `sort`, `sortBy`,
	     * `splice`, `spread`, `tail`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `toArray`, `toPairs`, `toPairsIn`,
	     * `toPath`, `toPlainObject`, `transform`, `unary`, `union`, `unionBy`,
	     * `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`, `unshift`, `unzip`,
	     * `unzipWith`, `values`, `valuesIn`, `without`, `wrap`, `xor`, `xorBy`,
	     * `xorWith`, `zip`, `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `endsWith`, `eq`,
	     * `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `floor`, `forEach`, `forEachRight`, `forIn`,
	     * `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`,
	     * `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`,
	     * `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
	     * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
	     * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
	     * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,
	     * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,
	     * `isSet`, `isString`, `isUndefined`, `isTypedArray`, `isWeakMap`, `isWeakSet`,
	     * `join`, `kebabCase`, `last`, `lastIndexOf`, `lowerCase`, `lowerFirst`,
	     * `lt`, `lte`, `max`, `maxBy`, `mean`, `min`, `minBy`, `noConflict`, `noop`,
	     * `now`, `pad`, `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `sample`,
	     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`,
	     * `sortedLastIndex`, `sortedLastIndexBy`, `startCase`, `startsWith`, `subtract`,
	     * `sum`, `sumBy`, `template`, `times`, `toLower`, `toInteger`, `toLength`,
	     * `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`, `trimEnd`,
	     * `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`, `upperFirst`,
	     * `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
	          (arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an hash object.
	     *
	     * @private
	     * @constructor
	     * @returns {Object} Returns the new hash object.
	     */
	    function Hash() {}
	
	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(hash, key) {
	      return hashHas(hash, key) && delete hash[key];
	    }
	
	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @param {Object} hash The hash to query.
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(hash, key) {
	      if (nativeCreate) {
	        var result = hash[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
	    }
	
	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @param {Object} hash The hash to query.
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(hash, key) {
	      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
	    }
	
	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     */
	    function hashSet(hash, key, value) {
	      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function MapCache(values) {
	      var index = -1,
	          length = values ? values.length : 0;
	
	      this.clear();
	      while (++index < length) {
	        var entry = values[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapClear() {
	      this.__data__ = {
	        'hash': new Hash,
	        'map': Map ? new Map : [],
	        'string': new Hash
	      };
	    }
	
	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapDelete(key) {
	      var data = this.__data__;
	      if (isKeyable(key)) {
	        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
	      }
	      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
	    }
	
	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapGet(key) {
	      var data = this.__data__;
	      if (isKeyable(key)) {
	        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
	      }
	      return Map ? data.map.get(key) : assocGet(data.map, key);
	    }
	
	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      var data = this.__data__;
	      if (isKeyable(key)) {
	        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
	      }
	      return Map ? data.map.has(key) : assocHas(data.map, key);
	    }
	
	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache object.
	     */
	    function mapSet(key, value) {
	      var data = this.__data__;
	      if (isKeyable(key)) {
	        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
	      } else if (Map) {
	        data.map.set(key, value);
	      } else {
	        assocSet(data.map, key, value);
	      }
	      return this;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates a set cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values ? values.length : 0;
	
	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.push(values[index]);
	      }
	    }
	
	    /**
	     * Checks if `value` is in `cache`.
	     *
	     * @private
	     * @param {Object} cache The set cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function cacheHas(cache, value) {
	      var map = cache.__data__;
	      if (isKeyable(value)) {
	        var data = map.__data__,
	            hash = typeof value == 'string' ? data.string : data.hash;
	
	        return hash[value] === HASH_UNDEFINED;
	      }
	      return map.has(value);
	    }
	
	    /**
	     * Adds `value` to the set cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var map = this.__data__;
	      if (isKeyable(value)) {
	        var data = map.__data__,
	            hash = typeof value == 'string' ? data.string : data.hash;
	
	        hash[value] = HASH_UNDEFINED;
	      }
	      else {
	        map.set(value, HASH_UNDEFINED);
	      }
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function Stack(values) {
	      var index = -1,
	          length = values ? values.length : 0;
	
	      this.clear();
	      while (++index < length) {
	        var entry = values[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = { 'array': [], 'map': null };
	    }
	
	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          array = data.array;
	
	      return array ? assocDelete(array, key) : data.map['delete'](key);
	    }
	
	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      var data = this.__data__,
	          array = data.array;
	
	      return array ? assocGet(array, key) : data.map.get(key);
	    }
	
	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      var data = this.__data__,
	          array = data.array;
	
	      return array ? assocHas(array, key) : data.map.has(key);
	    }
	
	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache object.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__,
	          array = data.array;
	
	      if (array) {
	        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
	          assocSet(array, key, value);
	        } else {
	          data.array = null;
	          data.map = new MapCache(array);
	        }
	      }
	      var map = data.map;
	      if (map) {
	        map.set(key, value);
	      }
	      return this;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Removes `key` and its value from the associative array.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function assocDelete(array, key) {
	      var index = assocIndexOf(array, key);
	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = array.length - 1;
	      if (index == lastIndex) {
	        array.pop();
	      } else {
	        splice.call(array, index, 1);
	      }
	      return true;
	    }
	
	    /**
	     * Gets the associative array value for `key`.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function assocGet(array, key) {
	      var index = assocIndexOf(array, key);
	      return index < 0 ? undefined : array[index][1];
	    }
	
	    /**
	     * Checks if an associative array value for `key` exists.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function assocHas(array, key) {
	      return assocIndexOf(array, key) > -1;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `key` is found in `array`
	     * of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to search.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Sets the associative array `key` to `value`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     */
	    function assocSet(array, key, value) {
	      var index = assocIndexOf(array, key);
	      if (index < 0) {
	        array.push([key, value]);
	      } else {
	        array[index][1] = value;
	      }
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function assignInDefaults(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }
	
	    /**
	     * This function is like `assignValue` except that it doesn't assign `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (typeof key == 'number' && value === undefined && !(key in object))) {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          isNil = object == null,
	          length = paths.length,
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = isNil ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }
	
	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the array-like object.
	     */
	    function baseCastArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }
	
	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the array-like object.
	     */
	    function baseCastFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }
	
	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function baseCastPath(value) {
	      return isArray(value) ? value : stringToPath(value);
	    }
	
	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }
	
	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stack) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;
	
	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          if (isHostObject(value)) {
	            return object ? value : {};
	          }
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);
	
	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        assignValue(result, key, baseClone(subValue, isDeep, customizer, key, value, stack));
	      });
	      return isArr ? result : copySymbols(value, result);
	    }
	
	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new function.
	     */
	    function baseConforms(source) {
	      var props = keys(source),
	          length = props.length;
	
	      return function(object) {
	        if (object == null) {
	          return !length;
	        }
	        var index = length;
	        while (index--) {
	          var key = props[index],
	              predicate = source[key],
	              value = object[key];
	
	          if ((value === undefined && !(key in Object(object))) || !predicate(value)) {
	            return false;
	          }
	        }
	        return true;
	      };
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    function baseCreate(proto) {
	      return isObject(proto) ? objectCreate(proto) : {};
	    }
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an array
	     * of `func` arguments.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments to provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of methods like `_.difference` without support for
	     * excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;
	
	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, isStrict, result) {
	      result || (result = []);
	
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && isArrayLikeObject(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forIn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return object == null ? object : baseFor(object, iteratee, keysIn);
	    }
	
	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }
	
	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = isKey(path, object) ? [path + ''] : baseCastPath(path);
	
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
	      // that are composed entirely of index properties, return `false` for
	      // `hasOwnProperty` checks of them.
	      return hasOwnProperty.call(object, key) ||
	        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
	    }
	
	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return key in Object(object);
	    }
	
	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }
	
	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          result = [];
	
	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        caches[othIndex] = !comparator && (iteratee || array.length >= 120)
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];
	
	      var index = -1,
	          length = array.length,
	          seen = caches[0];
	
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      if (!isKey(path, object)) {
	        path = baseCastPath(path);
	        object = parent(object, path);
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : apply(func, object, args);
	    }
	
	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {boolean} [bitmask] The bitmask of comparison flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - Unordered comparison
	     *     2 - Partial comparison
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, bitmask, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;
	
	      if (!objIsArr) {
	        objTag = getTag(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = getTag(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag && !isHostObject(object),
	          othIsObj = othTag == objectTag && !isHostObject(other),
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag, equalFunc, customizer, bitmask);
	      }
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      if (!isPartial) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, bitmask, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, bitmask, stack);
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack,
	              result = customizer ? customizer(objValue, srcValue, key, object, source, stack) : undefined;
	
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      var type = typeof value;
	      if (type == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }
	
	    /**
	     * The base implementation of `_.keys` which doesn't skip the constructor
	     * property of prototypes or treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      return nativeKeys(Object(object));
	    }
	
	    /**
	     * The base implementation of `_.keysIn` which doesn't skip the constructor
	     * property of prototypes or treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      object = object == null ? object : Object(object);
	
	      var result = [];
	      for (var key in object) {
	        result.push(key);
	      }
	      return result;
	    }
	
	    // Fallback for IE < 9 with es6-shim.
	    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
	      baseKeysIn = function(object) {
	        return iteratorToArray(enumerate(object));
	      };
	    }
	
	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];
	
	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value &&
	            (value !== undefined || (key in Object(object)));
	        };
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      var props = (isArray(source) || isTypedArray(source))
	        ? undefined
	        : keysIn(source);
	
	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;
	
	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      });
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);
	
	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      var isCommon = newValue === undefined;
	
	      if (isCommon) {
	        newValue = srcValue;
	        if (isArray(srcValue) || isTypedArray(srcValue)) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else {
	            isCommon = false;
	            newValue = baseClone(srcValue, true);
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            isCommon = false;
	            newValue = baseClone(srcValue, true);
	          }
	          else {
	            newValue = objValue;
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      stack.set(srcValue, newValue);
	
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	      }
	      assignMergeValue(object, key, newValue);
	    }
	
	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1,
	          toIteratee = getIteratee();
	
	      iteratees = arrayMap(iteratees.length ? iteratees : Array(1), function(iteratee) {
	        return toIteratee(iteratee);
	      });
	
	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property names.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, props) {
	      object = Object(object);
	      return arrayReduce(props, function(result, key) {
	        if (key in object) {
	          result[key] = object[key];
	        }
	        return result;
	      }, {});
	    }
	
	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key) {
	        if (predicate(value, key)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAll`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values) {
	      return basePullAllBy(array, values);
	    }
	
	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAllBy(array, values, iteratee) {
	      var index = -1,
	          length = values.length,
	          seen = array;
	
	      if (iteratee) {
	        seen = arrayMap(array, function(value) { return iteratee(value); });
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        while ((fromIndex = baseIndexOf(seen, computed, fromIndex)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;
	
	      while (length--) {
	        var index = indexes[length];
	        if (lastIndex == length || index != previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          }
	          else if (!isKey(index, array)) {
	            var path = baseCastPath(index),
	                object = parent(array, path);
	
	            if (object != null) {
	              delete object[last(path)];
	            }
	          }
	          else {
	            delete array[index];
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }
	
	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments to numbers.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the new array of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      path = isKey(path, object) ? [path + ''] : baseCastPath(path);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          var newValue = value;
	          if (index != lastIndex) {
	            var objValue = nested[key];
	            newValue = customizer ? customizer(objValue, key, nested) : undefined;
	            if (newValue === undefined) {
	              newValue = objValue == null
	                ? (isIndex(path[index + 1]) ? [] : {})
	                : objValue;
	            }
	          }
	          assignValue(nested, key, newValue);
	        }
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;
	
	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniq`.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array) {
	      return baseSortedUniqBy(array);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniqBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniqBy(array, iteratee) {
	      var index = 0,
	          length = array.length,
	          value = array[0],
	          computed = iteratee ? iteratee(value) : value,
	          seen = computed,
	          resIndex = 0,
	          result = [value];
	
	      while (++index < length) {
	        value = array[index],
	        computed = iteratee ? iteratee(value) : value;
	
	        if (!eq(computed, seen)) {
	          seen = computed;
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;
	
	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = isKey(path, object) ? [path + ''] : baseCastPath(path);
	      object = parent(object, path);
	      var key = last(path);
	      return (object != null && has(object, key)) ? delete object[key] : true;
	    }
	
	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}
	
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }
	
	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var index = -1,
	          length = arrays.length;
	
	      while (++index < length) {
	        var result = result
	          ? arrayPush(
	              baseDifference(result, arrays[index], iteratee, comparator),
	              baseDifference(arrays[index], result, iteratee, comparator)
	            )
	          : arrays[index];
	      }
	      return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
	    }
	
	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property names.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};
	
	      while (++index < length) {
	        assignFunc(result, props[index], index < valsLength ? values[index] : undefined);
	      }
	      return result;
	    }
	
	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var Ctor = buffer.constructor,
	          result = new Ctor(buffer.length);
	
	      buffer.copy(result);
	      return result;
	    }
	
	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var Ctor = arrayBuffer.constructor,
	          result = new Ctor(arrayBuffer.byteLength),
	          view = new Uint8Array(result);
	
	      view.set(new Uint8Array(arrayBuffer));
	      return result;
	    }
	
	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map) {
	      var Ctor = map.constructor;
	      return arrayReduce(mapToArray(map), addMapEntry, new Ctor);
	    }
	
	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var Ctor = regexp.constructor,
	          result = new Ctor(regexp.source, reFlags.exec(regexp));
	
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }
	
	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set) {
	      var Ctor = set.constructor;
	      return arrayReduce(setToArray(set), addSetEntry, new Ctor);
	    }
	
	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return Symbol ? Object(symbolValueOf.call(symbol)) : {};
	    }
	
	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var arrayBuffer = typedArray.buffer,
	          buffer = isDeep ? cloneArrayBuffer(arrayBuffer) : arrayBuffer,
	          Ctor = typedArray.constructor;
	
	      return new Ctor(buffer, typedArray.byteOffset, typedArray.length);
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;
	
	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object) {
	      return copyObjectWith(source, props, object);
	    }
	
	    /**
	     * This function is like `copyObject` except that it accepts a function to
	     * customize copied values.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObjectWith(source, props, object, customizer) {
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	
	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : source[key];
	
	        assignValue(object, key, newValue);
	      }
	      return object;
	    }
	
	    /**
	     * Copies own symbol properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }
	
	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};
	
	        return func(collection, setter, getIteratee(iteratee), accumulator);
	      };
	    }
	
	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return rest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;
	
	        customizer = typeof customizer == 'function'
	          ? (length--, customizer)
	          : undefined;
	
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for methods like `_.forIn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;
	
	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBaseWrapper(func, bitmask, thisArg) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);
	
	        var strSymbols = reHasComplexSymbol.test(string)
	          ? stringToArray(string)
	          : undefined;
	
	        var chr = strSymbols ? strSymbols[0] : string.charAt(0),
	            trailing = strSymbols ? strSymbols.slice(1).join('') : string.slice(1);
	
	        return chr[methodName]() + trailing;
	      };
	    }
	
	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string)), callback, '');
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurryWrapper(func, bitmask, arity) {
	      var Ctor = createCtorWrapper(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getPlaceholder(wrapper);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);
	
	        length -= holders.length;
	        if (length < arity) {
	          return createRecurryWrapper(
	            func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return rest(function(funcs) {
	        funcs = baseFlatten(funcs, 1);
	
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;
	
	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) &&
	                data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 &&
	              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
	          isFlip = bitmask & FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            index = length,
	            args = Array(length);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getPlaceholder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurryWrapper(
	            func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }
	
	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new invoker function.
	     */
	    function createOver(arrayFunc) {
	      return rest(function(iteratees) {
	        iteratees = arrayMap(baseFlatten(iteratees, 1), getIteratee());
	        return rest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }
	
	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(string, length, chars) {
	      length = toInteger(length);
	
	      var strLength = stringSize(string);
	      if (!length || strLength >= length) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars === undefined ? ' ' : (chars + '');
	
	      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));
	      return reHasComplexSymbol.test(chars)
	        ? stringToArray(result).slice(0, padLength).join('')
	        : result.slice(0, padLength);
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);
	
	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toNumber(start);
	        start = start === start ? start : 0;
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toNumber(end) || 0;
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
	        return baseRange(start, end, step, fromRight);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & CURRY_FLAG,
	          newArgPos = argPos ? copyArray(argPos) : undefined,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;
	
	      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
	
	      if (!(bitmask & CURRY_BOUND_FLAG)) {
	        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, newArgPos, ary, arity
	      ];
	
	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = toInteger(precision);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));
	
	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a set of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {
	      return new Set(values);
	    };
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask of wrapper flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;
	
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);
	
	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];
	
	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] == null
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	
	      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == BIND_FLAG) {
	        var result = createBaseWrapper(func, bitmask, thisArg);
	      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
	        result = createCurryWrapper(func, bitmask, arity);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
	        result = createPartialWrapper(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
	     * @param {Object} [stack] Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	      var index = -1,
	          isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(array, other);
	
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isUnordered) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, equalFunc, customizer, bitmask) {
	      switch (tag) {
	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;
	
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object) ? other != +other : object == +other;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	
	        case mapTag:
	          var convert = mapToArray;
	
	        case setTag:
	          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	          convert || (convert = setToArray);
	
	          // Recursively compare objects (susceptible to call stack limits).
	          return (isPartial || object.size == other.size) &&
	            equalFunc(convert(object), convert(other), customizer, bitmask | UNORDERED_COMPARE_FLAG);
	
	        case symbolTag:
	          return !!Symbol && (symbolValueOf.call(object) == symbolValueOf.call(other));
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	          objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : baseHas(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	
	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      return result;
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the appropriate "iteratee" function. If the `_.iteratee` method is
	     * customized this function returns the custom method, otherwise it returns
	     * `baseIteratee`. If arguments are provided the chosen function is invoked
	     * with them and its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }
	
	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');
	
	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = toPairs(object),
	          length = result.length;
	
	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }
	
	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getPlaceholder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }
	
	    /**
	     * Creates an array of the own symbol properties of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = getOwnPropertySymbols || function() {
	      return [];
	    };
	
	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function getTag(value) {
	      return objectToString.call(value);
	    }
	
	    // Fallback for IE 11 providing `toStringTag` values for maps, sets, and weakmaps.
	    if ((Map && getTag(new Map) != mapTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = objectToString.call(value),
	            Ctor = result == objectTag ? value.constructor : null,
	            ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';
	
	        if (ctorString) {
	          switch (ctorString) {
	            case mapCtorString: return mapTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasFunc(object, path);
	      if (!result && !isKey(path)) {
	        path = baseCastPath(path);
	        object = parent(object, path);
	        if (object != null) {
	          path = last(path);
	          result = hasFunc(object, path);
	        }
	      }
	      var length = object ? object.length : undefined;
	      return result || (
	        !!length && isLength(length) && isIndex(path, length) &&
	        (isArray(object) || isString(object) || isArguments(object))
	      );
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);
	
	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (isFunction(object.constructor) && !isPrototype(object))
	        ? baseCreate(getPrototypeOf(object))
	        : {};
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);
	
	        case mapTag:
	          return cloneMap(object);
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          return cloneRegExp(object);
	
	        case setTag:
	          return cloneSet(object);
	
	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }
	
	    /**
	     * Creates an array of index keys for `object` values of arrays,
	     * `arguments` objects, and strings, otherwise `null` is returned.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array|null} Returns index keys, else `null`.
	     */
	    function indexKeys(object) {
	      var length = object ? object.length : undefined;
	      if (isLength(length) &&
	          (isArray(object) || isString(object) || isArguments(object))) {
	        return baseTimes(length, String);
	      }
	      return null;
	    }
	
	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        return eq(object[index], value);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (typeof value == 'number') {
	        return true;
	      }
	      return !isArray(value) &&
	        (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	          (object != null && value in Object(object)));
	    }
	
	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return type == 'number' || type == 'boolean' ||
	        (type == 'string' && value != '__proto__') || value == null;
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];
	
	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (isFunction(Ctor) && Ctor.prototype) || objectProto;
	
	      return value === proto;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * modify function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * combined case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
	
	      var isCombo =
	        ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
	        ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : copyArray(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : copyArray(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : copyArray(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : copyArray(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = copyArray(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
	      }
	      return objValue;
	    }
	
	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length == 1 ? object : get(object, baseSlice(path, 0, -1));
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;
	
	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());
	
	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    function stringToPath(string) {
	      var result = [];
	      toString(string).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=0] The length of each chunk.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size) {
	      size = nativeMax(toInteger(size), 0);
	
	      var length = array ? array.length : 0;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var concat = rest(function(array, values) {
	      if (!isArray(array)) {
	        array = array == null ? [] : [Object(array)];
	      }
	      values = baseFlatten(values, 1);
	      return arrayConcat(array, values);
	    });
	
	    /**
	     * Creates an array of unique `array` values not included in the other
	     * given arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([3, 2, 1], [4, 2]);
	     * // => [3, 1]
	     */
	    var difference = rest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, true))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
	     * // => [3.1, 1.3]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = rest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, true), getIteratee(iteratee))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = rest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, true), undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate) {
	      return (array && array.length)
	        ? baseFindIndex(array, getIteratee(predicate, 3))
	        : -1;
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate) {
	      return (array && array.length)
	        ? baseFindIndex(array, getIteratee(predicate, 3), true)
	        : -1;
	    }
	
	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, 1) : [];
	    }
	
	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }
	
	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }
	
	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs ? pairs.length : 0,
	          result = {};
	
	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return array ? array[0] : undefined;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the offset
	     * from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      fromIndex = toInteger(fromIndex);
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }
	
	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     *
	     * _.intersection([2, 1], [4, 2], [1, 2]);
	     * // => [2]
	     */
	    var intersection = rest(function(arrays) {
	      var mapped = arrayMap(arrays, baseCastArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = rest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, baseCastArrayLikeObject);
	
	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee))
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = rest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, baseCastArrayLikeObject);
	
	      if (comparator === last(mapped)) {
	        comparator = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array ? nativeJoin.call(array, separator) : '';
	    }
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    var pull = rest(pullAll);
	
	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pullAll(array, [2, 3]);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAllBy(array, values, getIteratee(iteratee))
	        : array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified individually or in arrays.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = rest(function(array, indexes) {
	      indexes = arrayMap(baseFlatten(indexes, 1), String);
	
	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(compareAscending));
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array ? nativeReverse.call(array) : array;
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of [`Array#slice`](https://mdn.io/Array/slice)
	     * to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 5], 4);
	     * // => 0
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted into `array`.
	     * @example
	     *
	     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
	     *
	     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee));
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([1, 1, 2, 2], 2);
	     * // => 2
	     */
	    function sortedIndexOf(array, value) {
	      var length = array ? array.length : 0;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5], 4);
	     * // => 1
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }
	
	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted into `array`.
	     * @example
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
	    }
	
	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([1, 1, 2, 2], 2);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array ? array.length : 0;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniqBy(array, getIteratee(iteratee))
	        : [];
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      return drop(array, 1);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with three
	     * arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2, 1], [4, 2], [1, 2]);
	     * // => [2, 1, 4]
	     */
	    var union = rest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, true));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by which
	     * uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
	     * // => [2.1, 1.2, 4.3]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = rest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, true), getIteratee(iteratee));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = rest(function(arrays) {
	      var comparator = last(arrays);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, true), undefined, comparator);
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length)
	        ? baseUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseUniq(array, getIteratee(iteratee))
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The comparator is invoked with
	     * two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      return (array && array.length)
	        ? baseUniq(array, undefined, comparator)
	        : [];
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }
	
	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = rest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([2, 1], [4, 2]);
	     * // => [1, 4]
	     */
	    var xor = rest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by which
	     * uniqueness is computed. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
	     * // => [1.2, 4.3]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = rest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The comparator is invoked with
	     * two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = rest(function(arrays) {
	      var comparator = last(arrays);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = rest(unzip);
	
	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property names and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} [props=[]] The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }
	
	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} [props=[]] The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = rest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;
	
	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method chaining enabled.
	     * The result of such method chaining must be unwrapped with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }
	
	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths of elements to pick,
	     *  specified individually or in arrays.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     *
	     * _(['a', 'b', 'c']).at(0, 2).value();
	     * // => ['a', 'c']
	     */
	    var wrapperAt = rest(function(paths) {
	      paths = baseFlatten(paths, 1);
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };
	
	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });
	
	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * This method is the wrapper version of `_.flatMap`.
	     *
	     * @name flatMap
	     * @memberOf _
	     * @category Seq
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _([1, 2]).flatMap(duplicate).value();
	     * // => [1, 1, 2, 2]
	     */
	    function wrapperFlatMap(iteratee) {
	      return this.map(iteratee).flatten();
	    }
	
	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];
	
	      return { 'done': done, 'value': value };
	    }
	
	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }
	
	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }
	
	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    function find(collection, predicate) {
	      predicate = getIteratee(predicate, 3);
	      if (isArray(collection)) {
	        var index = baseFindIndex(collection, predicate);
	        return index > -1 ? collection[index] : undefined;
	      }
	      return baseFind(collection, predicate, baseEach);
	    }
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    function findLast(collection, predicate) {
	      predicate = getIteratee(predicate, 3);
	      if (isArray(collection)) {
	        var index = baseFindIndex(collection, predicate, true);
	        return index > -1 ? collection[index] : undefined;
	      }
	      return baseFind(collection, predicate, baseEachRight);
	    }
	
	    /**
	     * Creates an array of flattened values by running each element in `collection`
	     * through `iteratee` and concating its result to the other mapped values.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }
	
	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior use `_.forIn` or `_.forOwn`
	     * for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(value) {
	     *   console.log(value);
	     * });
	     * // => logs `1` then `2`
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' then 'b' (iteration order is not guaranteed)
	     */
	    function forEach(collection, iteratee) {
	      return (typeof iteratee == 'function' && isArray(collection))
	        ? arrayEach(collection, iteratee)
	        : baseEach(collection, baseCastFunction(iteratee));
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => logs `2` then `1`
	     */
	    function forEachRight(collection, iteratee) {
	      return (typeof iteratee == 'function' && isArray(collection))
	        ? arrayEachRight(collection, iteratee)
	        : baseEachRight(collection, baseCastFunction(iteratee));
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of elements responsible for generating the key.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string it's checked
	     * for a substring of `value`, otherwise [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it's
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = rest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `curry`, `curryRight`, `drop`, `dropRight`, `every`, `fill`,
	     * `invert`, `parseInt`, `random`, `range`, `rangeRight`, `slice`, `some`,
	     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimEnd`, `trimStart`,
	     * and `words`
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} [iteratees=[_.identity]] The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getIteratee(predicate, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }
	
	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var array = isArrayLike(collection) ? collection : values(collection),
	          length = array.length;
	
	      return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
	    }
	
	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=0] The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n) {
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;
	
	      n = baseClamp(toInteger(n), 0, length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];
	
	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sampleSize(collection, MAX_ARRAY_LENGTH);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        var result = collection.length;
	        return (result && isString(collection)) ? stringSize(collection) : result;
	      }
	      return keys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by, specified individually or in arrays.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, function(o) { return o.user; });
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.sortBy(users, 'user', function(o) {
	     *   return Math.floor(o.age / 10);
	     * });
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortBy = rest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees.length = 1;
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @type {Function}
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = Date.now;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that accepts up to `n` arguments, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = rest(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getPlaceholder(bind));
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = rest(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getPlaceholder(bindKey));
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide an options object to indicate whether `func` should be invoked on
	     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent calls
	     * to the debounced function return the result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it's invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          leading = false,
	          maxWait = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;
	      }
	
	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }
	
	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }
	
	      function flush() {
	        if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {
	          result = func.apply(thisArg, args);
	        }
	        cancel();
	        return result;
	      }
	
	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }
	
	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);
	
	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!lastCalled && !maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled);
	
	          var isCalled = (remaining <= 0 || remaining > maxWait) &&
	            (leading || maxTimeoutId);
	
	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => logs 'deferred' after one or more milliseconds
	     */
	    var defer = rest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = rest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrapper(func, FLIP_FLAG);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with arguments transformed by
	     * corresponding `transforms`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified individually or in arrays.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = rest(function(func, transforms) {
	      transforms = arrayMap(baseFlatten(transforms, 1), getIteratee());
	
	      var funcsLength = transforms.length;
	      return rest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);
	
	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });
	
	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = rest(function(func, partials) {
	      var holders = replaceHolders(partials, getPlaceholder(partial));
	      return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = rest(function(func, partials) {
	      var holders = replaceHolders(partials, getPlaceholder(partialRight));
	      return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified individually or in arrays.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = rest(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);
	
	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, array);
	          case 1: return func.call(this, args[0], array);
	          case 2: return func.call(this, args[0], args[1], array);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = array;
	        return apply(func, this, otherArgs);
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
	      return rest(function(args) {
	        var array = args[start],
	            otherArgs = args.slice(0, start);
	
	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide an options object to indicate whether
	     * `func` should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }
	
	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }
	
	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return partial(wrapper, value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }
	
	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value);
	    }
	
	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      return baseClone(value, false, customizer);
	    }
	
	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, true);
	    }
	
	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      return baseClone(value, true, customizer);
	    }
	
	    /**
	     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }
	
	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	    }
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @type {Function}
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;
	
	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    function isArrayBuffer(value) {
	      return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
	    }
	
	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null &&
	        !(typeof value == 'function' && isFunction(value)) && isLength(getLength(value));
	    }
	
	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && objectToString.call(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = !Buffer ? constant(false) : function(value) {
	      return value instanceof Buffer;
	    };
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objectToString.call(value) == dateTag;
	    }
	
	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is empty. A value is considered empty unless it's an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (isArrayLike(value) &&
	          (isArray(value) || isString(value) ||
	            isFunction(value.splice) || isArguments(value))) {
	        return !value.length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are **not** supported.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }
	
	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined` comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      return (objectToString.call(value) == errorTag) ||
	        (typeof value.message == 'string' && typeof value.name == 'string');
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MAX_VALUE);
	     * // => true
	     *
	     * _.isFinite(3.14);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 8 which returns 'object' for typed array constructors, and
	      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	      var tag = isObject(value) ? objectToString.call(value) : '';
	      return tag == funcTag || tag == genTag;
	    }
	
	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return !!value && typeof value == 'object';
	    }
	
	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    function isMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }
	
	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values. This method is
	     * equivalent to a `_.matches` function when `source` is partially applied.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }
	
	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined` comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(funcToString.call(value));
	      }
	      return isObjectLike(value) &&
	        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && objectToString.call(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) ||
	          objectToString.call(value) != objectTag || isHostObject(value)) {
	        return false;
	      }
	      var proto = getPrototypeOf(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = proto.constructor;
	      return (typeof Ctor == 'function' &&
	        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objectToString.call(value) == regexpTag;
	    }
	
	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    function isSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && objectToString.call(value) == symbolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	    }
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && objectToString.call(value) == weakSetTag;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (iteratorSymbol && value[iteratorSymbol]) {
	        return iteratorToArray(value[iteratorSymbol]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
	
	      return func(value);
	    }
	
	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3');
	     * // => 3
	     */
	    function toInteger(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      var remainder = value % 1;
	      return value === value ? (remainder ? value - remainder : value) : 0;
	    }
	
	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }
	
	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3);
	     * // => 3
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3');
	     * // => 3
	     */
	    function toNumber(value) {
	      if (isObject(value)) {
	        var other = isFunction(value.valueOf) ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }
	
	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
	    }
	
	    /**
	     * Converts `value` to a string if it's not one. An empty string is returned
	     * for `null` and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (value == null) {
	        return '';
	      }
	      if (isSymbol(value)) {
	        return Symbol ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable properties of source objects to the destination
	     * object. Source objects are applied from left to right. Subsequent sources
	     * overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.c = 3;
	     * }
	     *
	     * function Bar() {
	     *   this.e = 5;
	     * }
	     *
	     * Foo.prototype.d = 4;
	     * Bar.prototype.f = 6;
	     *
	     * _.assign({ 'a': 1 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3, 'e': 5 }
	     */
	    var assign = createAssigner(function(object, source) {
	      copyObject(source, keys(source), object);
	    });
	
	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * function Bar() {
	     *   this.d = 4;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     * Bar.prototype.e = 5;
	     *
	     * _.assignIn({ 'a': 1 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });
	
	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer` which
	     * is invoked to produce the assigned values. If `customizer` returns `undefined`
	     * assignment is handled by the method instead. The `customizer` is invoked
	     * with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObjectWith(source, keysIn(source), object, customizer);
	    });
	
	    /**
	     * This method is like `_.assign` except that it accepts `customizer` which
	     * is invoked to produce the assigned values. If `customizer` returns `undefined`
	     * assignment is handled by the method instead. The `customizer` is invoked
	     * with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObjectWith(source, keys(source), object, customizer);
	    });
	
	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths of elements to pick,
	     *  specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     *
	     * _.at(['a', 'b', 'c'], 0, 2);
	     * // => ['a', 'c']
	     */
	    var at = rest(function(object, paths) {
	      return baseAt(object, baseFlatten(paths, 1));
	    });
	
	    /**
	     * Creates an object that inherits from the `prototype` object. If a `properties`
	     * object is given its own enumerable properties are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties ? baseAssign(result, properties) : result;
	    }
	
	    /**
	     * Assigns own and inherited enumerable properties of source objects to the
	     * destination object for all destination properties that resolve to `undefined`.
	     * Source objects are applied from left to right. Once a property is set,
	     * additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = rest(function(args) {
	      args.push(undefined, assignInDefaults);
	      return apply(assignInWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = rest(function(args) {
	      args.push(undefined, mergeDefaults);
	      return apply(mergeWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
	    }
	
	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The iteratee is invoked with three arguments:
	     * (value, key, object). Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', then 'c' (iteration order is not guaranteed)
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, baseCastFunction(iteratee), keysIn);
	    }
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, baseCastFunction(iteratee), keysIn);
	    }
	
	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The iteratee is invoked with three arguments:
	     * (value, key, object). Iteratee functions may exit iteration early by
	     * explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' then 'b' (iteration order is not guaranteed)
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, baseCastFunction(iteratee));
	    }
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, baseCastFunction(iteratee));
	    }
	
	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }
	
	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return hasPath(object, path, baseHas);
	    }
	
	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b.c');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b', 'c']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return hasPath(object, path, baseHasIn);
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));
	
	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` through `iteratee`.
	     * The corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);
	
	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = rest(baseInvoke);
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      var isProto = isPrototype(object);
	      if (!(isProto || isArrayLike(object))) {
	        return baseKeys(object);
	      }
	      var indexes = indexKeys(object),
	          skipIndexes = !!indexes,
	          result = indexes || [],
	          length = result.length;
	
	      for (var key in object) {
	        if (baseHas(object, key) &&
	            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	            !(isProto && key == 'constructor')) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      var index = -1,
	          isProto = isPrototype(object),
	          props = baseKeysIn(object),
	          propsLength = props.length,
	          indexes = indexKeys(object),
	          skipIndexes = !!indexes,
	          result = indexes || [],
	          length = result.length;
	
	      while (++index < propsLength) {
	        var key = props[index];
	        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`. The iteratee is invoked with
	     * three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        result[iteratee(value, key, object)] = value;
	      });
	      return result;
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee is invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        result[key] = iteratee(value, key, object);
	      });
	      return result;
	    }
	
	    /**
	     * Recursively merges own and inherited enumerable properties of source objects
	     * into the destination object. Source properties that resolve to `undefined`
	     * are skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });
	
	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined` merging is handled by the
	     * method instead. The `customizer` is invoked with seven arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property names to omit, specified
	     *  individually or in arrays.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = rest(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      props = arrayMap(baseFlatten(props, 1), String);
	      return basePick(object, baseDifference(keysIn(object), props));
	    });
	
	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable properties of `object` that `predicate`
	     * doesn't return truthy for. The predicate is invoked with two arguments:
	     * (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      predicate = getIteratee(predicate);
	      return basePickBy(object, function(value, key) {
	        return !predicate(value, key);
	      });
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [props] The property names to pick, specified
	     *  individually or in arrays.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = rest(function(object, props) {
	      return object == null ? {} : basePick(object, baseFlatten(props, 1));
	    });
	
	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      return object == null ? {} : basePickBy(object, getIteratee(predicate));
	    }
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it's invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      if (!isKey(path, object)) {
	        path = baseCastPath(path);
	        var result = get(object, path);
	        object = parent(object, path);
	      } else {
	        result = object == null ? undefined : object[path];
	      }
	      if (result === undefined) {
	        result = defaultValue;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }
	
	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }
	
	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.setWith({ '0': { 'length': 2 } }, '[0][1][2]', 3, Object);
	     * // => { '0': { '1': { '2': 3 }, 'length': 2 } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }
	
	    /**
	     * Creates an array of own enumerable key-value pairs for `object` which
	     * can be consumed by `_.fromPairs`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    function toPairs(object) {
	      return baseToPairs(object, keys(object));
	    }
	
	    /**
	     * Creates an array of own and inherited enumerable key-value pairs for
	     * `object` which can be consumed by `_.fromPairs`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)
	     */
	    function toPairsIn(object) {
	      return baseToPairs(object, keysIn(object));
	    }
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The iteratee is invoked with four arguments:
	     * (accumulator, value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getIteratee(iteratee, 4);
	
	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = isFunction(Ctor) ? baseCreate(getPrototypeOf(object)) : {};
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }
	
	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object ? baseValues(object, keys(object)) : [];
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }
	
	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toNumber(start) || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toNumber(end) || 0;
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }
	
	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are floats,
	     * a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toNumber(lower) || 0;
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toNumber(upper) || 0;
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });
	
	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }
	
	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = typeof target == 'string' ? target : (target + '');
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);
	
	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in IE < 9, they can break out of
	     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }
	
	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');
	
	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = stringSize(string);
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);
	
	      return createPadding('', leftLength, chars) + string + createPadding('', rightLength, chars);
	    }
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      return string + createPadding(string, length, chars);
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      return createPadding(string, length, chars) + string;
	    }
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#x15.1.2.2)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = toString(string).replace(reTrim, '');
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      string = toString(string);
	      n = toInteger(n);
	
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);
	
	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }
	
	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the new array of string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      return toString(string).split(separator, limit);
	    }
	
	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + capitalize(word);
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = baseClamp(toInteger(position), 0, string.length);
	      return string.lastIndexOf(target, position) == position;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, assignInDefaults);
	
	      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Converts `string`, as a whole, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar');
	     * // => '--foo-bar'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }
	
	    /**
	     * Converts `string`, as a whole, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar');
	     * // => '--FOO-BAR'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard || chars === undefined) {
	        return string.replace(reTrim, '');
	      }
	      chars = (chars + '');
	      if (!chars) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars);
	
	      return strSymbols
	        .slice(charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1)
	        .join('');
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard || chars === undefined) {
	        return string.replace(reTrimEnd, '');
	      }
	      chars = (chars + '');
	      if (!chars) {
	        return string;
	      }
	      var strSymbols = stringToArray(string);
	      return strSymbols
	        .slice(0, charsEndIndex(strSymbols, stringToArray(chars)) + 1)
	        .join('');
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard || chars === undefined) {
	        return string.replace(reTrimStart, '');
	      }
	      chars = (chars + '');
	      if (!chars) {
	        return string;
	      }
	      var strSymbols = stringToArray(string);
	      return strSymbols
	        .slice(charsStartIndex(strSymbols, stringToArray(chars)))
	        .join('');
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options=({})] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? toString(options.omission) : omission;
	      }
	      string = toString(string);
	
	      var strLength = string.length;
	      if (reHasComplexSymbol.test(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? strSymbols.slice(0, end).join('')
	        : string.slice(0, end);
	
	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;
	
	      if (pattern === undefined) {
	        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
	      }
	      return string.match(pattern) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = rest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind,
	     *  specified individually or in arrays.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, 'onClick');
	     * jQuery(element).on('click', view.onClick);
	     * // => logs 'clicked docs' when clicked
	     */
	    var bindAll = rest(function(object, methodNames) {
	      arrayEach(baseFlatten(methodNames, 1), function(key) {
	        object[key] = bind(object[key], object);
	      });
	      return object;
	    });
	
	    /**
	     * Creates a function that iterates over `pairs` invoking the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.constant(true),                _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs ? pairs.length : 0,
	          toIteratee = getIteratee();
	
	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });
	
	      return rest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }
	
	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, true));
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * This method returns the first argument given to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name the created callback returns the
	     * property value for a given element. If `func` is an object the created
	     * callback returns `true` for elements that contain the equivalent object
	     * properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(callback, func) {
	     *   var p = /^(\S+)\s*([<>])\s*(\S+)$/.exec(func);
	     *   return !p ? callback(func) : function(object) {
	     *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);
	     *   };
	     * });
	     *
	     * _.filter(users, 'age > 36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`. The created function is equivalent to
	     * `_.isMatch` with a `source` partially applied.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** This method supports comparing the same values as `_.isEqual`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invokeMap(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = rest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = rest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);
	
	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = (isObject(options) && 'chain' in options) ? options.chain : true,
	          isFunc = isFunction(object);
	
	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);
	
	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });
	
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }
	
	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that returns its nth argument.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     *
	     * func('a', 'b', 'c');
	     * // => 'b'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return function() {
	        return arguments[n];
	      };
	    }
	
	    /**
	     * Creates a function that invokes `iteratees` with the arguments provided
	     * to the created function and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} iteratees The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over(Math.max, Math.min);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);
	
	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments provided to the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} predicates The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery(Boolean, isFinite);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);
	
	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments provided to the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} predicates The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome(Boolean, isFinite);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);
	
	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();
	
	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);
	
	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(true));
	     * // => [true, true, true, true]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);
	
	      iteratee = baseCastFunction(iteratee);
	      n -= MAX_ARRAY_LENGTH;
	
	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     *
	     * var path = ['a', 'b', 'c'],
	     *     newPath = _.toPath(path);
	     *
	     * console.log(newPath);
	     * // => ['a', 'b', 'c']
	     *
	     * console.log(path === newPath);
	     * // => false
	     */
	    function toPath(value) {
	      return isArray(value) ? arrayMap(value, String) : stringToPath(value);
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is given the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      var result;
	      if (augend === undefined && addend === undefined) {
	        return 0;
	      }
	      if (augend !== undefined) {
	        result = augend;
	      }
	      if (addend !== undefined) {
	        result = result === undefined ? addend : (result + addend);
	      }
	      return result;
	    }
	
	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey
	     * `undefined` is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, gt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee), gt)
	        : undefined;
	    }
	
	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return sum(array) / (array ? array.length : 0);
	    }
	
	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey
	     * `undefined` is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, lt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee), lt)
	        : undefined;
	    }
	
	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    function subtract(minuend, subtrahend) {
	      var result;
	      if (minuend === undefined && subtrahend === undefined) {
	        return 0;
	      }
	      if (minuend !== undefined) {
	        result = minuend;
	      }
	      if (subtrahend !== undefined) {
	        result = result === undefined ? subtrahend : (result - subtrahend);
	      }
	      return result;
	    }
	
	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }
	
	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee))
	        : 0;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    // Avoid inheriting from `Object.prototype` when possible.
	    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
	
	    // Add functions to the `MapCache`.
	    MapCache.prototype.clear = mapClear;
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;
	
	    // Add functions to the `SetCache`.
	    SetCache.prototype.push = cachePush;
	
	    // Add functions to the `Stack` cache.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;
	
	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;
	
	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;
	
	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;
	
	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
	
	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };
	
	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };
	
	    LazyWrapper.prototype.invokeMap = rest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });
	
	    LazyWrapper.prototype.reject = function(predicate) {
	      predicate = getIteratee(predicate, 3);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;
	
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });
	
	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });
	
	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];
	
	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.flatMap = wrapperFlatMap;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    if (iteratorSymbol) {
	      lodash.prototype[iteratorSymbol] = wrapperToIterator;
	    }
	    return lodash;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Expose lodash on the free variable `window` or `self` when available. This
	  // prevents errors in cases where lodash is loaded by a script tag in the presence
	  // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.
	  (freeWindow || freeSelf || {})._ = _;
	
	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.e = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module), (function() { return this; }())))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	const _ = __webpack_require__(11)
	const highland = __webpack_require__(5)
	const EventEmitter2 = __webpack_require__(2).EventEmitter2 || __webpack_require__(2)
	
	/**
	 * Parse OBO files from an input stream.
	 * Emits a [Term] object stream or ndjson stream.
	 * @module bionode-obo
	 */
	
	console.log(__webpack_require__(2).EventEmitter2)
	
	// Setting up event emitter
	const emitter = new EventEmitter2({
	  wildcard: false,
	  delimiter: '.',
	  newListener: true,
	  maxListeners: 10
	})
	
	// emitter.addListener('header', header => console.log('HEADER: ' + JSON.stringify(stanzaParser(header), null, 2)))
	
	// highland('stanza', emitter)
	//   .map(stanza => stanzaParser(stanza))
	//   .map(stanza => JSON.stringify(stanza, null, 2))
	//   .each(stanza => console.log('STANZA: ' + stanza))
	
	// Flags and buffers
	let header = true
	let headerComplete = false
	let headerStr = ''
	
	let term = false
	let termStr = ''
	
	// Watch for `line` events from the emitter
	// TODO stop using events, as this stream "never ends"
	highland('line', emitter)
	  .each(line => {
	    // If we found a new stanza, swap term flag
	    if (line.match(/^\[[a-z]+\]/i)) {
	      // Found a stanza
	      header = false
	      term = !term
	    }
	
	    // Emit header once
	    // TODO headerStr buffer can be termStr
	    if (header) {
	      headerStr += line + '\n'
	    } else if (!headerComplete) {
	      emitter.emit('header', headerStr)
	      headerComplete = true
	    }
	
	
	    if (term) {
	      // If we are currently buffering a stanza, continue to do so
	      termStr += line + '\n'
	    } else if (!term && !header) {
	      // Term flag will have been swapped if we encountered a [Term], [Typedef], etc
	      // Then emit the currently completed stanza, and swap the flag back so we
	      // continue to buffer a new stanza
	      term = !term
	      emitter.emit('stanza', termStr)
	      termStr = line + '\n'
	    }
	  })
	
	// Emits a `line` event with each line passed in
	// TODO mitigate using events, event stream doesn't know when it ends
	const getLines = (stream) => {
	  return stream
	    .splitBy('\n')
	    .each(line => emitter.emit('line', line))
	}
	
	// map stanza text to an object representation
	const parseStanzas = (stream) => {
	  return stream.map(stanza => stanzaParser(stanza))
	}
	
	// map objects to stringified lines
	const ndjsonIfy = (stream) => {
	  return stream.map(obj => JSON.stringify(obj) + '\n')
	}
	
	// filter out [Term]s
	const termsFilter = (stream) => {
	  return stream.filter(obj => obj[''] === '[Term]')
	}
	
	/**
	 * Parse OBO 1.2 file
	 * @return {stream} the readable stream of an OBO file from fs or www
	 */
	exports.parse = highland.pipeline(highland.through(getLines))
	
	/**
	 * Produce [Term]s object stream
	 * @param  {stream} stream stream from fs or www
	 * @return {stream}        object stream
	 */
	exports.terms = (stream) => {
	  highland(stream).through(getLines)
	
	  return highland('stanza', emitter)
	    .through(parseStanzas)
	    .through(termsFilter)
	}
	
	/**
	 * Produce [Term]s ndjson stream
	 * @param  {stream} stream strem from fs or www
	 * @return {stream}        ndjson stream
	 */
	exports.termsNdjson = (stream) => {
	  highland(stream).through(getLines)
	
	  return highland('stanza', emitter)
	    .through(parseStanzas)
	    .through(termsFilter)
	    .through(ndjsonIfy)
	}
	
	/**
	 * Parse one [Term] at once.
	 *
	 * NOTE Although this parser is a stream, this function requires one term to be
	 * stored in memory at once. How else to create an Object stream? One
	 * could append a string until it is JSON.parse()''able, but that still requires
	 * storing the object in memory at once, on the other side. Better to provide
	 * an Object stream as well as an ndjson stream.
	 */
	const stanzaParser = (stanza) => {
	  return stanza
	    .split('\n')
	    // Filter out empty lines
	    .filter(l => l.length !== 0)
	    // Reduce array into object of key:val
	    .reduce( (prev, curr) => {
	      const sep = curr.indexOf(':')
	      const key = curr.substring(0, sep)
	      const val = _.trim(curr.substring(sep+1))
	
	      prev[key] = val
	
	      return prev
	    }, {} )
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var toString = {}.toString;
	
	module.e = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, __dirname) {var require;var require;/*!
	Copyright (c) 2016 The Cytoscape Consortium
	
	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the Software), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	of the Software, and to permit persons to whom the Software is furnished to do
	so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	*/
	
	(function(f){if(true){module.e=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cytoscape = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('./util');
	var is = _dereq_('./is');
	var Promise = _dereq_('./promise');
	
	var Animation = function( target, opts, opts2 ){
	  if( !(this instanceof Animation) ){
	    return new Animation( target, opts, opts2 );
	  }
	
	  var _p = this._private = util.extend( {
	    duration: 1000
	  }, opts, opts2 );
	
	  _p.target = target;
	  _p.style = _p.style || _p.css;
	  _p.started = false;
	  _p.playing = false;
	  _p.hooked = false;
	  _p.applying = false;
	  _p.progress = 0;
	  _p.completes = [];
	  _p.frames = [];
	
	  if( _p.complete && is.fn(_p.complete) ){
	    _p.completes.push( _p.complete );
	  }
	
	  // for future timeline/animations impl
	  this.length = 1;
	  this[0] = this;
	};
	
	var anifn = Animation.prototype;
	
	util.extend( anifn, {
	
	  instanceString: function(){ return 'animation'; },
	
	  hook: function(){
	    var _p = this._private;
	
	    if( !_p.hooked ){
	      // add to target's animation queue
	      var q;
	      var tAni = _p.target._private.animation;
	      if( _p.queue ){
	        q = tAni.queue;
	      } else {
	        q = tAni.current;
	      }
	      q.push( this );
	
	      // add to the animation loop pool
	      if( is.elementOrCollection( _p.target ) ){
	        _p.target.cy().addToAnimationPool( _p.target );
	      }
	
	      _p.hooked = true;
	    }
	
	    return this;
	  },
	
	  play: function(){
	    var _p = this._private;
	
	    // autorewind
	    if( _p.progress === 1 ){
	      _p.progress = 0;
	    }
	
	    _p.playing = true;
	    _p.started = false; // needs to be started by animation loop
	    _p.stopped = false;
	
	    this.hook();
	
	    // the animation loop will start the animation...
	
	    return this;
	  },
	
	  playing: function(){
	    return this._private.playing;
	  },
	
	  apply: function(){
	    var _p = this._private;
	
	    _p.applying = true;
	    _p.started = false; // needs to be started by animation loop
	    _p.stopped = false;
	
	    this.hook();
	
	    // the animation loop will apply the animation at this progress
	
	    return this;
	  },
	
	  applying: function(){
	    return this._private.applying;
	  },
	
	  pause: function(){
	    var _p = this._private;
	
	    _p.playing = false;
	    _p.started = false;
	
	    return this;
	  },
	
	  stop: function(){
	    var _p = this._private;
	
	    _p.playing = false;
	    _p.started = false;
	    _p.stopped = true; // to be removed from animation queues
	
	    return this;
	  },
	
	  rewind: function(){
	    return this.progress(0);
	  },
	
	  fastforward: function(){
	    return this.progress(1);
	  },
	
	  time: function( t ){
	    var _p = this._private;
	
	    if( t === undefined ){
	      return _p.progress * _p.duration;
	    } else {
	      return this.progress( t / _p.duration );
	    }
	  },
	
	  progress: function( p ){
	    var _p = this._private;
	    var wasPlaying = _p.playing;
	
	    if( p === undefined ){
	      return _p.progress;
	    } else {
	      if( wasPlaying ){
	        this.pause();
	      }
	
	      _p.progress = p;
	      _p.started = false;
	
	      if( wasPlaying ){
	        this.play();
	      }
	    }
	
	    return this;
	  },
	
	  completed: function(){
	    return this._private.progress === 1;
	  },
	
	  reverse: function(){
	    var _p = this._private;
	    var wasPlaying = _p.playing;
	
	    if( wasPlaying ){
	      this.pause();
	    }
	
	    _p.progress = 1 - _p.progress;
	    _p.started = false;
	
	    var swap = function( a, b ){
	      var _pa = _p[a];
	
	      _p[a] = _p[b];
	      _p[b] = _pa;
	    };
	
	    swap( 'zoom', 'startZoom' );
	    swap( 'pan', 'startPan' );
	    swap( 'position', 'startPosition' );
	
	    // swap styles
	    for( var i = 0; i < _p.style.length; i++ ){
	      var prop = _p.style[i];
	      var name = prop.name;
	      var startStyleProp = _p.startStyle[ name ];
	
	      _p.startStyle[ name ] = _p.startStyle[ util.dash2camel( name ) ] = prop;
	      _p.style[i] = startStyleProp;
	    }
	
	    if( wasPlaying ){
	      this.play();
	    }
	
	    return this;
	  },
	
	  promise: function( type ){
	    var _p = this._private;
	
	    var arr;
	
	    switch( type ){
	      case 'frame':
	        arr = _p.frames;
	        break;
	      default:
	      case 'complete':
	      case 'completed':
	        arr = _p.completes;
	    }
	
	    return new Promise(function( resolve, reject ){
	      arr.push(function(){
	        resolve();
	      });
	    });
	  }
	
	} );
	
	anifn.complete = anifn.completed;
	
	module.exports = Animation;
	
	},{"./is":77,"./promise":80,"./util":94}],2:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	
	var elesfn = ({
	
	  // Implemented from pseudocode from wikipedia
	  aStar: function(options) {
	    var eles = this;
	
	    options = options || {};
	
	    // Reconstructs the path from Start to End, acumulating the result in pathAcum
	    var reconstructPath = function(start, end, cameFromMap, pathAcum) {
	      // Base case
	      if (start == end) {
	        pathAcum.push( cy.getElementById(end) );
	        return pathAcum;
	      }
	
	      if (end in cameFromMap) {
	        // We know which node is before the last one
	        var previous = cameFromMap[end];
	        var previousEdge = cameFromEdge[end];
	
	        pathAcum.push( cy.getElementById(end) );
	        pathAcum.push( cy.getElementById(previousEdge) );
	
	
	        return reconstructPath(start,
	                     previous,
	                     cameFromMap,
	                     pathAcum);
	      }
	
	      // We should not reach here!
	      return undefined;
	    };
	
	    // Returns the index of the element in openSet which has minimum fScore
	    var findMin = function(openSet, fScore) {
	      if (openSet.length === 0) {
	        // Should never be the case
	        return undefined;
	      }
	      var minPos = 0;
	      var tempScore = fScore[openSet[0]];
	      for (var i = 1; i < openSet.length; i++) {
	        var s = fScore[openSet[i]];
	        if (s < tempScore) {
	          tempScore = s;
	          minPos = i;
	        }
	      }
	      return minPos;
	    };
	
	    var cy = this._private.cy;
	
	    // root - mandatory!
	    if (options != null && options.root != null) {
	      var source = is.string(options.root) ?
	        // use it as a selector, e.g. "#rootID
	        this.filter(options.root)[0] :
	        options.root[0];
	    } else {
	      return undefined;
	    }
	
	    // goal - mandatory!
	    if (options.goal != null) {
	      var target = is.string(options.goal) ?
	        // use it as a selector, e.g. "#goalID
	        this.filter(options.goal)[0] :
	        options.goal[0];
	    } else {
	      return undefined;
	    }
	
	    // Heuristic function - optional
	    if (options.heuristic != null && is.fn(options.heuristic)) {
	      var heuristic = options.heuristic;
	    } else {
	      var heuristic = function(){ return 0; }; // use constant if unspecified
	    }
	
	    // Weight function - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weightFn = options.weight;
	    } else {
	      // If not specified, assume each edge has equal weight (1)
	      var weightFn = function(e) {return 1;};
	    }
	
	    // directed - optional
	    if (options.directed != null) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    var closedSet = [];
	    var openSet = [source.id()];
	    var cameFrom = {};
	    var cameFromEdge = {};
	    var gScore = {};
	    var fScore = {};
	
	    gScore[source.id()] = 0;
	    fScore[source.id()] = heuristic(source);
	
	    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
	    var nodes = this.nodes();
	
	    // Counter
	    var steps = 0;
	
	    // Main loop
	    while (openSet.length > 0) {
	      var minPos = findMin(openSet, fScore);
	      var cMin = cy.getElementById( openSet[minPos] );
	      steps++;
	
	      // If we've found our goal, then we are done
	      if (cMin.id() == target.id()) {
	        var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
	        rPath.reverse();
	        return {
	          found : true,
	          distance : gScore[cMin.id()],
	          path : eles.spawn(rPath),
	          steps : steps
	        };
	      }
	
	      // Add cMin to processed nodes
	      closedSet.push(cMin.id());
	      // Remove cMin from boundary nodes
	      openSet.splice(minPos, 1);
	
	      // Update scores for neighbors of cMin
	      // Take into account if graph is directed or not
	      var vwEdges = cMin.connectedEdges();
	      if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
	      vwEdges = vwEdges.intersect(edges);
	
	      for (var i = 0; i < vwEdges.length; i++) {
	        var e = vwEdges[i];
	        var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);
	
	        // if node is in closedSet, ignore it
	        if (closedSet.indexOf(w.id()) != -1) {
	          continue;
	        }
	
	        // New tentative score for node w
	        var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
	
	        // Update gScore for node w if:
	        //   w not present in openSet
	        // OR
	        //   tentative gScore is less than previous value
	
	        // w not in openSet
	        if (openSet.indexOf(w.id()) == -1) {
	          gScore[w.id()] = tempScore;
	          fScore[w.id()] = tempScore + heuristic(w);
	          openSet.push(w.id()); // Add node to openSet
	          cameFrom[w.id()] = cMin.id();
	          cameFromEdge[w.id()] = e.id();
	          continue;
	        }
	        // w already in openSet, but with greater gScore
	        if (tempScore < gScore[w.id()]) {
	          gScore[w.id()] = tempScore;
	          fScore[w.id()] = tempScore + heuristic(w);
	          cameFrom[w.id()] = cMin.id();
	        }
	
	      } // End of neighbors update
	
	    } // End of main loop
	
	    // If we've reached here, then we've not reached our goal
	    return {
	      found : false,
	      distance : undefined,
	      path : undefined,
	      steps : steps
	    };
	  }
	
	}); // elesfn
	
	
	module.exports = elesfn;
	
	},{"../../is":77}],3:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	var util = _dereq_('../../util');
	
	var elesfn = ({
	
	  // Implemented from pseudocode from wikipedia
	  bellmanFord: function(options) {
	    var eles = this;
	
	    options = options || {};
	
	    // Weight function - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weightFn = options.weight;
	    } else {
	      // If not specified, assume each edge has equal weight (1)
	      var weightFn = function(e) {return 1;};
	    }
	
	    // directed - optional
	    if (options.directed != null) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    // root - mandatory!
	    if (options.root != null) {
	      if (is.string(options.root)) {
	        // use it as a selector, e.g. "#rootID
	        var source = this.filter(options.root)[0];
	      } else {
	        var source = options.root[0];
	      }
	    } else {
	      return undefined;
	    }
	
	    var cy = this._private.cy;
	    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
	    var nodes = this.nodes();
	    var numNodes = nodes.length;
	
	    // mapping: node id -> position in nodes array
	    var id2position = {};
	    for (var i = 0; i < numNodes; i++) {
	      id2position[nodes[i].id()] = i;
	    }
	
	    // Initializations
	    var cost = [];
	    var predecessor = [];
	    var predEdge = [];
	
	    for (var i = 0; i < numNodes; i++) {
	      if (nodes[i].id() === source.id()) {
	        cost[i] = 0;
	      } else {
	        cost[i] = Infinity;
	      }
	      predecessor[i] = undefined;
	    }
	
	    // Edges relaxation
	    var flag = false;
	    for (var i = 1; i < numNodes; i++) {
	      flag = false;
	      for (var e = 0; e < edges.length; e++) {
	        var sourceIndex = id2position[edges[e].source().id()];
	        var targetIndex = id2position[edges[e].target().id()];
	        var weight = weightFn.apply(edges[e], [edges[e]]);
	
	        var temp = cost[sourceIndex] + weight;
	        if (temp < cost[targetIndex]) {
	          cost[targetIndex] = temp;
	          predecessor[targetIndex] = sourceIndex;
	          predEdge[targetIndex] = edges[e];
	          flag = true;
	        }
	
	        // If undirected graph, we need to take into account the 'reverse' edge
	        if (!directed) {
	          var temp = cost[targetIndex] + weight;
	          if (temp < cost[sourceIndex]) {
	            cost[sourceIndex] = temp;
	            predecessor[sourceIndex] = targetIndex;
	            predEdge[sourceIndex] = edges[e];
	            flag = true;
	          }
	        }
	      }
	
	      if (!flag) {
	        break;
	      }
	    }
	
	    if (flag) {
	      // Check for negative weight cycles
	      for (var e = 0; e < edges.length; e++) {
	        var sourceIndex = id2position[edges[e].source().id()];
	        var targetIndex = id2position[edges[e].target().id()];
	        var weight = weightFn.apply(edges[e], [edges[e]]);
	
	        if (cost[sourceIndex] + weight < cost[targetIndex]) {
	          util.error("Graph contains a negative weight cycle for Bellman-Ford");
	          return { pathTo: undefined,
	               distanceTo: undefined,
	               hasNegativeWeightCycle: true};
	        }
	      }
	    }
	
	    // Build result object
	    var position2id = [];
	    for (var i = 0; i < numNodes; i++) {
	      position2id.push(nodes[i].id());
	    }
	
	
	    var res = {
	      distanceTo : function(to) {
	        if (is.string(to)) {
	          // to is a selector string
	          var toId = (cy.filter(to)[0]).id();
	        } else {
	          // to is a node
	          var toId = to.id();
	        }
	
	        return cost[id2position[toId]];
	      },
	
	      pathTo : function(to) {
	
	        var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
	          for(;;){
	            // Add toId to path
	            acumPath.push( cy.getElementById(position2id[toPos]) );
	            acumPath.push( predEdge[toPos] );
	
	            if (fromPos === toPos) {
	              // reached starting node
	              return acumPath;
	            }
	
	            // If no path exists, discart acumulated path and return undefined
	            var predPos = predecessor[toPos];
	            if (typeof predPos === "undefined") {
	              return undefined;
	            }
	
	            toPos = predPos;
	          }
	
	        };
	
	        if (is.string(to)) {
	          // to is a selector string
	          var toId = (cy.filter(to)[0]).id();
	        } else {
	          // to is a node
	          var toId = to.id();
	        }
	        var path = [];
	
	        // This returns a reversed path
	        var res =  reconstructPathAux(predecessor,
	                      id2position[source.id()],
	                      id2position[toId],
	                      position2id,
	                      path,
	                      predEdge);
	
	        // Get it in the correct order and return it
	        if (res != null) {
	          res.reverse();
	        }
	
	        return eles.spawn(res);
	      },
	
	      hasNegativeWeightCycle: false
	    };
	
	    return res;
	
	  } // bellmanFord
	
	}); // elesfn
	
	module.exports = elesfn;
	
	},{"../../is":77,"../../util":94}],4:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	
	var elesfn = ({
	
	  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
	  betweennessCentrality: function (options) {
	    options = options || {};
	
	    // Weight - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weightFn = options.weight;
	      var weighted = true;
	    } else {
	      var weighted = false;
	    }
	
	    // Directed - default false
	    if (options.directed != null && is.bool(options.directed)) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    var priorityInsert = function (queue, ele) {
	      queue.unshift(ele);
	      for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
	        var tmp = queue[i];
	        queue[i] = queue[i + 1];
	        queue[i + 1] = tmp;
	      }
	    };
	
	    var cy = this._private.cy;
	
	    // starting
	    var V = this.nodes();
	    var A = {};
	    var C = {};
	
	    // A contains the neighborhoods of every node
	    for (var i = 0; i < V.length; i++) {
	      if (directed) {
	        A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
	      } else {
	        A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node
	      }
	    }
	
	    // C contains the betweenness values
	    for (var i = 0; i < V.length; i++) {
	      C[V[i].id()] = 0;
	    }
	
	    for (var s = 0; s < V.length; s++) {
	      var S = []; // stack
	      var P = {};
	      var g = {};
	      var d = {};
	      var Q = []; // queue
	
	      // init dictionaries
	      for (var i = 0; i < V.length; i++) {
	        P[V[i].id()] = [];
	        g[V[i].id()] = 0;
	        d[V[i].id()] = Number.POSITIVE_INFINITY;
	      }
	
	      g[V[s].id()] = 1; // sigma
	      d[V[s].id()] = 0; // distance to s
	
	      Q.unshift(V[s].id());
	
	      while (Q.length > 0) {
	        var v = Q.pop();
	        S.push(v);
	        if (weighted) {
	          A[v].forEach(function (w) {
	            if (cy.$('#' + v).edgesTo(w).length > 0) {
	              var edge = cy.$('#' + v).edgesTo(w)[0];
	            } else {
	              var edge = w.edgesTo('#' + v)[0];
	            }
	
	            var edgeWeight = weightFn.apply(edge, [edge]);
	
	            if (d[w.id()] > d[v] + edgeWeight) {
	              d[w.id()] = d[v] + edgeWeight;
	              if (Q.indexOf(w.id()) < 0) { //if w is not in Q
	                priorityInsert(Q, w.id());
	              } else { // update position if w is in Q
	                Q.splice(Q.indexOf(w.id()), 1);
	                priorityInsert(Q, w.id());
	              }
	              g[w.id()] = 0;
	              P[w.id()] = [];
	            }
	            if (d[w.id()] == d[v] + edgeWeight) {
	              g[w.id()] = g[w.id()] + g[v];
	              P[w.id()].push(v);
	            }
	          });
	        } else {
	          A[v].forEach(function (w) {
	            if (d[w.id()] == Number.POSITIVE_INFINITY) {
	              Q.unshift(w.id());
	              d[w.id()] = d[v] + 1;
	            }
	            if (d[w.id()] == d[v] + 1) {
	              g[w.id()] = g[w.id()] + g[v];
	              P[w.id()].push(v);
	            }
	          });
	        }
	      }
	
	      var e = {};
	      for (var i = 0; i < V.length; i++) {
	        e[V[i].id()] = 0;
	      }
	
	      while (S.length > 0) {
	        var w = S.pop();
	        P[w].forEach(function (v) {
	          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
	          if (w != V[s].id())
	            C[w] = C[w] + e[w];
	        });
	      }
	    }
	
	    var max = 0;
	    for (var key in C) {
	      if (max < C[key])
	        max = C[key];
	    }
	
	    var ret = {
	      betweenness: function (node) {
	        if (is.string(node)) {
	          var node = (cy.filter(node)[0]).id();
	        } else {
	          var node = node.id();
	        }
	
	        return C[node];
	      },
	
	      betweennessNormalized: function (node) {
	        if (is.string(node)) {
	          var node = (cy.filter(node)[0]).id();
	        } else {
	          var node = node.id();
	        }
	
	        return C[node] / max;
	      }
	    };
	
	    // alias
	    ret.betweennessNormalised = ret.betweennessNormalized;
	
	    return ret;
	  } // betweennessCentrality
	
	}); // elesfn
	
	// nice, short mathemathical alias
	elesfn.bc = elesfn.betweennessCentrality;
	
	module.exports = elesfn;
	
	},{"../../is":77}],5:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	var Heap = _dereq_('../../heap');
	
	var defineSearch = function( params ){
	  params = {
	    bfs: params.bfs || !params.dfs,
	    dfs: params.dfs || !params.bfs
	  };
	
	  // from pseudocode on wikipedia
	  return function searchFn( roots, fn, directed ){
	    var options;
	    var std;
	    var thisArg;
	    if( is.plainObject(roots) && !is.elementOrCollection(roots) ){
	      options = roots;
	      roots = options.roots || options.root;
	      fn = options.visit;
	      directed = options.directed;
	      std = options.std;
	      thisArg = options.thisArg;
	    }
	
	    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
	    fn = is.fn(fn) ? fn : function(){};
	
	    var cy = this._private.cy;
	    var v = roots = is.string(roots) ? this.filter(roots) : roots;
	    var Q = [];
	    var connectedNodes = [];
	    var connectedBy = {};
	    var id2depth = {};
	    var V = {};
	    var j = 0;
	    var found;
	    var nodes = this.nodes();
	    var edges = this.edges();
	
	    // enqueue v
	    for( var i = 0; i < v.length; i++ ){
	      if( v[i].isNode() ){
	        Q.unshift( v[i] );
	
	        if( params.bfs ){
	          V[ v[i].id() ] = true;
	
	          connectedNodes.push( v[i] );
	        }
	
	        id2depth[ v[i].id() ] = 0;
	      }
	    }
	
	    while( Q.length !== 0 ){
	      var v = params.bfs ? Q.shift() : Q.pop();
	
	      if( params.dfs ){
	        if( V[ v.id() ] ){ continue; }
	
	        V[ v.id() ] = true;
	
	        connectedNodes.push( v );
	      }
	
	      var depth = id2depth[ v.id() ];
	      var prevEdge = connectedBy[ v.id() ];
	      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
	      var ret;
	
	      if( std ){
	        ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
	      } else {
	        ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
	      }
	
	      if( ret === true ){
	        found = v;
	        break;
	      }
	
	      if( ret === false ){
	        break;
	      }
	
	      var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
	      for( var i = 0; i < vwEdges.length; i++ ){
	        var e = vwEdges[i];
	        var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );
	
	        if( w.length !== 0 && !V[ w.id() ] ){
	          w = w[0];
	
	          Q.push( w );
	
	          if( params.bfs ){
	            V[ w.id() ] = true;
	
	            connectedNodes.push( w );
	          }
	
	          connectedBy[ w.id() ] = e;
	
	          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
	        }
	      }
	
	    }
	
	    var connectedEles = [];
	
	    for( var i = 0; i < connectedNodes.length; i++ ){
	      var node = connectedNodes[i];
	      var edge = connectedBy[ node.id() ];
	
	      if( edge ){
	        connectedEles.push( edge );
	      }
	
	      connectedEles.push( node );
	    }
	
	    return {
	      path: cy.collection( connectedEles, { unique: true } ),
	      found: cy.collection( found )
	    };
	  };
	};
	
	// search, spanning trees, etc
	var elesfn = ({
	
	  breadthFirstSearch: defineSearch({ bfs: true }),
	  depthFirstSearch: defineSearch({ dfs: true }),
	
	  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
	  // implemented from pseudocode from wikipedia
	  kruskal: function( weightFn ){
	    var cy = this.cy();
	
	    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)
	
	    function findSet(ele){
	      for( var i = 0; i < forest.length; i++ ){
	        var eles = forest[i];
	
	        if( eles.anySame(ele) ){
	          return {
	            eles: eles,
	            index: i
	          };
	        }
	      }
	    }
	
	    var A = cy.collection(cy, []);
	    var forest = [];
	    var nodes = this.nodes();
	
	    for( var i = 0; i < nodes.length; i++ ){
	      forest.push( nodes[i].collection() );
	    }
	
	    var edges = this.edges();
	    var S = edges.toArray().sort(function(a, b){
	      var weightA = weightFn.call(a, a);
	      var weightB = weightFn.call(b, b);
	
	      return weightA - weightB;
	    });
	
	    for(var i = 0; i < S.length; i++){
	      var edge = S[i];
	      var u = edge.source()[0];
	      var v = edge.target()[0];
	      var setU = findSet(u);
	      var setV = findSet(v);
	
	      if( setU.index !== setV.index ){
	        A = A.add( edge );
	
	        // combine forests for u and v
	        forest[ setU.index ] = setU.eles.add( setV.eles );
	        forest.splice( setV.index, 1 );
	      }
	    }
	
	    return nodes.add( A );
	
	  },
	
	  dijkstra: function( root, weightFn, directed ){
	    var options;
	    if( is.plainObject(root) && !is.elementOrCollection(root) ){
	      options = root;
	      root = options.root;
	      weightFn = options.weight;
	      directed = options.directed;
	    }
	
	    var cy = this._private.cy;
	    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)
	
	    var source = is.string(root) ? this.filter(root)[0] : root[0];
	    var dist = {};
	    var prev = {};
	    var knownDist = {};
	
	    var edges = this.edges().filter(function(){ return !this.isLoop(); });
	    var nodes = this.nodes();
	
	    var getDist = function(node){
	      return dist[ node.id() ];
	    };
	
	    var setDist = function(node, d){
	      dist[ node.id() ] = d;
	
	      Q.updateItem( node );
	    };
	
	    var Q = new Heap(function( a, b ){
	      return getDist(a) - getDist(b);
	    });
	
	    for( var i = 0; i < nodes.length; i++ ){
	      var node = nodes[i];
	
	      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
	      Q.push( node );
	    }
	
	    var distBetween = function(u, v){
	      var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
	      var smallestDistance = Infinity;
	      var smallestEdge;
	
	      for( var i = 0; i < uvs.length; i++ ){
	        var edge = uvs[i];
	        var weight = weightFn.apply( edge, [edge] );
	
	        if( weight < smallestDistance || !smallestEdge ){
	          smallestDistance = weight;
	          smallestEdge = edge;
	        }
	      }
	
	      return {
	        edge: smallestEdge,
	        dist: smallestDistance
	      };
	    };
	
	    while( Q.size() > 0 ){
	      var u = Q.pop();
	      var smalletsDist = getDist(u);
	      var uid = u.id();
	
	      knownDist[uid] = smalletsDist;
	
	      if( smalletsDist === Math.Infinite ){
	        break;
	      }
	
	      var neighbors = u.neighborhood().intersect(nodes);
	      for( var i = 0; i < neighbors.length; i++ ){
	        var v = neighbors[i];
	        var vid = v.id();
	        var vDist = distBetween(u, v);
	
	        var alt = smalletsDist + vDist.dist;
	
	        if( alt < getDist(v) ){
	          setDist(v, alt);
	
	          prev[ vid ] = {
	            node: u,
	            edge: vDist.edge
	          };
	        }
	      } // for
	    } // while
	
	    return {
	      distanceTo: function(node){
	        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
	
	        return knownDist[ target.id() ];
	      },
	
	      pathTo: function(node){
	        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
	        var S = [];
	        var u = target;
	
	        if( target.length > 0 ){
	          S.unshift( target );
	
	          while( prev[ u.id() ] ){
	            var p = prev[ u.id() ];
	
	            S.unshift( p.edge );
	            S.unshift( p.node );
	
	            u = p.node;
	          }
	        }
	
	        return cy.collection( S );
	      }
	    };
	  }
	});
	
	// nice, short mathemathical alias
	elesfn.bfs = elesfn.breadthFirstSearch;
	elesfn.dfs = elesfn.depthFirstSearch;
	
	module.exports = elesfn;
	
	},{"../../heap":75,"../../is":77}],6:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	
	var elesfn = ({
	
	  closenessCentralityNormalized: function (options) {
	    options = options || {};
	
	    var cy = this.cy();
	
	    var harmonic = options.harmonic;
	    if( harmonic === undefined ){
	      harmonic = true;
	    }
	
	    var closenesses = {};
	    var maxCloseness = 0;
	    var nodes = this.nodes();
	    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });
	
	    // Compute closeness for every node and find the maximum closeness
	    for(var i = 0; i < nodes.length; i++){
	      var currCloseness = 0;
	      for (var j = 0; j < nodes.length; j++) {
	        if (i != j) {
	          var d = fw.distance(nodes[i], nodes[j]);
	
	          if( harmonic ){
	            currCloseness += 1 / d;
	          } else {
	            currCloseness += d;
	          }
	        }
	      }
	
	      if( !harmonic ){
	        currCloseness = 1 / currCloseness;
	      }
	
	      if (maxCloseness < currCloseness){
	        maxCloseness = currCloseness;
	      }
	
	      closenesses[nodes[i].id()] = currCloseness;
	    }
	
	    return {
	      closeness: function (node) {
	        if (is.string(node)) {
	          // from is a selector string
	          var node = (cy.filter(node)[0]).id();
	        } else {
	          // from is a node
	          var node = node.id();
	        }
	
	        return closenesses[node] / maxCloseness;
	      }
	    };
	  },
	
	  // Implemented from pseudocode from wikipedia
	  closenessCentrality: function (options) {
	    options = options || {};
	
	    // root - mandatory!
	    if (options.root != null) {
	      if (is.string(options.root)) {
	        // use it as a selector, e.g. "#rootID
	        var root = this.filter(options.root)[0];
	      } else {
	        var root = options.root[0];
	      }
	    } else {
	      return undefined;
	    }
	
	    // weight - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weight = options.weight;
	    } else {
	      var weight = function(){return 1;};
	    }
	
	    // directed - optional
	    if (options.directed != null && is.bool(options.directed)) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    var harmonic = options.harmonic;
	    if( harmonic === undefined ){
	      harmonic = true;
	    }
	
	    // we need distance from this node to every other node
	    var dijkstra = this.dijkstra({
	      root: root,
	      weight: weight,
	      directed: directed
	    });
	    var totalDistance = 0;
	
	    var nodes = this.nodes();
	    for (var i = 0; i < nodes.length; i++){
	      if (nodes[i].id() != root.id()){
	        var d = dijkstra.distanceTo(nodes[i]);
	
	        if( harmonic ){
	          totalDistance += 1 / d;
	        } else {
	          totalDistance += d;
	        }
	      }
	    }
	
	    return harmonic ? totalDistance : 1 / totalDistance;
	  } // closenessCentrality
	
	}); // elesfn
	
	// nice, short mathemathical alias
	elesfn.cc = elesfn.closenessCentrality;
	elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;
	
	module.exports = elesfn;
	
	},{"../../is":77}],7:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	var util = _dereq_('../../util');
	
	var elesfn = ({
	
	  degreeCentralityNormalized: function (options) {
	    options = options || {};
	
	    var cy = this.cy();
	
	    // directed - optional
	    if (options.directed != null) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    var nodes = this.nodes();
	    var numNodes = nodes.length;
	
	    if (!directed) {
	      var degrees = {};
	      var maxDegree = 0;
	
	      for (var i = 0; i < numNodes; i++) {
	        var node = nodes[i];
	        // add current node to the current options object and call degreeCentrality
	        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));
	        if (maxDegree < currDegree.degree)
	          maxDegree = currDegree.degree;
	
	        degrees[node.id()] = currDegree.degree;
	      }
	
	      return {
	        degree: function (node) {
	          if (is.string(node)) {
	            // from is a selector string
	            var node = (cy.filter(node)[0]).id();
	          } else {
	            // from is a node
	            var node = node.id();
	          }
	
	          return degrees[node] / maxDegree;
	        }
	      };
	    } else {
	      var indegrees = {};
	      var outdegrees = {};
	      var maxIndegree = 0;
	      var maxOutdegree = 0;
	
	      for (var i = 0; i < numNodes; i++) {
	        var node = nodes[i];
	        // add current node to the current options object and call degreeCentrality
	        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));
	
	        if (maxIndegree < currDegree.indegree)
	          maxIndegree = currDegree.indegree;
	
	        if (maxOutdegree < currDegree.outdegree)
	          maxOutdegree = currDegree.outdegree;
	
	        indegrees[node.id()] = currDegree.indegree;
	        outdegrees[node.id()] = currDegree.outdegree;
	      }
	
	      return {
	        indegree: function (node) {
	          if (is.string(node)) {
	            // from is a selector string
	            var node = (cy.filter(node)[0]).id();
	          } else {
	            // from is a node
	            var node = node.id();
	          }
	
	          return indegrees[node] / maxIndegree;
	        },
	        outdegree: function (node) {
	          if (is.string(node)) {
	            // from is a selector string
	            var node = (cy.filter(node)[0]).id();
	          } else {
	            // from is a node
	            var node = node.id();
	          }
	
	          return outdegrees[node] / maxOutdegree;
	        }
	
	      };
	    }
	
	  }, // degreeCentralityNormalized
	
	  // Implemented from the algorithm in Opsahl's paper
	  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
	  // check the heading 2 "Degree"
	  degreeCentrality: function (options) {
	    options = options || {};
	
	    var callingEles = this;
	
	    // root - mandatory!
	    if (options != null && options.root != null) {
	      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
	    } else {
	      return undefined;
	    }
	
	    // weight - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weightFn = options.weight;
	    } else {
	      // If not specified, assume each edge has equal weight (1)
	      var weightFn = function (e) {
	        return 1;
	      };
	    }
	
	    // directed - optional
	    if (options.directed != null) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    // alpha - optional
	    if (options.alpha != null && is.number(options.alpha)) {
	      var alpha = options.alpha;
	    } else {
	      alpha = 0;
	    }
	
	
	    if (!directed) {
	      var connEdges = root.connectedEdges().intersection( callingEles );
	      var k = connEdges.length;
	      var s = 0;
	
	      // Now, sum edge weights
	      for (var i = 0; i < connEdges.length; i++) {
	        var edge = connEdges[i];
	        s += weightFn.apply(edge, [edge]);
	      }
	
	      return {
	        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
	      };
	    } else {
	      var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
	      var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
	      var k_in = incoming.length;
	      var k_out = outgoing.length;
	      var s_in = 0;
	      var s_out = 0;
	
	      // Now, sum incoming edge weights
	      for (var i = 0; i < incoming.length; i++) {
	        var edge = incoming[i];
	        s_in += weightFn.apply(edge, [edge]);
	      }
	
	      // Now, sum outgoing edge weights
	      for (var i = 0; i < outgoing.length; i++) {
	        var edge = outgoing[i];
	        s_out += weightFn.apply(edge, [edge]);
	      }
	
	      return {
	        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
	        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
	      };
	    }
	  } // degreeCentrality
	
	}); // elesfn
	
	// nice, short mathemathical alias
	elesfn.dc = elesfn.degreeCentrality;
	elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;
	
	module.exports = elesfn;
	
	},{"../../is":77,"../../util":94}],8:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	
	var elesfn = ({
	
	  // Implemented from pseudocode from wikipedia
	  floydWarshall: function(options) {
	    options = options || {};
	
	    var cy = this.cy();
	
	    // Weight function - optional
	    if (options.weight != null && is.fn(options.weight)) {
	      var weightFn = options.weight;
	    } else {
	      // If not specified, assume each edge has equal weight (1)
	      var weightFn = function(e) {return 1;};
	    }
	
	    // directed - optional
	    if (options.directed != null) {
	      var directed = options.directed;
	    } else {
	      var directed = false;
	    }
	
	    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
	    var nodes = this.nodes();
	    var numNodes = nodes.length;
	
	    // mapping: node id -> position in nodes array
	    var id2position = {};
	    for (var i = 0; i < numNodes; i++) {
	      id2position[nodes[i].id()] = i;
	    }
	
	    // Initialize distance matrix
	    var dist = [];
	    for (var i = 0; i < numNodes; i++) {
	      var newRow = new Array(numNodes);
	      for (var j = 0; j < numNodes; j++) {
	        if (i == j) {
	          newRow[j] = 0;
	        } else {
	          newRow[j] = Infinity;
	        }
	      }
	      dist.push(newRow);
	    }
	
	    // Initialize matrix used for path reconstruction
	    // Initialize distance matrix
	    var next = [];
	    var edgeNext = [];
	
	    var initMatrix = function(next){
	      for (var i = 0; i < numNodes; i++) {
	        var newRow = new Array(numNodes);
	        for (var j = 0; j < numNodes; j++) {
	          newRow[j] = undefined;
	        }
	        next.push(newRow);
	      }
	    };
	
	    initMatrix(next);
	    initMatrix(edgeNext);
	
	    // Process edges
	    for (var i = 0; i < edges.length ; i++) {
	      var sourceIndex = id2position[edges[i].source().id()];
	      var targetIndex = id2position[edges[i].target().id()];
	      var weight = weightFn.apply(edges[i], [edges[i]]);
	
	      // Check if already process another edge between same 2 nodes
	      if (dist[sourceIndex][targetIndex] > weight) {
	        dist[sourceIndex][targetIndex] = weight;
	        next[sourceIndex][targetIndex] = targetIndex;
	        edgeNext[sourceIndex][targetIndex] = edges[i];
	      }
	    }
	
	    // If undirected graph, process 'reversed' edges
	    if (!directed) {
	      for (var i = 0; i < edges.length ; i++) {
	        var sourceIndex = id2position[edges[i].target().id()];
	        var targetIndex = id2position[edges[i].source().id()];
	        var weight = weightFn.apply(edges[i], [edges[i]]);
	
	        // Check if already process another edge between same 2 nodes
	        if (dist[sourceIndex][targetIndex] > weight) {
	          dist[sourceIndex][targetIndex] = weight;
	          next[sourceIndex][targetIndex] = targetIndex;
	          edgeNext[sourceIndex][targetIndex] = edges[i];
	        }
	      }
	    }
	
	    // Main loop
	    for (var k = 0; k < numNodes; k++) {
	      for (var i = 0; i < numNodes; i++) {
	        for (var j = 0; j < numNodes; j++) {
	          if (dist[i][k] + dist[k][j] < dist[i][j]) {
	            dist[i][j] = dist[i][k] + dist[k][j];
	            next[i][j] = next[i][k];
	          }
	        }
	      }
	    }
	
	    // Build result object
	    var position2id = [];
	    for (var i = 0; i < numNodes; i++) {
	      position2id.push(nodes[i].id());
	    }
	
	    var res = {
	      distance: function(from, to) {
	        if (is.string(from)) {
	          // from is a selector string
	          var fromId = (cy.filter(from)[0]).id();
	        } else {
	          // from is a node
	          var fromId = from.id();
	        }
	
	        if (is.string(to)) {
	          // to is a selector string
	          var toId = (cy.filter(to)[0]).id();
	        } else {
	          // to is a node
	          var toId = to.id();
	        }
	
	        return dist[id2position[fromId]][id2position[toId]];
	      },
	
	      path: function(from, to) {
	        var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
	          if (from === to) {
	            return cy.getElementById( position2id[from] );
	          }
	          if (next[from][to] === undefined) {
	            return undefined;
	          }
	
	          var path = [ cy.getElementById(position2id[from]) ];
	          var prev = from;
	          while (from !== to) {
	            prev = from;
	            from = next[from][to];
	
	            var edge = edgeNext[prev][from];
	            path.push( edge );
	
	            path.push( cy.getElementById(position2id[from]) );
	          }
	          return path;
	        };
	
	        if (is.string(from)) {
	          // from is a selector string
	          var fromId = (cy.filter(from)[0]).id();
	        } else {
	          // from is a node
	          var fromId = from.id();
	        }
	
	        if (is.string(to)) {
	          // to is a selector string
	          var toId = (cy.filter(to)[0]).id();
	        } else {
	          // to is a node
	          var toId = to.id();
	        }
	
	        var pathArr = reconstructPathAux(id2position[fromId],
	                      id2position[toId],
	                      next,
	                      position2id,
	                      edgeNext);
	
	        return cy.collection( pathArr );
	      }
	    };
	
	    return res;
	
	  } // floydWarshall
	
	}); // elesfn
	
	module.exports = elesfn;
	
	},{"../../is":77}],9:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	
	var elesfn = {};
	
	[
	  _dereq_('./bfs-dfs'),
	  _dereq_('./a-star'),
	  _dereq_('./floyd-warshall'),
	  _dereq_('./bellman-ford'),
	  _dereq_('./kerger-stein'),
	  _dereq_('./page-rank'),
	  _dereq_('./degree-centrality'),
	  _dereq_('./closeness-centrality'),
	  _dereq_('./betweenness-centrality')
	].forEach(function( props ){
	  util.extend( elesfn, props );
	});
	
	module.exports = elesfn;
	
	},{"../../util":94,"./a-star":2,"./bellman-ford":3,"./betweenness-centrality":4,"./bfs-dfs":5,"./closeness-centrality":6,"./degree-centrality":7,"./floyd-warshall":8,"./kerger-stein":10,"./page-rank":11}],10:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	
	var elesfn = ({
	
	  // Computes the minimum cut of an undirected graph
	  // Returns the correct answer with high probability
	  kargerStein: function(options) {
	    var eles = this;
	
	    options = options || {};
	
	    // Function which colapses 2 (meta) nodes into one
	    // Updates the remaining edge lists
	    // Receives as a paramater the edge which causes the collapse
	    var colapse = function(edgeIndex, nodeMap, remainingEdges) {
	      var edgeInfo = remainingEdges[edgeIndex];
	      var sourceIn = edgeInfo[1];
	      var targetIn = edgeInfo[2];
	      var partition1 = nodeMap[sourceIn];
	      var partition2 = nodeMap[targetIn];
	
	      // Delete all edges between partition1 and partition2
	      var newEdges = remainingEdges.filter(function(edge) {
	        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
	          return false;
	        }
	        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
	          return false;
	        }
	        return true;
	      });
	
	      // All edges pointing to partition2 should now point to partition1
	      for (var i = 0; i < newEdges.length; i++) {
	        var edge = newEdges[i];
	        if (edge[1] === partition2) { // Check source
	          newEdges[i] = edge.slice(0);
	          newEdges[i][1] = partition1;
	        } else if (edge[2] === partition2) { // Check target
	          newEdges[i] = edge.slice(0);
	          newEdges[i][2] = partition1;
	        }
	      }
	
	      // Move all nodes from partition2 to partition1
	      for (var i = 0; i < nodeMap.length; i++) {
	        if (nodeMap[i] === partition2) {
	          nodeMap[i] = partition1;
	        }
	      }
	
	      return newEdges;
	    };
	
	
	    // Contracts a graph until we reach a certain number of meta nodes
	    var contractUntil = function(metaNodeMap,
	                   remainingEdges,
	                   size,
	                   sizeLimit) {
	      // Stop condition
	      if (size <= sizeLimit) {
	        return remainingEdges;
	      }
	
	      // Choose an edge randomly
	      var edgeIndex = Math.floor((Math.random() * remainingEdges.length));
	
	      // Colapse graph based on edge
	      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
	
	      return contractUntil(metaNodeMap,
	                 newEdges,
	                 size - 1,
	                 sizeLimit);
	    };
	
	    var cy = this._private.cy;
	    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
	    var nodes = this.nodes();
	    var numNodes = nodes.length;
	    var numEdges = edges.length;
	    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
	    var stopSize = Math.floor(numNodes / Math.sqrt(2));
	
	    if (numNodes < 2) {
	      util.error("At least 2 nodes are required for Karger-Stein algorithm");
	      return undefined;
	    }
	
	    // Create numerical identifiers for each node
	    // mapping: node id -> position in nodes array
	    // for reverse mapping, simply use nodes array
	    var id2position = {};
	    for (var i = 0; i < numNodes; i++) {
	      id2position[nodes[i].id()] = i;
	    }
	
	    // Now store edge destination as indexes
	    // Format for each edge (edge index, source node index, target node index)
	    var edgeIndexes = [];
	    for (var i = 0; i < numEdges; i++) {
	      var e = edges[i];
	      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
	    }
	
	    // We will store the best cut found here
	    var minCutSize = Infinity;
	    var minCut;
	
	    // Initial meta node partition
	    var originalMetaNode = [];
	    for (var i = 0; i < numNodes; i++) {
	      originalMetaNode.push(i);
	    }
	
	    // Main loop
	    for (var iter = 0; iter <= numIter; iter++) {
	      // Create new meta node partition
	      var metaNodeMap = originalMetaNode.slice(0);
	
	      // Contract until stop point (stopSize nodes)
	      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
	
	      // Create a copy of the colapsed nodes state
	      var metaNodeMap2 = metaNodeMap.slice(0);
	
	      // Run 2 iterations starting in the stop state
	      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
	      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);
	
	      // Is any of the 2 results the best cut so far?
	      if (res1.length <= res2.length && res1.length < minCutSize) {
	        minCutSize = res1.length;
	        minCut = [res1, metaNodeMap];
	      } else if (res2.length <= res1.length && res2.length < minCutSize) {
	        minCutSize = res2.length;
	        minCut = [res2, metaNodeMap2];
	      }
	    } // end of main loop
	
	
	    // Construct result
	    var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
	    var partition1 = [];
	    var partition2 = [];
	
	    // traverse metaNodeMap for best cut
	    var witnessNodePartition = minCut[1][0];
	    for (var i = 0; i < minCut[1].length; i++) {
	      var partitionId = minCut[1][i];
	      if (partitionId === witnessNodePartition) {
	        partition1.push(nodes[i]);
	      } else {
	        partition2.push(nodes[i]);
	      }
	    }
	
	    var ret = {
	      cut: eles.spawn(cy, resEdges),
	      partition1: eles.spawn(partition1),
	      partition2: eles.spawn(partition2)
	    };
	
	    return ret;
	  }
	}); // elesfn
	
	
	module.exports = elesfn;
	
	},{"../../util":94}],11:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../is');
	
	var elesfn = ({
	
	  pageRank: function(options) {
	    options = options || {};
	
	    var normalizeVector = function(vector) {
	      var length = vector.length;
	
	      // First, get sum of all elements
	      var total = 0;
	      for (var i = 0; i < length; i++) {
	        total += vector[i];
	      }
	
	      // Now, divide each by the sum of all elements
	      for (var i = 0; i < length; i++) {
	        vector[i] = vector[i] / total;
	      }
	    };
	
	    // dampingFactor - optional
	    if (options != null &&
	      options.dampingFactor != null) {
	      var dampingFactor = options.dampingFactor;
	    } else {
	      var dampingFactor = 0.8; // Default damping factor
	    }
	
	    // desired precision - optional
	    if (options != null &&
	      options.precision != null) {
	      var epsilon = options.precision;
	    } else {
	      var epsilon = 0.000001; // Default precision
	    }
	
	    // Max number of iterations - optional
	    if (options != null &&
	      options.iterations != null) {
	      var numIter = options.iterations;
	    } else {
	      var numIter = 200; // Default number of iterations
	    }
	
	    // Weight function - optional
	    if (options != null &&
	      options.weight != null &&
	      is.fn(options.weight)) {
	      var weightFn = options.weight;
	    } else {
	      // If not specified, assume each edge has equal weight (1)
	      var weightFn = function(e) {return 1;};
	    }
	
	    var cy = this._private.cy;
	    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
	    var nodes = this.nodes();
	    var numNodes = nodes.length;
	    var numEdges = edges.length;
	
	    // Create numerical identifiers for each node
	    // mapping: node id -> position in nodes array
	    // for reverse mapping, simply use nodes array
	    var id2position = {};
	    for (var i = 0; i < numNodes; i++) {
	      id2position[nodes[i].id()] = i;
	    }
	
	    // Construct transposed adjacency matrix
	    // First lets have a zeroed matrix of the right size
	    // We'll also keep track of the sum of each column
	    var matrix = [];
	    var columnSum = [];
	    var additionalProb = (1 - dampingFactor) / numNodes;
	
	    // Create null matric
	    for (var i = 0; i < numNodes; i++) {
	      var newRow = [];
	      for (var j = 0; j < numNodes; j++) {
	        newRow.push(0.0);
	      }
	      matrix.push(newRow);
	      columnSum.push(0.0);
	    }
	
	    // Now, process edges
	    for (var i = 0; i < numEdges; i++) {
	      var edge = edges[i];
	      var s = id2position[edge.source().id()];
	      var t = id2position[edge.target().id()];
	      var w = weightFn.apply(edge, [edge]);
	
	      // Update matrix
	      matrix[t][s] += w;
	
	      // Update column sum
	      columnSum[s] += w;
	    }
	
	    // Add additional probability based on damping factor
	    // Also, take into account columns that have sum = 0
	    var p = 1.0 / numNodes + additionalProb; // Shorthand
	    // Traverse matrix, column by column
	    for (var j = 0; j < numNodes; j++) {
	      if (columnSum[j] === 0) {
	        // No 'links' out from node jth, assume equal probability for each possible node
	        for (var i = 0; i < numNodes; i++) {
	          matrix[i][j] = p;
	        }
	      } else {
	        // Node jth has outgoing link, compute normalized probabilities
	        for (var i = 0; i < numNodes; i++) {
	          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
	        }
	      }
	    }
	
	    // Compute dominant eigenvector using power method
	    var eigenvector = [];
	    var nullVector = [];
	    var previous;
	
	    // Start with a vector of all 1's
	    // Also, initialize a null vector which will be used as shorthand
	    for (var i = 0; i < numNodes; i++) {
	      eigenvector.push(1.0);
	      nullVector.push(0.0);
	    }
	
	    for (var iter = 0; iter < numIter; iter++) {
	      // New array with all 0's
	      var temp = nullVector.slice(0);
	
	      // Multiply matrix with previous result
	      for (var i = 0; i < numNodes; i++) {
	        for (var j = 0; j < numNodes; j++) {
	          temp[i] += matrix[i][j] * eigenvector[j];
	        }
	      }
	
	      normalizeVector(temp);
	      previous = eigenvector;
	      eigenvector = temp;
	
	      var diff = 0;
	      // Compute difference (squared module) of both vectors
	      for (var i = 0; i < numNodes; i++) {
	        diff += Math.pow(previous[i] - eigenvector[i], 2);
	      }
	
	      // If difference is less than the desired threshold, stop iterating
	      if (diff < epsilon) {
	        break;
	      }
	    }
	
	    // Construct result
	    var res = {
	      rank : function(node) {
	        if (is.string(node)) {
	          // is a selector string
	          var nodeId = (cy.filter(node)[0]).id();
	        } else {
	          // is a node object
	          var nodeId = node.id();
	        }
	        return eigenvector[id2position[nodeId]];
	      }
	    };
	
	
	    return res;
	  } // pageRank
	
	}); // elesfn
	
	module.exports = elesfn;
	
	},{"../../is":77}],12:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	
	var elesfn = ({
	  animate: define.animate(),
	  animation: define.animation(),
	  animated: define.animated(),
	  clearQueue: define.clearQueue(),
	  delay: define.delay(),
	  delayAnimation: define.delayAnimation(),
	  stop: define.stop()
	});
	
	module.exports = elesfn;
	
	},{"../define":41}],13:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	
	var elesfn = ({
	  classes: function( classes ){
	    classes = classes.match(/\S+/g) || [];
	    var self = this;
	    var changed = [];
	    var classesMap = {};
	
	    // fill in classes map
	    for( var i = 0; i < classes.length; i++ ){
	      var cls = classes[i];
	
	      classesMap[ cls ] = true;
	    }
	
	    // check and update each ele
	    for( var j = 0; j < self.length; j++ ){
	      var ele = self[j];
	      var _p = ele._private;
	      var eleClasses = _p.classes;
	      var changedEle = false;
	
	      // check if ele has all of the passed classes
	      for( var i = 0; i < classes.length; i++ ){
	        var cls = classes[i];
	        var eleHasClass = eleClasses[ cls ];
	
	        if( !eleHasClass ){
	          changedEle = true;
	          break;
	        }
	      }
	
	      // check if ele has classes outside of those passed
	      if( !changedEle ){ for( var eleCls in eleClasses ){
	        var eleHasClass = eleClasses[ eleCls ];
	        var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function
	
	        if( eleHasClass && !specdClass ){
	          changedEle = true;
	          break;
	        }
	      } }
	
	      if( changedEle ){
	        _p.classes = util.copy( classesMap );
	
	        changed.push( ele );
	      }
	    }
	
	    // trigger update style on those eles that had class changes
	    if( changed.length > 0 ){
	      this.spawn(changed)
	        .updateStyle()
	        .trigger('class')
	      ;
	    }
	
	    return self;
	  },
	
	  addClass: function( classes ){
	    return this.toggleClass( classes, true );
	  },
	
	  hasClass: function( className ){
	    var ele = this[0];
	    return ( ele != null && ele._private.classes[className] ) ? true : false;
	  },
	
	  toggleClass: function( classesStr, toggle ){
	    var classes = classesStr.match(/\S+/g) || [];
	    var self = this;
	    var changed = []; // eles who had classes changed
	
	    for( var i = 0, il = self.length; i < il; i++ ){
	      var ele = self[i];
	      var changedEle = false;
	
	      for( var j = 0; j < classes.length; j++ ){
	        var cls = classes[j];
	        var eleClasses = ele._private.classes;
	        var hasClass = eleClasses[cls];
	        var shouldAdd = toggle || (toggle === undefined && !hasClass);
	
	        if( shouldAdd ){
	          eleClasses[cls] = true;
	
	          if( !hasClass && !changedEle ){
	            changed.push(ele);
	            changedEle = true;
	          }
	        } else { // then remove
	          eleClasses[cls] = false;
	
	          if( hasClass && !changedEle ){
	            changed.push(ele);
	            changedEle = true;
	          }
	        }
	
	      } // for j classes
	    } // for i eles
	
	    // trigger update style on those eles that had class changes
	    if( changed.length > 0 ){
	      this.spawn(changed)
	        .updateStyle()
	        .trigger('class')
	      ;
	    }
	
	    return self;
	  },
	
	  removeClass: function( classes ){
	    return this.toggleClass( classes, false );
	  },
	
	  flashClass: function( classes, duration ){
	    var self = this;
	
	    if( duration == null ){
	      duration = 250;
	    } else if( duration === 0 ){
	      return self; // nothing to do really
	    }
	
	    self.addClass( classes );
	    setTimeout(function(){
	      self.removeClass( classes );
	    }, duration);
	
	    return self;
	  }
	});
	
	module.exports = elesfn;
	
	},{"../util":94}],14:[function(_dereq_,module,exports){
	'use strict';
	
	var elesfn = ({
	  allAre: function( selector ){
	    return this.filter(selector).length === this.length;
	  },
	
	  is: function( selector ){
	    return this.filter(selector).length > 0;
	  },
	
	  some: function( fn, thisArg ){
	    for( var i = 0; i < this.length; i++ ){
	      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );
	
	      if( ret ){
	        return true;
	      }
	    }
	
	    return false;
	  },
	
	  every: function( fn, thisArg ){
	    for( var i = 0; i < this.length; i++ ){
	      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );
	
	      if( !ret ){
	        return false;
	      }
	    }
	
	    return true;
	  },
	
	  same: function( collection ){
	    collection = this.cy().collection( collection );
	
	    // cheap extra check
	    if( this.length !== collection.length ){
	      return false;
	    }
	
	    return this.intersect( collection ).length === this.length;
	  },
	
	  anySame: function( collection ){
	    collection = this.cy().collection( collection );
	
	    return this.intersect( collection ).length > 0;
	  },
	
	  allAreNeighbors: function( collection ){
	    collection = this.cy().collection( collection );
	
	    return this.neighborhood().intersect( collection ).length === collection.length;
	  }
	});
	
	elesfn.allAreNeighbours = elesfn.allAreNeighbors;
	
	module.exports = elesfn;
	
	},{}],15:[function(_dereq_,module,exports){
	'use strict';
	
	var elesfn = ({
	  parent: function( selector ){
	    var parents = [];
	    var cy = this._private.cy;
	
	    for( var i = 0; i < this.length; i++ ){
	      var ele = this[i];
	      var parent = cy.getElementById( ele._private.data.parent );
	
	      if( parent.size() > 0 ){
	        parents.push( parent );
	      }
	    }
	
	    return this.spawn( parents, { unique: true } ).filter( selector );
	  },
	
	  parents: function( selector ){
	    var parents = [];
	
	    var eles = this.parent();
	    while( eles.nonempty() ){
	      for( var i = 0; i < eles.length; i++ ){
	        var ele = eles[i];
	        parents.push( ele );
	      }
	
	      eles = eles.parent();
	    }
	
	    return this.spawn( parents, { unique: true } ).filter( selector );
	  },
	
	  commonAncestors: function( selector ){
	    var ancestors;
	
	    for( var i = 0; i < this.length; i++ ){
	      var ele = this[i];
	      var parents = ele.parents();
	
	      ancestors = ancestors || parents;
	
	      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
	    }
	
	    return ancestors.filter( selector );
	  },
	
	  orphans: function( selector ){
	    return this.stdFilter(function( ele ){
	      return ele.isNode() && ele.parent().empty();
	    }).filter( selector );
	  },
	
	  nonorphans: function( selector ){
	    return this.stdFilter(function( ele ){
	      return ele.isNode() && ele.parent().nonempty();
	    }).filter( selector );
	  },
	
	  children: function( selector ){
	    var children = [];
	
	    for( var i = 0; i < this.length; i++ ){
	      var ele = this[i];
	      children = children.concat( ele._private.children );
	    }
	
	    return this.spawn( children, { unique: true } ).filter( selector );
	  },
	
	  siblings: function( selector ){
	    return this.parent().children().not( this ).filter( selector );
	  },
	
	  isParent: function(){
	    var ele = this[0];
	
	    if( ele ){
	      return ele._private.children.length !== 0;
	    }
	  },
	
	  isChild: function(){
	    var ele = this[0];
	
	    if( ele ){
	      return ele._private.data.parent !== undefined && ele.parent().length !== 0;
	    }
	  },
	
	  descendants: function( selector ){
	    var elements = [];
	
	    function add( eles ){
	      for( var i = 0; i < eles.length; i++ ){
	        var ele = eles[i];
	
	        elements.push( ele );
	
	        if( ele.children().nonempty() ){
	          add( ele.children() );
	        }
	      }
	    }
	
	    add( this.children() );
	
	    return this.spawn( elements, { unique: true } ).filter( selector );
	  }
	});
	
	// aliases
	elesfn.ancestors = elesfn.parents;
	
	module.exports = elesfn;
	
	},{}],16:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	var fn, elesfn;
	
	fn = elesfn = ({
	
	  data: define.data({
	    field: 'data',
	    bindingEvent: 'data',
	    allowBinding: true,
	    allowSetting: true,
	    settingEvent: 'data',
	    settingTriggersEvent: true,
	    triggerFnName: 'trigger',
	    allowGetting: true,
	    immutableKeys: {
	      'id': true,
	      'source': true,
	      'target': true,
	      'parent': true
	    },
	    updateStyle: true
	  }),
	
	  removeData: define.removeData({
	    field: 'data',
	    event: 'data',
	    triggerFnName: 'trigger',
	    triggerEvent: true,
	    immutableKeys: {
	      'id': true,
	      'source': true,
	      'target': true,
	      'parent': true
	    },
	    updateStyle: true
	  }),
	
	  scratch: define.data({
	    field: 'scratch',
	    bindingEvent: 'scratch',
	    allowBinding: true,
	    allowSetting: true,
	    settingEvent: 'scratch',
	    settingTriggersEvent: true,
	    triggerFnName: 'trigger',
	    allowGetting: true,
	    updateStyle: true
	  }),
	
	  removeScratch: define.removeData({
	    field: 'scratch',
	    event: 'scratch',
	    triggerFnName: 'trigger',
	    triggerEvent: true,
	    updateStyle: true
	  }),
	
	  rscratch: define.data({
	    field: 'rscratch',
	    allowBinding: false,
	    allowSetting: true,
	    settingTriggersEvent: false,
	    allowGetting: true
	  }),
	
	  removeRscratch: define.removeData({
	    field: 'rscratch',
	    triggerEvent: false
	  }),
	
	  id: function(){
	    var ele = this[0];
	
	    if( ele ){
	      return ele._private.data.id;
	    }
	  }
	
	});
	
	// aliases
	fn.attr = fn.data;
	fn.removeAttr = fn.removeData;
	
	module.exports = elesfn;
	
	},{"../define":41}],17:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	
	var elesfn = {};
	
	function defineDegreeFunction(callback){
	  return function( includeLoops ){
	    var self = this;
	
	    if( includeLoops === undefined ){
	      includeLoops = true;
	    }
	
	    if( self.length === 0 ){ return; }
	
	    if( self.isNode() && !self.removed() ){
	      var degree = 0;
	      var node = self[0];
	      var connectedEdges = node._private.edges;
	
	      for( var i = 0; i < connectedEdges.length; i++ ){
	        var edge = connectedEdges[i];
	
	        if( !includeLoops && edge.isLoop() ){
	          continue;
	        }
	
	        degree += callback( node, edge );
	      }
	
	      return degree;
	    } else {
	      return;
	    }
	  };
	}
	
	util.extend(elesfn, {
	  degree: defineDegreeFunction(function(node, edge){
	    if( edge.source().same( edge.target() ) ){
	      return 2;
	    } else {
	      return 1;
	    }
	  }),
	
	  indegree: defineDegreeFunction(function(node, edge){
	    if( edge.target().same(node) ){
	      return 1;
	    } else {
	      return 0;
	    }
	  }),
	
	  outdegree: defineDegreeFunction(function(node, edge){
	    if( edge.source().same(node) ){
	      return 1;
	    } else {
	      return 0;
	    }
	  })
	});
	
	function defineDegreeBoundsFunction(degreeFn, callback){
	  return function( includeLoops ){
	    var ret;
	    var nodes = this.nodes();
	
	    for( var i = 0; i < nodes.length; i++ ){
	      var ele = nodes[i];
	      var degree = ele[degreeFn]( includeLoops );
	      if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
	        ret = degree;
	      }
	    }
	
	    return ret;
	  };
	}
	
	util.extend(elesfn, {
	  minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
	    return degree < min;
	  }),
	
	  maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
	    return degree > max;
	  }),
	
	  minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
	    return degree < min;
	  }),
	
	  maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
	    return degree > max;
	  }),
	
	  minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
	    return degree < min;
	  }),
	
	  maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
	    return degree > max;
	  })
	});
	
	util.extend(elesfn, {
	  totalDegree: function( includeLoops ){
	    var total = 0;
	    var nodes = this.nodes();
	
	    for( var i = 0; i < nodes.length; i++ ){
	      total += nodes[i].degree( includeLoops );
	    }
	
	    return total;
	  }
	});
	
	module.exports = elesfn;
	
	},{"../util":94}],18:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	var is = _dereq_('../is');
	var util = _dereq_('../util');
	var fn, elesfn;
	
	fn = elesfn = ({
	
	  position: define.data({
	    field: 'position',
	    bindingEvent: 'position',
	    allowBinding: true,
	    allowSetting: true,
	    settingEvent: 'position',
	    settingTriggersEvent: true,
	    triggerFnName: 'rtrigger',
	    allowGetting: true,
	    validKeys: ['x', 'y'],
	    onSet: function( eles ){
	      var updatedEles = eles.updateCompoundBounds();
	      updatedEles.rtrigger('position');
	    },
	    canSet: function( ele ){
	      return !ele.locked() && !ele.isParent();
	    }
	  }),
	
	  // position but no notification to renderer
	  silentPosition: define.data({
	    field: 'position',
	    bindingEvent: 'position',
	    allowBinding: false,
	    allowSetting: true,
	    settingEvent: 'position',
	    settingTriggersEvent: false,
	    triggerFnName: 'trigger',
	    allowGetting: true,
	    validKeys: ['x', 'y'],
	    onSet: function( eles ){
	      eles.updateCompoundBounds();
	    },
	    canSet: function( ele ){
	      return !ele.locked() && !ele.isParent();
	    }
	  }),
	
	  positions: function( pos, silent ){
	    if( is.plainObject(pos) ){
	      this.position(pos);
	
	    } else if( is.fn(pos) ){
	      var fn = pos;
	
	      for( var i = 0; i < this.length; i++ ){
	        var ele = this[i];
	
	        var pos = fn.apply(ele, [i, ele]);
	
	        if( pos && !ele.locked() && !ele.isParent() ){
	          var elePos = ele._private.position;
	          elePos.x = pos.x;
	          elePos.y = pos.y;
	        }
	      }
	
	      var updatedEles = this.updateCompoundBounds();
	      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;
	
	      if( silent ){
	        toTrigger.trigger('position');
	      } else {
	        toTrigger.rtrigger('position');
	      }
	    }
	
	    return this; // chaining
	  },
	
	  silentPositions: function( pos ){
	    return this.positions( pos, true );
	  },
	
	  // get/set the rendered (i.e. on screen) positon of the element
	  renderedPosition: function( dim, val ){
	    var ele = this[0];
	    var cy = this.cy();
	    var zoom = cy.zoom();
	    var pan = cy.pan();
	    var rpos = is.plainObject( dim ) ? dim : undefined;
	    var setting = rpos !== undefined || ( val !== undefined && is.string(dim) );
	
	    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
	      if( setting ){
	        for( var i = 0; i < this.length; i++ ){
	          var ele = this[i];
	
	          if( val !== undefined ){ // set one dimension
	            ele._private.position[dim] = ( val - pan[dim] )/zoom;
	          } else if( rpos !== undefined ){ // set whole position
	            ele._private.position = {
	              x: ( rpos.x - pan.x ) /zoom,
	              y: ( rpos.y - pan.y ) /zoom
	            };
	          }
	        }
	
	        this.rtrigger('position');
	      } else { // getting
	        var pos = ele._private.position;
	        rpos = {
	          x: pos.x * zoom + pan.x,
	          y: pos.y * zoom + pan.y
	        };
	
	        if( dim === undefined ){ // then return the whole rendered position
	          return rpos;
	        } else { // then return the specified dimension
	          return rpos[ dim ];
	        }
	      }
	    } else if( !setting ){
	      return undefined; // for empty collection case
	    }
	
	    return this; // chaining
	  },
	
	  // get/set the position relative to the parent
	  relativePosition: function( dim, val ){
	    var ele = this[0];
	    var cy = this.cy();
	    var ppos = is.plainObject( dim ) ? dim : undefined;
	    var setting = ppos !== undefined || ( val !== undefined && is.string(dim) );
	    var hasCompoundNodes = cy.hasCompoundNodes();
	
	    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
	      if( setting ){
	        for( var i = 0; i < this.length; i++ ){
	          var ele = this[i];
	          var parent = hasCompoundNodes ? ele.parent() : null;
	          var hasParent = parent && parent.length > 0;
	          var relativeToParent = hasParent;
	
	          if( hasParent ){
	            parent = parent[0];
	          }
	
	          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };
	
	          if( val !== undefined ){ // set one dimension
	            ele._private.position[dim] = val + origin[dim];
	          } else if( ppos !== undefined ){ // set whole position
	            ele._private.position = {
	              x: ppos.x + origin.x,
	              y: ppos.y + origin.y
	            };
	          }
	        }
	
	        this.rtrigger('position');
	
	      } else { // getting
	        var pos = ele._private.position;
	        var parent = hasCompoundNodes ? ele.parent() : null;
	        var hasParent = parent && parent.length > 0;
	        var relativeToParent = hasParent;
	
	        if( hasParent ){
	          parent = parent[0];
	        }
	
	        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };
	
	        ppos = {
	          x: pos.x - origin.x,
	          y: pos.y - origin.y
	        };
	
	        if( dim === undefined ){ // then return the whole rendered position
	          return ppos;
	        } else { // then return the specified dimension
	          return ppos[ dim ];
	        }
	      }
	    } else if( !setting ){
	      return undefined; // for empty collection case
	    }
	
	    return this; // chaining
	  },
	
	  renderedBoundingBox: function( options ){
	    var bb = this.boundingBox( options );
	    var cy = this.cy();
	    var zoom = cy.zoom();
	    var pan = cy.pan();
	
	    var x1 = bb.x1 * zoom + pan.x;
	    var x2 = bb.x2 * zoom + pan.x;
	    var y1 = bb.y1 * zoom + pan.y;
	    var y2 = bb.y2 * zoom + pan.y;
	
	    return {
	      x1: x1,
	      x2: x2,
	      y1: y1,
	      y2: y2,
	      w: x2 - x1,
	      h: y2 - y1
	    };
	  },
	
	  updateCompoundBounds: function(){
	    var cy = this.cy();
	
	    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled
	
	    var updated = [];
	
	    function update( parent ){
	      var children = parent.children();
	      var style = parent._private.style;
	      var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
	      var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
	      var padding = {
	        top: style['padding-top'].pfValue,
	        bottom: style['padding-bottom'].pfValue,
	        left: style['padding-left'].pfValue,
	        right: style['padding-right'].pfValue
	      };
	      var pos = parent._private.position;
	      var didUpdate = false;
	
	      if( style['width'].value === 'auto' ){
	        parent._private.autoWidth = bb.w;
	        pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
	        didUpdate = true;
	      }
	
	      if( style['height'].value === 'auto' ){
	        parent._private.autoHeight = bb.h;
	        pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
	        didUpdate = true;
	      }
	
	      if( didUpdate ){
	        updated.push( parent );
	      }
	    }
	
	    // go up, level by level
	    var eles = this.parent();
	    while( eles.nonempty() ){
	
	      // update each parent node in this level
	      for( var i = 0; i < eles.length; i++ ){
	        var ele = eles[i];
	
	        update( ele );
	      }
	
	      // next level
	      eles = eles.parent();
	    }
	
	    // return changed
	    return this.spawn( updated );
	  },
	
	  // get the bounding box of the elements (in raw model position)
	  boundingBox: function( options ){
	    var eles = this;
	    var cy = eles._private.cy;
	    var cy_p = cy._private;
	    var styleEnabled = cy_p.styleEnabled;
	
	    options = options || util.staticEmptyObject();
	
	    var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
	    var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
	    var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;
	
	    // recalculate projections etc
	    if( styleEnabled ){
	      cy_p.renderer.recalculateRenderedStyle( this );
	    }
	
	    var x1 = Infinity;
	    var x2 = -Infinity;
	    var y1 = Infinity;
	    var y2 = -Infinity;
	
	    // find bounds of elements
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var _p = ele._private;
	      var style = _p.style;
	      var display = styleEnabled ? _p.style['display'].value : 'element';
	      var isNode = _p.group === 'nodes';
	      var ex1, ex2, ey1, ey2, x, y;
	      var includedEle = false;
	
	      if( display === 'none' ){ continue; } // then ele doesn't take up space
	
	      if( isNode && includeNodes ){
	        includedEle = true;
	
	        var pos = _p.position;
	        x = pos.x;
	        y = pos.y;
	        var w = ele.outerWidth();
	        var halfW = w/2;
	        var h = ele.outerHeight();
	        var halfH = h/2;
	
	        // handle node dimensions
	        /////////////////////////
	
	        ex1 = x - halfW;
	        ex2 = x + halfW;
	        ey1 = y - halfH;
	        ey2 = y + halfH;
	
	        x1 = ex1 < x1 ? ex1 : x1;
	        x2 = ex2 > x2 ? ex2 : x2;
	        y1 = ey1 < y1 ? ey1 : y1;
	        y2 = ey2 > y2 ? ey2 : y2;
	
	      } else if( ele.isEdge() && includeEdges ){
	        includedEle = true;
	
	        var n1 = _p.source;
	        var n1_p = n1._private;
	        var n1pos = n1_p.position;
	
	        var n2 = _p.target;
	        var n2_p = n2._private;
	        var n2pos = n2_p.position;
	
	
	        // handle edge dimensions (rough box estimate)
	        //////////////////////////////////////////////
	
	        var rstyle = _p.rstyle || {};
	        var w = 0;
	        var wHalf = 0;
	
	        if( styleEnabled ){
	          w = style['width'].pfValue;
	          wHalf = w/2;
	        }
	
	        ex1 = n1pos.x;
	        ex2 = n2pos.x;
	        ey1 = n1pos.y;
	        ey2 = n2pos.y;
	
	        if( ex1 > ex2 ){
	          var temp = ex1;
	          ex1 = ex2;
	          ex2 = temp;
	        }
	
	        if( ey1 > ey2 ){
	          var temp = ey1;
	          ey1 = ey2;
	          ey2 = temp;
	        }
	
	        // take into account edge width
	        ex1 -= wHalf;
	        ex2 += wHalf;
	        ey1 -= wHalf;
	        ey2 += wHalf;
	
	        x1 = ex1 < x1 ? ex1 : x1;
	        x2 = ex2 > x2 ? ex2 : x2;
	        y1 = ey1 < y1 ? ey1 : y1;
	        y2 = ey2 > y2 ? ey2 : y2;
	
	        // handle points along edge (sanity check)
	        //////////////////////////////////////////
	
	        if( styleEnabled ){
	          var pts = rstyle.bezierPts || rstyle.linePts || [];
	
	          for( var j = 0; j < pts.length; j++ ){
	            var pt = pts[j];
	
	            ex1 = pt.x - wHalf;
	            ex2 = pt.x + wHalf;
	            ey1 = pt.y - wHalf;
	            ey2 = pt.y + wHalf;
	
	            x1 = ex1 < x1 ? ex1 : x1;
	            x2 = ex2 > x2 ? ex2 : x2;
	            y1 = ey1 < y1 ? ey1 : y1;
	            y2 = ey2 > y2 ? ey2 : y2;
	          }
	        }
	
	        // precise haystacks (sanity check)
	        ///////////////////////////////////
	
	        if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
	          var hpts = rstyle.haystackPts;
	
	          ex1 = hpts[0].x;
	          ey1 = hpts[0].y;
	          ex2 = hpts[1].x;
	          ey2 = hpts[1].y;
	
	          if( ex1 > ex2 ){
	            var temp = ex1;
	            ex1 = ex2;
	            ex2 = temp;
	          }
	
	          if( ey1 > ey2 ){
	            var temp = ey1;
	            ey1 = ey2;
	            ey2 = temp;
	          }
	
	          x1 = ex1 < x1 ? ex1 : x1;
	          x2 = ex2 > x2 ? ex2 : x2;
	          y1 = ey1 < y1 ? ey1 : y1;
	          y2 = ey2 > y2 ? ey2 : y2;
	        }
	
	      } // edges
	
	
	      // handle label dimensions
	      //////////////////////////
	
	      if( styleEnabled ){
	
	        var _p = ele._private;
	        var style = _p.style;
	        var rstyle = _p.rstyle;
	        var label = style['label'].strValue;
	        var fontSize = style['font-size'];
	        var halign = style['text-halign'];
	        var valign = style['text-valign'];
	        var labelWidth = rstyle.labelWidth;
	        var labelHeight = rstyle.labelHeight;
	        var labelX = rstyle.labelX;
	        var labelY = rstyle.labelY;
	        var isEdge = ele.isEdge();
	        var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
	
	        if( includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
	          var lh = labelHeight;
	          var lw = labelWidth;
	          var lx1, lx2, ly1, ly2;
	
	          if( isEdge ){
	            lx1 = labelX - lw/2;
	            lx2 = labelX + lw/2;
	            ly1 = labelY - lh/2;
	            ly2 = labelY + lh/2;
	
	            if( autorotate ){
	              var theta = _p.rscratch.labelAngle;
	              var cos = Math.cos( theta );
	              var sin = Math.sin( theta );
	
	              var rotate = function( x, y ){
	                x = x - labelX;
	                y = y - labelY;
	
	                return {
	                  x: x*cos - y*sin + labelX,
	                  y: x*sin + y*cos + labelY
	                };
	              };
	
	              var px1y1 = rotate( lx1, ly1 );
	              var px1y2 = rotate( lx1, ly2 );
	              var px2y1 = rotate( lx2, ly1 );
	              var px2y2 = rotate( lx2, ly2 );
	
	              lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
	              lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
	              ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
	              ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
	            }
	          } else {
	            switch( halign.value ){
	              case 'left':
	                lx1 = labelX - lw;
	                lx2 = labelX;
	                break;
	
	              case 'center':
	                lx1 = labelX - lw/2;
	                lx2 = labelX + lw/2;
	                break;
	
	              case 'right':
	                lx1 = labelX;
	                lx2 = labelX + lw;
	                break;
	            }
	
	            switch( valign.value ){
	              case 'top':
	                ly1 = labelY - lh;
	                ly2 = labelY;
	                break;
	
	              case 'center':
	                ly1 = labelY - lh/2;
	                ly2 = labelY + lh/2;
	                break;
	
	              case 'bottom':
	                ly1 = labelY;
	                ly2 = labelY + lh;
	                break;
	            }
	          }
	
	          x1 = lx1 < x1 ? lx1 : x1;
	          x2 = lx2 > x2 ? lx2 : x2;
	          y1 = ly1 < y1 ? ly1 : y1;
	          y2 = ly2 > y2 ? ly2 : y2;
	        }
	      } // style enabled for labels
	    } // for
	
	    var noninf = function(x){
	      if( x === Infinity || x === -Infinity ){
	        return 0;
	      }
	
	      return x;
	    };
	
	    x1 = noninf(x1);
	    x2 = noninf(x2);
	    y1 = noninf(y1);
	    y2 = noninf(y2);
	
	    return {
	      x1: x1,
	      x2: x2,
	      y1: y1,
	      y2: y2,
	      w: x2 - x1,
	      h: y2 - y1
	    };
	  }
	});
	
	var defineDimFns = function( opts ){
	  opts.uppercaseName = util.capitalize( opts.name );
	  opts.autoName = 'auto' + opts.uppercaseName;
	  opts.labelName = 'label' + opts.uppercaseName;
	  opts.outerName = 'outer' + opts.uppercaseName;
	  opts.uppercaseOuterName = util.capitalize( opts.outerName );
	
	  fn[ opts.name ] = function dimImpl(){
	    var ele = this[0];
	    var _p = ele._private;
	    var cy = _p.cy;
	    var styleEnabled = cy._private.styleEnabled;
	
	    if( ele ){
	      if( styleEnabled ){
	        var d = _p.style[ opts.name ];
	
	        switch( d.strValue ){
	          case 'auto':
	            return _p[ opts.autoName ] || 0;
	          case 'label':
	            return _p.rstyle[ opts.labelName ] || 0;
	          default:
	            return d.pfValue;
	        }
	      } else {
	        return 1;
	      }
	    }
	  };
	
	  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
	    var ele = this[0];
	    var _p = ele._private;
	    var cy = _p.cy;
	    var styleEnabled = cy._private.styleEnabled;
	
	    if( ele ){
	      if( styleEnabled ){
	        var style = _p.style;
	        var dim = ele[ opts.name ]();
	        var border = style['border-width'].pfValue;
	        var padding = style[ opts.paddings[0] ].pfValue + style[ opts.paddings[1] ].pfValue;
	
	        return dim + border + padding;
	      } else {
	        return 1;
	      }
	    }
	  };
	
	  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
	    var ele = this[0];
	
	    if( ele ){
	      var d = ele[ opts.name ]();
	      return d * this.cy().zoom();
	    }
	  };
	
	  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
	    var ele = this[0];
	
	    if( ele ){
	      var od = ele[ opts.outerName ]();
	      return od * this.cy().zoom();
	    }
	  };
	};
	
	defineDimFns({
	  name: 'width',
	  paddings: ['padding-left', 'padding-right']
	});
	
	defineDimFns({
	  name: 'height',
	  paddings: ['padding-top', 'padding-bottom']
	});
	
	// aliases
	fn.modelPosition = fn.point = fn.position;
	fn.modelPositions = fn.points = fn.positions;
	fn.renderedPoint = fn.renderedPosition;
	fn.relativePoint = fn.relativePosition;
	fn.boundingbox = fn.boundingBox;
	fn.renderedBoundingbox = fn.renderedBoundingBox;
	
	module.exports = elesfn;
	
	},{"../define":41,"../is":77,"../util":94}],19:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	// represents a node or an edge
	var Element = function(cy, params, restore){
	  if( !(this instanceof Element) ){
	    return new Element(cy, params, restore);
	  }
	
	  var self = this;
	  restore = (restore === undefined || restore ? true : false);
	
	  if( cy === undefined || params === undefined || !is.core(cy) ){
	    util.error('An element must have a core reference and parameters set');
	    return;
	  }
	
	  var group = params.group;
	
	  // try to automatically infer the group if unspecified
	  if( group == null ){
	    if( params.data.source != null && params.data.target != null ){
	      group = 'edges';
	    } else {
	      group = 'nodes';
	    }
	  }
	
	  // validate group
	  if( group !== 'nodes' && group !== 'edges' ){
	    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
	    return;
	  }
	
	  // make the element array-like, just like a collection
	  this.length = 1;
	  this[0] = this;
	
	  // NOTE: when something is added here, add also to ele.json()
	  this._private = {
	    cy: cy,
	    single: true, // indicates this is an element
	    data: params.data || {}, // data object
	    position: params.position || {}, // (x, y) position pair
	    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
	    autoHeight: undefined,
	    listeners: [], // array of bound listeners
	    group: group, // string; 'nodes' or 'edges'
	    style: {}, // properties as set by the style
	    rstyle: {}, // properties for style sent from the renderer to the core
	    styleCxts: [], // applied style contexts from the styler
	    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
	    selected: params.selected ? true : false, // whether it's selected
	    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
	    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
	    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
	    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
	    active: false, // whether the element is active from user interaction
	    classes: {}, // map ( className => true )
	    animation: { // object for currently-running animations
	      current: [],
	      queue: []
	    },
	    rscratch: {}, // object in which the renderer can store information
	    scratch: params.scratch || {}, // scratch objects
	    edges: [], // array of connected edges
	    children: [] // array of children
	  };
	
	  // renderedPosition overrides if specified
	  if( params.renderedPosition ){
	    var rpos = params.renderedPosition;
	    var pan = cy.pan();
	    var zoom = cy.zoom();
	
	    this._private.position = {
	      x: (rpos.x - pan.x)/zoom,
	      y: (rpos.y - pan.y)/zoom
	    };
	  }
	
	  if( is.string(params.classes) ){
	    var classes = params.classes.split(/\s+/);
	    for( var i = 0, l = classes.length; i < l; i++ ){
	      var cls = classes[i];
	      if( !cls || cls === '' ){ continue; }
	
	      self._private.classes[cls] = true;
	    }
	  }
	
	  if( params.style || params.css ){
	    cy.style().applyBypass( this, params.style || params.css );
	  }
	
	  if( restore === undefined || restore ){
	    this.restore();
	  }
	
	};
	
	module.exports = Element;
	
	},{"../is":77,"../util":94}],20:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	
	var elesfn = ({
	  on: define.on(), // .on( events [, selector] [, data], handler)
	  one: define.on({ unbindSelfOnTrigger: true }),
	  once: define.on({ unbindAllBindersOnTrigger: true }),
	  off: define.off(), // .off( events [, selector] [, handler] )
	  trigger: define.trigger(), // .trigger( events [, extraParams] )
	
	  rtrigger: function(event, extraParams){ // for internal use only
	    if( this.length === 0 ){ return; } // empty collections don't need to notify anything
	
	    // notify renderer
	    this.cy().notify({
	      type: event,
	      collection: this
	    });
	
	    this.trigger(event, extraParams);
	    return this;
	  }
	});
	
	// aliases:
	define.eventAliasesOn( elesfn );
	
	module.exports = elesfn;
	
	},{"../define":41}],21:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var Selector = _dereq_('../selector');
	
	var elesfn = ({
	  nodes: function( selector ){
	    return this.filter(function(i, element){
	      return element.isNode();
	    }).filter(selector);
	  },
	
	  edges: function( selector ){
	    return this.filter(function(i, element){
	      return element.isEdge();
	    }).filter(selector);
	  },
	
	  filter: function( filter ){
	    if( is.fn(filter) ){
	      var elements = [];
	
	      for( var i = 0; i < this.length; i++ ){
	        var ele = this[i];
	
	        if( filter.apply(ele, [i, ele]) ){
	          elements.push(ele);
	        }
	      }
	
	      return this.spawn(elements);
	
	    } else if( is.string(filter) || is.elementOrCollection(filter) ){
	      return Selector(filter).filter(this);
	
	    } else if( filter === undefined ){
	      return this;
	    }
	
	    return this.spawn(); // if not handled by above, give 'em an empty collection
	  },
	
	  not: function( toRemove ){
	    if( !toRemove ){
	      return this;
	    } else {
	
	      if( is.string( toRemove ) ){
	        toRemove = this.filter( toRemove );
	      }
	
	      var elements = [];
	
	      for( var i = 0; i < this.length; i++ ){
	        var element = this[i];
	
	        var remove = toRemove._private.ids[ element.id() ];
	        if( !remove ){
	          elements.push( element );
	        }
	      }
	
	      return this.spawn( elements );
	    }
	
	  },
	
	  absoluteComplement: function(){
	    var cy = this._private.cy;
	
	    return cy.elements().not( this );
	  },
	
	  intersect: function( other ){
	    // if a selector is specified, then filter by it instead
	    if( is.string(other) ){
	      var selector = other;
	      return this.filter( selector );
	    }
	
	    var elements = [];
	    var col1 = this;
	    var col2 = other;
	    var col1Smaller = this.length < other.length;
	    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
	    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
	    var col = col1Smaller ? col1 : col2;
	
	    for( var i = 0; i < col.length; i++ ){
	      var id = col[i]._private.data.id;
	      var ele = ids2[ id ];
	
	      if( ele ){
	        elements.push( ele );
	      }
	    }
	
	    return this.spawn( elements );
	  },
	
	  xor: function( other ){
	    var cy = this._private.cy;
	
	    if( is.string(other) ){
	      other = cy.$( other );
	    }
	
	    var elements = [];
	    var col1 = this;
	    var col2 = other;
	
	    var add = function( col, other ){
	
	      for( var i = 0; i < col.length; i++ ){
	        var ele = col[i];
	        var id = ele._private.data.id;
	        var inOther = other._private.ids[ id ];
	
	        if( !inOther ){
	          elements.push( ele );
	        }
	      }
	
	    };
	
	    add( col1, col2 );
	    add( col2, col1 );
	
	    return this.spawn( elements );
	  },
	
	  diff: function( other ){
	    var cy = this._private.cy;
	
	    if( is.string(other) ){
	      other = cy.$( other );
	    }
	
	    var left = [];
	    var right = [];
	    var both = [];
	    var col1 = this;
	    var col2 = other;
	
	    var add = function( col, other, retEles ){
	
	      for( var i = 0; i < col.length; i++ ){
	        var ele = col[i];
	        var id = ele._private.data.id;
	        var inOther = other._private.ids[ id ];
	
	        if( inOther ){
	          both.push( ele );
	        } else {
	          retEles.push( ele );
	        }
	      }
	
	    };
	
	    add( col1, col2, left );
	    add( col2, col1, right );
	
	    return {
	      left: this.spawn( left, { unique: true } ),
	      right: this.spawn( right, { unique: true } ),
	      both: this.spawn( both, { unique: true } )
	    };
	  },
	
	  add: function( toAdd ){
	    var cy = this._private.cy;
	
	    if( !toAdd ){
	      return this;
	    }
	
	    if( is.string(toAdd) ){
	      var selector = toAdd;
	      toAdd = cy.elements(selector);
	    }
	
	    var elements = [];
	
	    for( var i = 0; i < this.length; i++ ){
	      elements.push( this[i] );
	    }
	
	    for( var i = 0; i < toAdd.length; i++ ){
	
	      var add = !this._private.ids[ toAdd[i].id() ];
	      if( add ){
	        elements.push( toAdd[i] );
	      }
	    }
	
	    return this.spawn(elements);
	  },
	
	  // in place merge on calling collection
	  merge: function( toAdd ){
	    var _p = this._private;
	    var cy = _p.cy;
	
	    if( !toAdd ){
	      return this;
	    }
	
	    if( is.string(toAdd) ){
	      var selector = toAdd;
	      toAdd = cy.elements(selector);
	    }
	
	    for( var i = 0; i < toAdd.length; i++ ){
	      var toAddEle = toAdd[i];
	      var id = toAddEle.id();
	      var add = !_p.ids[ id ];
	
	      if( add ){
	        var index = this.length++;
	
	        this[ index ] = toAddEle;
	        _p.ids[ id ] = toAddEle;
	        _p.indexes[ id ] = index;
	      }
	    }
	
	    return this; // chaining
	  },
	
	  // remove single ele in place in calling collection
	  unmergeOne: function( ele ){
	    ele = ele[0];
	
	    var _p = this._private;
	    var id = ele.id();
	    var i = _p.indexes[ id ];
	
	    if( i == null ){
	      return this; // no need to remove
	    }
	
	    // remove ele
	    this[i] = undefined;
	    _p.ids[ id ] = undefined;
	    _p.indexes[ id ] = undefined;
	
	    var unmergedLastEle = i === this.length - 1;
	
	    // replace empty spot with last ele in collection
	    if( this.length > 1 && !unmergedLastEle ){
	      var lastEleI = this.length - 1;
	      var lastEle = this[ lastEleI ];
	
	      this[ lastEleI ] = undefined;
	      this[i] = lastEle;
	      _p.indexes[ lastEle.id() ] = i;
	    }
	
	    // the collection is now 1 ele smaller
	    this.length--;
	
	    return this;
	  },
	
	  // remove eles in place on calling collection
	  unmerge: function( toRemove ){
	    var cy = this._private.cy;
	
	    if( !toRemove ){
	      return this;
	    }
	
	    if( is.string(toRemove) ){
	      var selector = toRemove;
	      toRemove = cy.elements(selector);
	    }
	
	    for( var i = 0; i < toRemove.length; i++ ){
	      this.unmergeOne( toRemove[i] );
	    }
	
	    return this; // chaining
	  },
	
	  map: function( mapFn, thisArg ){
	    var arr = [];
	    var eles = this;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );
	
	      arr.push( ret );
	    }
	
	    return arr;
	  },
	
	  stdFilter: function( fn, thisArg ){
	    var filterEles = [];
	    var eles = this;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );
	
	      if( include ){
	        filterEles.push( ele );
	      }
	    }
	
	    return this.spawn( filterEles );
	  },
	
	  max: function( valFn, thisArg ){
	    var max = -Infinity;
	    var maxEle;
	    var eles = this;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );
	
	      if( val > max ){
	        max = val;
	        maxEle = ele;
	      }
	    }
	
	    return {
	      value: max,
	      ele: maxEle
	    };
	  },
	
	  min: function( valFn, thisArg ){
	    var min = Infinity;
	    var minEle;
	    var eles = this;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );
	
	      if( val < min ){
	        min = val;
	        minEle = ele;
	      }
	    }
	
	    return {
	      value: min,
	      ele: minEle
	    };
	  }
	});
	
	// aliases
	var fn = elesfn;
	fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
	fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
	fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
	fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
	fn.fnFilter = fn.filterFn = fn.stdFilter;
	fn.complement = fn.abscomp = fn.absoluteComplement;
	
	module.exports = elesfn;
	
	},{"../is":77,"../selector":81}],22:[function(_dereq_,module,exports){
	'use strict';
	
	var elesfn = ({
	  isNode: function(){
	    return this.group() === 'nodes';
	  },
	
	  isEdge: function(){
	    return this.group() === 'edges';
	  },
	
	  isLoop: function(){
	    return this.isEdge() && this.source().id() === this.target().id();
	  },
	
	  isSimple: function(){
	    return this.isEdge() && this.source().id() !== this.target().id();
	  },
	
	  group: function(){
	    var ele = this[0];
	
	    if( ele ){
	      return ele._private.group;
	    }
	  }
	});
	
	
	module.exports = elesfn;
	
	},{}],23:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var Element = _dereq_('./element');
	
	// factory for generating edge ids when no id is specified for a new element
	var idFactory = {
	  prefix: 'ele',
	  id: 0,
	  generate: function(cy, element, tryThisId){
	    var json = is.element( element ) ? element._private : element;
	    var id = tryThisId != null ? tryThisId : this.prefix + this.id;
	
	    if( cy.getElementById(id).empty() ){
	      this.id++; // we've used the current id, so move it up
	    } else { // otherwise keep trying successive unused ids
	      while( !cy.getElementById(id).empty() ){
	        id = this.prefix + ( ++this.id );
	      }
	    }
	
	    return id;
	  }
	};
	
	// represents a set of nodes, edges, or both together
	var Collection = function(cy, elements, options){
	  if( !(this instanceof Collection) ){
	    return new Collection(cy, elements, options);
	  }
	
	  if( cy === undefined || !is.core(cy) ){
	    util.error('A collection must have a reference to the core');
	    return;
	  }
	
	  var ids = {};
	  var indexes = {};
	  var createdElements = false;
	
	  if( !elements ){
	    elements = [];
	  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
	    createdElements = true;
	
	    // make elements from json and restore all at once later
	    var eles = [];
	    var elesIds = {};
	
	    for( var i = 0, l = elements.length; i < l; i++ ){
	      var json = elements[i];
	
	      if( json.data == null ){
	        json.data = {};
	      }
	
	      var data = json.data;
	
	      // make sure newly created elements have valid ids
	      if( data.id == null ){
	        data.id = idFactory.generate( cy, json );
	      } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
	        continue; // can't create element if prior id already exists
	      }
	
	      var ele = new Element( cy, json, false );
	      eles.push( ele );
	      elesIds[ data.id ] = true;
	    }
	
	    elements = eles;
	  }
	
	  this.length = 0;
	
	  for( var i = 0, l = elements.length; i < l; i++ ){
	    var element = elements[i];
	    if( !element ){  continue; }
	
	    var id = element._private.data.id;
	
	    if( !options || (options.unique && !ids[ id ] ) ){
	      ids[ id ] = element;
	      indexes[ id ] = this.length;
	
	      this[ this.length ] = element;
	      this.length++;
	    }
	  }
	
	  this._private = {
	    cy: cy,
	    ids: ids,
	    indexes: indexes
	  };
	
	  // restore the elements if we created them from json
	  if( createdElements ){
	    this.restore();
	  }
	};
	
	// Functions
	////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// keep the prototypes in sync (an element has the same functions as a collection)
	// and use elefn and elesfn as shorthands to the prototypes
	var elesfn = Element.prototype = Collection.prototype;
	
	elesfn.instanceString = function(){
	  return 'collection';
	};
	
	elesfn.spawn = function( cy, eles, opts ){
	  if( !is.core(cy) ){ // cy is optional
	    opts = eles;
	    eles = cy;
	    cy = this.cy();
	  }
	
	  return new Collection( cy, eles, opts );
	};
	
	elesfn.cy = function(){
	  return this._private.cy;
	};
	
	elesfn.element = function(){
	  return this[0];
	};
	
	elesfn.collection = function(){
	  if( is.collection(this) ){
	    return this;
	  } else { // an element
	    return new Collection( this._private.cy, [this] );
	  }
	};
	
	elesfn.unique = function(){
	  return new Collection( this._private.cy, this, { unique: true } );
	};
	
	elesfn.getElementById = function( id ){
	  var cy = this._private.cy;
	  var ele = this._private.ids[ id ];
	
	  return ele ? ele : new Collection(cy); // get ele or empty collection
	};
	
	elesfn.json = function( obj ){
	  var ele = this.element();
	  var cy = this.cy();
	
	  if( ele == null && obj ){ return this; } // can't set to no eles
	
	  if( ele == null ){ return undefined; } // can't get from no eles
	
	  var p = ele._private;
	
	  if( is.plainObject(obj) ){ // set
	
	    cy.startBatch();
	
	    if( obj.data ){
	      ele.data( obj.data );
	    }
	
	    if( obj.position ){
	      ele.position( obj.position );
	    }
	
	    // ignore group -- immutable
	
	    var checkSwitch = function( k, trueFnName, falseFnName ){
	      var obj_k = obj[k];
	
	      if( obj_k != null && obj_k !== p[k] ){
	        if( obj_k ){
	          ele[ trueFnName ]();
	        } else {
	          ele[ falseFnName ]();
	        }
	      }
	    };
	
	    checkSwitch( 'removed', 'remove', 'restore' );
	
	    checkSwitch( 'selected', 'select', 'unselect' );
	
	    checkSwitch( 'selectable', 'selectify', 'unselectify' );
	
	    checkSwitch( 'locked', 'lock', 'unlock' );
	
	    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );
	
	    if( obj.classes != null ){
	      ele.classes( obj.classes );
	    }
	
	    cy.endBatch();
	
	    return this;
	
	  } else if( obj === undefined ){ // get
	
	    var json = {
	      data: util.copy( p.data ),
	      position: util.copy( p.position ),
	      group: p.group,
	      removed: p.removed,
	      selected: p.selected,
	      selectable: p.selectable,
	      locked: p.locked,
	      grabbable: p.grabbable,
	      classes: null
	    };
	
	    var classes = [];
	    for( var cls in p.classes ){
	      if( p.classes[cls] ){
	        classes.push(cls);
	      }
	    }
	    json.classes = classes.join(' ');
	
	    return json;
	  }
	};
	
	elesfn.jsons = function(){
	  var jsons = [];
	
	  for( var i = 0; i < this.length; i++ ){
	    var ele = this[i];
	    var json = ele.json();
	
	    jsons.push( json );
	  }
	
	  return jsons;
	};
	
	elesfn.clone = function(){
	  var cy = this.cy();
	  var elesArr = [];
	
	  for( var i = 0; i < this.length; i++ ){
	    var ele = this[i];
	    var json = ele.json();
	    var clone = new Element(cy, json, false); // NB no restore
	
	    elesArr.push( clone );
	  }
	
	  return new Collection( cy, elesArr );
	};
	elesfn.copy = elesfn.clone;
	
	elesfn.restore = function( notifyRenderer ){
	  var self = this;
	  var restored = [];
	  var cy = self.cy();
	
	  if( notifyRenderer === undefined ){
	    notifyRenderer = true;
	  }
	
	  // create arrays of nodes and edges, since we need to
	  // restore the nodes first
	  var elements = [];
	  var nodes = [], edges = [];
	  var numNodes = 0;
	  var numEdges = 0;
	  for( var i = 0, l = self.length; i < l; i++ ){
	    var ele = self[i];
	
	    // keep nodes first in the array and edges after
	    if( ele.isNode() ){ // put to front of array if node
	      nodes.push( ele );
	      numNodes++;
	    } else { // put to end of array if edge
	      edges.push( ele );
	      numEdges++;
	    }
	  }
	
	  elements = nodes.concat( edges );
	
	  // now, restore each element
	  for( var i = 0, l = elements.length; i < l; i++ ){
	    var ele = elements[i];
	
	    if( !ele.removed() ){
	      // don't need to do anything
	      continue;
	    }
	
	    var _private = ele._private;
	    var data = _private.data;
	
	    // set id and validate
	    if( data.id === undefined ){
	      data.id = idFactory.generate( cy, ele );
	
	    } else if( is.number(data.id) ){
	      data.id = '' + data.id; // now it's a string
	
	    } else if( is.emptyString(data.id) || !is.string(data.id) ){
	      util.error('Can not create element with invalid string ID `' + data.id + '`');
	
	      // can't create element if it has empty string as id or non-string id
	      continue;
	    } else if( cy.getElementById( data.id ).length !== 0 ){
	      util.error('Can not create second element with ID `' + data.id + '`');
	
	      // can't create element if one already has that id
	      continue;
	    }
	
	    var id = data.id; // id is finalised, now let's keep a ref
	
	    if( ele.isNode() ){ // extra checks for nodes
	      var node = ele;
	      var pos = _private.position;
	
	      // make sure the nodes have a defined position
	
	      if( pos.x == null ){
	        pos.x = 0;
	      }
	
	      if( pos.y == null ){
	        pos.y = 0;
	      }
	    }
	
	    if( ele.isEdge() ){ // extra checks for edges
	
	      var edge = ele;
	      var fields = ['source', 'target'];
	      var fieldsLength = fields.length;
	      var badSourceOrTarget = false;
	      for(var j = 0; j < fieldsLength; j++){
	
	        var field = fields[j];
	        var val = data[field];
	
	        if( is.number(val) ){
	          val = data[field] = '' + data[field]; // now string
	        }
	
	        if( val == null || val === '' ){
	          // can't create if source or target is not defined properly
	          util.error('Can not create edge `' + id + '` with unspecified ' + field);
	          badSourceOrTarget = true;
	        } else if( cy.getElementById(val).empty() ){
	          // can't create edge if one of its nodes doesn't exist
	          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
	          badSourceOrTarget = true;
	        }
	      }
	
	      if( badSourceOrTarget ){ continue; } // can't create this
	
	      var src = cy.getElementById( data.source );
	      var tgt = cy.getElementById( data.target );
	
	      src._private.edges.push( edge );
	      tgt._private.edges.push( edge );
	
	      edge._private.source = src;
	      edge._private.target = tgt;
	
	    } // if is edge
	
	    // create mock ids map for element so it can be used like collections
	    _private.ids = {};
	    _private.ids[ id ] = ele;
	
	    _private.removed = false;
	    cy.addToPool( ele );
	
	    restored.push( ele );
	  } // for each element
	
	  // do compound node sanity checks
	  for( var i = 0; i < numNodes; i++ ){ // each node
	    var node = elements[i];
	    var data = node._private.data;
	
	    if( is.number(data.parent) ){ // then automake string
	      data.parent = '' + data.parent;
	    }
	
	    var parentId = data.parent;
	
	    var specifiedParent = parentId != null;
	
	    if( specifiedParent ){
	      var parent = cy.getElementById( parentId );
	
	      if( parent.empty() ){
	        // non-existant parent; just remove it
	        data.parent = undefined;
	      } else {
	        var selfAsParent = false;
	        var ancestor = parent;
	        while( !ancestor.empty() ){
	          if( node.same(ancestor) ){
	            // mark self as parent and remove from data
	            selfAsParent = true;
	            data.parent = undefined; // remove parent reference
	
	            // exit or we loop forever
	            break;
	          }
	
	          ancestor = ancestor.parent();
	        }
	
	        if( !selfAsParent ){
	          // connect with children
	          parent[0]._private.children.push( node );
	          node._private.parent = parent[0];
	
	          // let the core know we have a compound graph
	          cy._private.hasCompoundNodes = true;
	        }
	      } // else
	    } // if specified parent
	  } // for each node
	
	  restored = new Collection( cy, restored );
	  if( restored.length > 0 ){
	
	    var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
	    toUpdateStyle.updateStyle( notifyRenderer );
	
	    if( notifyRenderer ){
	      restored.rtrigger('add');
	    } else {
	      restored.trigger('add');
	    }
	  }
	
	  return self; // chainability
	};
	
	elesfn.removed = function(){
	  var ele = this[0];
	  return ele && ele._private.removed;
	};
	
	elesfn.inside = function(){
	  var ele = this[0];
	  return ele && !ele._private.removed;
	};
	
	elesfn.remove = function( notifyRenderer ){
	  var self = this;
	  var removed = [];
	  var elesToRemove = [];
	  var elesToRemoveIds = {};
	  var cy = self._private.cy;
	
	  if( notifyRenderer === undefined ){
	    notifyRenderer = true;
	  }
	
	  // add connected edges
	  function addConnectedEdges(node){
	    var edges = node._private.edges;
	    for( var i = 0; i < edges.length; i++ ){
	      add( edges[i] );
	    }
	  }
	
	
	  // add descendant nodes
	  function addChildren(node){
	    var children = node._private.children;
	
	    for( var i = 0; i < children.length; i++ ){
	      add( children[i] );
	    }
	  }
	
	  function add( ele ){
	    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
	    if( alreadyAdded ){
	      return;
	    } else {
	      elesToRemoveIds[ ele.id() ] = true;
	    }
	
	    if( ele.isNode() ){
	      elesToRemove.push( ele ); // nodes are removed last
	
	      addConnectedEdges( ele );
	      addChildren( ele );
	    } else {
	      elesToRemove.unshift( ele ); // edges are removed first
	    }
	  }
	
	  // make the list of elements to remove
	  // (may be removing more than specified due to connected edges etc)
	
	  for( var i = 0, l = self.length; i < l; i++ ){
	    var ele = self[i];
	
	    add( ele );
	  }
	
	  function removeEdgeRef(node, edge){
	    var connectedEdges = node._private.edges;
	    for( var j = 0; j < connectedEdges.length; j++ ){
	      var connectedEdge = connectedEdges[j];
	
	      if( edge === connectedEdge ){
	        connectedEdges.splice( j, 1 );
	        break;
	      }
	    }
	  }
	
	  function removeChildRef(parent, ele){
	    ele = ele[0];
	    parent = parent[0];
	    var children = parent._private.children;
	
	    for( var j = 0; j < children.length; j++ ){
	      if( children[j][0] === ele[0] ){
	        children.splice(j, 1);
	        break;
	      }
	    }
	  }
	
	  for( var i = 0; i < elesToRemove.length; i++ ){
	    var ele = elesToRemove[i];
	
	    // mark as removed
	    ele._private.removed = true;
	
	    // remove from core pool
	    cy.removeFromPool( ele );
	
	    // add to list of removed elements
	    removed.push( ele );
	
	    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
	      var src = ele.source()[0];
	      var tgt = ele.target()[0];
	
	      removeEdgeRef( src, ele );
	      removeEdgeRef( tgt, ele );
	
	    } else { // remove reference to parent
	      var parent = ele.parent();
	
	      if( parent.length !== 0 ){
	        removeChildRef(parent, ele);
	      }
	    }
	  }
	
	  // check to see if we have a compound graph or not
	  var elesStillInside = cy._private.elements;
	  cy._private.hasCompoundNodes = false;
	  for( var i = 0; i < elesStillInside.length; i++ ){
	    var ele = elesStillInside[i];
	
	    if( ele.isParent() ){
	      cy._private.hasCompoundNodes = true;
	      break;
	    }
	  }
	
	  var removedElements = new Collection( this.cy(), removed );
	  if( removedElements.size() > 0 ){
	    // must manually notify since trigger won't do this automatically once removed
	
	    if( notifyRenderer ){
	      this.cy().notify({
	        type: 'remove',
	        collection: removedElements
	      });
	    }
	
	    removedElements.trigger('remove');
	  }
	
	  // check for empty remaining parent nodes
	  var checkedParentId = {};
	  for( var i = 0; i < elesToRemove.length; i++ ){
	    var ele = elesToRemove[i];
	    var isNode = ele._private.group === 'nodes';
	    var parentId = ele._private.data.parent;
	
	    if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
	      checkedParentId[ parentId ] = true;
	      var parent = cy.getElementById( parentId );
	
	      if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
	        parent.updateStyle();
	      }
	    }
	  }
	
	  return new Collection( cy, removed );
	};
	
	elesfn.move = function( struct ){
	  var cy = this._private.cy;
	
	  if( struct.source !== undefined || struct.target !== undefined ){
	    var srcId = struct.source;
	    var tgtId = struct.target;
	    var srcExists = cy.getElementById( srcId ).length > 0;
	    var tgtExists = cy.getElementById( tgtId ).length > 0;
	
	    if( srcExists || tgtExists ){
	      var jsons = this.jsons();
	
	      this.remove();
	
	      for( var i = 0; i < jsons.length; i++ ){
	        var json = jsons[i];
	
	        if( json.group === 'edges' ){
	          if( srcExists ){ json.data.source = srcId; }
	          if( tgtExists ){ json.data.target = tgtId; }
	        }
	      }
	
	      return cy.add( jsons );
	    }
	
	  } else if( struct.parent !== undefined ){ // move node to new parent
	    var parentId = struct.parent;
	    var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
	
	    if( parentExists ){
	      var jsons = this.jsons();
	      var descs = this.descendants();
	      var descsEtc = descs.merge( descs.add(this).connectedEdges() );
	
	      this.remove(); // NB: also removes descendants and their connected edges
	
	      for( var i = 0; i < this.length; i++ ){
	        var json = jsons[i];
	
	        if( json.group === 'nodes' ){
	          json.data.parent = parentId === null ? undefined : parentId;
	        }
	      }
	    }
	
	    return cy.add( jsons ).merge( descsEtc.restore() );
	  }
	
	  return this; // if nothing done
	};
	
	[
	  _dereq_('./algorithms'),
	  _dereq_('./animation'),
	  _dereq_('./class'),
	  _dereq_('./comparators'),
	  _dereq_('./compounds'),
	  _dereq_('./data'),
	  _dereq_('./degree'),
	  _dereq_('./dimensions'),
	  _dereq_('./events'),
	  _dereq_('./filter'),
	  _dereq_('./group'),
	  _dereq_('./index'),
	  _dereq_('./iteration'),
	  _dereq_('./layout'),
	  _dereq_('./style'),
	  _dereq_('./switch-functions'),
	  _dereq_('./traversing')
	].forEach(function( props ){
	  util.extend( elesfn, props );
	});
	
	module.exports = Collection;
	
	},{"../is":77,"../util":94,"./algorithms":9,"./animation":12,"./class":13,"./comparators":14,"./compounds":15,"./data":16,"./degree":17,"./dimensions":18,"./element":19,"./events":20,"./filter":21,"./group":22,"./index":23,"./iteration":24,"./layout":25,"./style":26,"./switch-functions":27,"./traversing":28}],24:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var zIndexSort = _dereq_('./zsort');
	
	var elesfn = ({
	  each: function(fn){
	    if( is.fn(fn) ){
	      for(var i = 0; i < this.length; i++){
	        var ele = this[i];
	        var ret = fn.apply( ele, [ i, ele ] );
	
	        if( ret === false ){ break; } // exit each early on return false
	      }
	    }
	    return this;
	  },
	
	  forEach: function(fn, thisArg){
	    if( is.fn(fn) ){
	
	      for(var i = 0; i < this.length; i++){
	        var ele = this[i];
	        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );
	
	        if( ret === false ){ break; } // exit each early on return false
	      }
	    }
	
	    return this;
	  },
	
	  toArray: function(){
	    var array = [];
	
	    for(var i = 0; i < this.length; i++){
	      array.push( this[i] );
	    }
	
	    return array;
	  },
	
	  slice: function(start, end){
	    var array = [];
	    var thisSize = this.length;
	
	    if( end == null ){
	      end = thisSize;
	    }
	
	    if( start == null ){
	      start = 0;
	    }
	
	    if( start < 0 ){
	      start = thisSize + start;
	    }
	
	    if( end < 0 ){
	      end = thisSize + end;
	    }
	
	    for(var i = start; i >= 0 && i < end && i < thisSize; i++){
	      array.push( this[i] );
	    }
	
	    return this.spawn(array);
	  },
	
	  size: function(){
	    return this.length;
	  },
	
	  eq: function(i){
	    return this[i] || this.spawn();
	  },
	
	  first: function(){
	    return this[0] || this.spawn();
	  },
	
	  last: function(){
	    return this[ this.length - 1 ] || this.spawn();
	  },
	
	  empty: function(){
	    return this.length === 0;
	  },
	
	  nonempty: function(){
	    return !this.empty();
	  },
	
	  sort: function( sortFn ){
	    if( !is.fn( sortFn ) ){
	      return this;
	    }
	
	    var sorted = this.toArray().sort( sortFn );
	
	    return this.spawn(sorted);
	  },
	
	  sortByZIndex: function(){
	    return this.sort( zIndexSort );
	  },
	
	  zDepth: function(){
	    var ele = this[0];
	    if( !ele ){ return undefined; }
	
	    // var cy = ele.cy();
	    var _p = ele._private;
	    var group = _p.group;
	
	    if( group === 'nodes' ){
	      var depth = _p.data.parent ? ele.parents().size() : 0;
	
	      if( !ele.isParent() ){
	        return Number.MAX_VALUE; // childless nodes always on top
	      }
	
	      return depth;
	    } else {
	      var src = _p.source;
	      var tgt = _p.target;
	      var srcDepth = src.zDepth();
	      var tgtDepth = tgt.zDepth();
	
	      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
	    }
	  }
	});
	
	module.exports = elesfn;
	
	},{"../is":77,"./zsort":29}],25:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var util = _dereq_('../util');
	
	var elesfn = ({
	
	  // using standard layout options, apply position function (w/ or w/o animation)
	  layoutPositions: function( layout, options, fn ){
	    var nodes = this.nodes();
	    var cy = this.cy();
	
	    layout.trigger({ type: 'layoutstart', layout: layout });
	
	    layout.animations = [];
	
	    if( options.animate ){
	      for( var i = 0; i < nodes.length; i++ ){
	        var node = nodes[i];
	        var lastNode = i === nodes.length - 1;
	
	        var newPos = fn.call( node, i, node );
	        var pos = node.position();
	
	        if( !is.number(pos.x) || !is.number(pos.y) ){
	          node.silentPosition({ x: 0, y: 0 });
	        }
	
	        var ani = node.animation({
	          position: newPos,
	          duration: options.animationDuration,
	          easing: options.animationEasing,
	          step: !lastNode ? undefined : function(){
	            if( options.fit ){
	              cy.fit( options.eles, options.padding );
	            }
	          },
	          complete: !lastNode ? undefined : function(){
	            if( options.zoom != null ){
	              cy.zoom( options.zoom );
	            }
	
	            if( options.pan ){
	              cy.pan( options.pan );
	            }
	
	            if( options.fit ){
	              cy.fit( options.eles, options.padding );
	            }
	
	            layout.one('layoutstop', options.stop);
	            layout.trigger({ type: 'layoutstop', layout: layout });
	          }
	        });
	
	        layout.animations.push( ani );
	
	        ani.play();
	      }
	
	      layout.one('layoutready', options.ready);
	      layout.trigger({ type: 'layoutready', layout: layout });
	    } else {
	      nodes.positions( fn );
	
	      if( options.fit ){
	        cy.fit( options.eles, options.padding );
	      }
	
	      if( options.zoom != null ){
	        cy.zoom( options.zoom );
	      }
	
	      if( options.pan ){
	        cy.pan( options.pan );
	      }
	
	      layout.one('layoutready', options.ready);
	      layout.trigger({ type: 'layoutready', layout: layout });
	
	      layout.one('layoutstop', options.stop);
	      layout.trigger({ type: 'layoutstop', layout: layout });
	    }
	
	    return this; // chaining
	  },
	
	  layout: function( options ){
	    var cy = this.cy();
	
	    cy.layout( util.extend({}, options, {
	      eles: this
	    }) );
	
	    return this;
	  },
	
	  makeLayout: function( options ){
	    var cy = this.cy();
	
	    return cy.makeLayout( util.extend({}, options, {
	      eles: this
	    }) );
	  }
	
	});
	
	// aliases:
	elesfn.createLayout = elesfn.makeLayout;
	
	module.exports = elesfn;
	
	},{"../is":77,"../util":94}],26:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	
	var elesfn = ({
	
	  // fully updates (recalculates) the style for the elements
	  updateStyle: function( notifyRenderer ){
	    var cy = this._private.cy;
	
	    if( !cy.styleEnabled() ){ return this; }
	
	    if( cy._private.batchingStyle ){
	      var bEles = cy._private.batchStyleEles;
	
	      bEles.merge( this );
	
	      return this; // chaining and exit early when batching
	    }
	
	    var style = cy.style();
	    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;
	
	    style.apply( this );
	
	    var updatedCompounds = this.updateCompoundBounds();
	    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
	
	    if( notifyRenderer ){
	      toNotify.rtrigger('style'); // let renderer know we changed style
	    } else {
	      toNotify.trigger('style'); // just fire the event
	    }
	    return this; // chaining
	  },
	
	  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
	  updateMappers: function( notifyRenderer ){
	    var cy = this._private.cy;
	    var style = cy.style();
	    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;
	
	    if( !cy.styleEnabled() ){ return this; }
	
	    style.updateMappers( this );
	
	    var updatedCompounds = this.updateCompoundBounds();
	    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
	
	    if( notifyRenderer ){
	      toNotify.rtrigger('style'); // let renderer know we changed style
	    } else {
	      toNotify.trigger('style'); // just fire the event
	    }
	    return this; // chaining
	  },
	
	  // get the specified css property as a rendered value (i.e. on-screen value)
	  // or get the whole rendered style if no property specified (NB doesn't allow setting)
	  renderedCss: function( property ){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return this; }
	
	    var ele = this[0];
	
	    if( ele ){
	      var renstyle = ele.cy().style().getRenderedStyle( ele );
	
	      if( property === undefined ){
	        return renstyle;
	      } else {
	        return renstyle[ property ];
	      }
	    }
	  },
	
	  // read the calculated css style of the element or override the style (via a bypass)
	  css: function( name, value ){
	    var cy = this.cy();
	
	    if( !cy.styleEnabled() ){ return this; }
	
	    var updateTransitions = false;
	    var style = cy.style();
	
	    if( is.plainObject(name) ){ // then extend the bypass
	      var props = name;
	      style.applyBypass( this, props, updateTransitions );
	
	      var updatedCompounds = this.updateCompoundBounds();
	      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
	      toNotify.rtrigger('style'); // let the renderer know we've updated style
	
	    } else if( is.string(name) ){
	
	      if( value === undefined ){ // then get the property from the style
	        var ele = this[0];
	
	        if( ele ){
	          return style.getStylePropertyValue( ele, name );
	        } else { // empty collection => can't get any value
	          return;
	        }
	
	      } else { // then set the bypass with the property value
	        style.applyBypass( this, name, value, updateTransitions );
	
	        var updatedCompounds = this.updateCompoundBounds();
	        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
	        toNotify.rtrigger('style'); // let the renderer know we've updated style
	      }
	
	    } else if( name === undefined ){
	      var ele = this[0];
	
	      if( ele ){
	        return style.getRawStyle( ele );
	      } else { // empty collection => can't get any value
	        return;
	      }
	    }
	
	    return this; // chaining
	  },
	
	  removeCss: function( names ){
	    var cy = this.cy();
	
	    if( !cy.styleEnabled() ){ return this; }
	
	    var updateTransitions = false;
	    var style = cy.style();
	    var eles = this;
	
	    if( names === undefined ){
	      for( var i = 0; i < eles.length; i++ ){
	        var ele = eles[i];
	
	        style.removeAllBypasses( ele, updateTransitions );
	      }
	    } else {
	      names = names.split(/\s+/);
	
	      for( var i = 0; i < eles.length; i++ ){
	        var ele = eles[i];
	
	        style.removeBypasses( ele, names, updateTransitions );
	      }
	    }
	
	    var updatedCompounds = this.updateCompoundBounds();
	    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
	    toNotify.rtrigger('style'); // let the renderer know we've updated style
	
	    return this; // chaining
	  },
	
	  show: function(){
	    this.css('display', 'element');
	    return this; // chaining
	  },
	
	  hide: function(){
	    this.css('display', 'none');
	    return this; // chaining
	  },
	
	  visible: function(){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return true; }
	
	    var ele = this[0];
	    var hasCompoundNodes = cy.hasCompoundNodes();
	
	    if( ele ){
	      var style = ele._private.style;
	
	      if(
	        style['visibility'].value !== 'visible'
	        || style['display'].value !== 'element'
	      ){
	        return false;
	      }
	
	      if( ele._private.group === 'nodes' ){
	        if( !hasCompoundNodes ){ return true; }
	
	        var parents = ele._private.data.parent ? ele.parents() : null;
	
	        if( parents ){
	          for( var i = 0; i < parents.length; i++ ){
	            var parent = parents[i];
	            var pStyle = parent._private.style;
	            var pVis = pStyle['visibility'].value;
	            var pDis = pStyle['display'].value;
	
	            if( pVis !== 'visible' || pDis !== 'element' ){
	              return false;
	            }
	          }
	        }
	
	        return true;
	      } else {
	        var src = ele._private.source;
	        var tgt = ele._private.target;
	
	        return src.visible() && tgt.visible();
	      }
	
	    }
	  },
	
	  hidden: function(){
	    var ele = this[0];
	
	    if( ele ){
	      return !ele.visible();
	    }
	  },
	
	  effectiveOpacity: function(){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return 1; }
	
	    var hasCompoundNodes = cy.hasCompoundNodes();
	    var ele = this[0];
	
	    if( ele ){
	      var _p = ele._private;
	      var parentOpacity = _p.style.opacity.value;
	
	      if( !hasCompoundNodes ){ return parentOpacity; }
	
	      var parents = !_p.data.parent ? null : ele.parents();
	
	      if( parents ){
	        for( var i = 0; i < parents.length; i++ ){
	          var parent = parents[i];
	          var opacity = parent._private.style.opacity.value;
	
	          parentOpacity = opacity * parentOpacity;
	        }
	      }
	
	      return parentOpacity;
	    }
	  },
	
	  transparent: function(){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return false; }
	
	    var ele = this[0];
	    var hasCompoundNodes = ele.cy().hasCompoundNodes();
	
	    if( ele ){
	      if( !hasCompoundNodes ){
	        return ele._private.style.opacity.value === 0;
	      } else {
	        return ele.effectiveOpacity() === 0;
	      }
	    }
	  },
	
	  isFullAutoParent: function(){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return false; }
	
	    var ele = this[0];
	
	    if( ele ){
	      var autoW = ele._private.style['width'].value === 'auto';
	      var autoH = ele._private.style['height'].value === 'auto';
	
	      return ele.isParent() && autoW && autoH;
	    }
	  },
	
	  backgrounding: function(){
	    var cy = this.cy();
	    if( !cy.styleEnabled() ){ return false; }
	
	    var ele = this[0];
	
	    return ele._private.backgrounding ? true : false;
	  }
	
	});
	
	
	elesfn.bypass = elesfn.style = elesfn.css;
	elesfn.renderedStyle = elesfn.renderedCss;
	elesfn.removeBypass = elesfn.removeStyle = elesfn.removeCss;
	
	module.exports = elesfn;
	
	},{"../is":77}],27:[function(_dereq_,module,exports){
	'use strict';
	
	var elesfn = {};
	
	function defineSwitchFunction(params){
	  return function(){
	    var args = arguments;
	    var changedEles = [];
	
	    // e.g. cy.nodes().select( data, handler )
	    if( args.length === 2 ){
	      var data = args[0];
	      var handler = args[1];
	      this.bind( params.event, data, handler );
	    }
	
	    // e.g. cy.nodes().select( handler )
	    else if( args.length === 1 ){
	      var handler = args[0];
	      this.bind( params.event, handler );
	    }
	
	    // e.g. cy.nodes().select()
	    else if( args.length === 0 ){
	      for( var i = 0; i < this.length; i++ ){
	        var ele = this[i];
	        var able = !params.ableField || ele._private[params.ableField];
	        var changed = ele._private[params.field] != params.value;
	
	        if( params.overrideAble ){
	          var overrideAble = params.overrideAble(ele);
	
	          if( overrideAble !== undefined ){
	            able = overrideAble;
	
	            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
	          }
	        }
	
	        if( able ){
	          ele._private[params.field] = params.value;
	
	          if( changed ){
	            changedEles.push( ele );
	          }
	        }
	      }
	
	      var changedColl = this.spawn( changedEles );
	      changedColl.updateStyle(); // change of state => possible change of style
	      changedColl.trigger( params.event );
	    }
	
	    return this;
	  };
	}
	
	function defineSwitchSet( params ){
	  elesfn[ params.field ] = function(){
	    var ele = this[0];
	
	    if( ele ){
	      if( params.overrideField ){
	        var val = params.overrideField(ele);
	
	        if( val !== undefined ){
	          return val;
	        }
	      }
	
	      return ele._private[ params.field ];
	    }
	  };
	
	  elesfn[ params.on ] = defineSwitchFunction({
	    event: params.on,
	    field: params.field,
	    ableField: params.ableField,
	    overrideAble: params.overrideAble,
	    value: true
	  });
	
	  elesfn[ params.off ] = defineSwitchFunction({
	    event: params.off,
	    field: params.field,
	    ableField: params.ableField,
	    overrideAble: params.overrideAble,
	    value: false
	  });
	}
	
	defineSwitchSet({
	  field: 'locked',
	  overrideField: function(ele){
	    return ele.cy().autolock() ? true : undefined;
	  },
	  on: 'lock',
	  off: 'unlock'
	});
	
	defineSwitchSet({
	  field: 'grabbable',
	  overrideField: function(ele){
	    return ele.cy().autoungrabify() ? false : undefined;
	  },
	  on: 'grabify',
	  off: 'ungrabify'
	});
	
	defineSwitchSet({
	  field: 'selected',
	  ableField: 'selectable',
	  overrideAble: function(ele){
	    return ele.cy().autounselectify() ? false : undefined;
	  },
	  on: 'select',
	  off: 'unselect'
	});
	
	defineSwitchSet({
	  field: 'selectable',
	  overrideField: function(ele){
	    return ele.cy().autounselectify() ? false : undefined;
	  },
	  on: 'selectify',
	  off: 'unselectify'
	});
	
	elesfn.deselect = elesfn.unselect;
	
	elesfn.grabbed = function(){
	  var ele = this[0];
	  if( ele ){
	    return ele._private.grabbed;
	  }
	};
	
	defineSwitchSet({
	  field: 'active',
	  on: 'activate',
	  off: 'unactivate'
	});
	
	elesfn.inactive = function(){
	  var ele = this[0];
	  if( ele ){
	    return !ele._private.active;
	  }
	};
	
	module.exports = elesfn;
	
	},{}],28:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var elesfn = {};
	
	util.extend(elesfn, {
	  // get the root nodes in the DAG
	  roots: function( selector ){
	    var eles = this;
	    var roots = [];
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      if( !ele.isNode() ){
	        continue;
	      }
	
	      var hasEdgesPointingIn = ele.connectedEdges(function(){
	        return this.data('target') === ele.id() && this.data('source') !== ele.id();
	      }).length > 0;
	
	      if( !hasEdgesPointingIn ){
	        roots.push( ele );
	      }
	    }
	
	    return this.spawn( roots, { unique: true } ).filter( selector );
	  },
	
	  // get the leaf nodes in the DAG
	  leaves: function( selector ){
	    var eles = this;
	    var leaves = [];
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      if( !ele.isNode() ){
	        continue;
	      }
	
	      var hasEdgesPointingOut = ele.connectedEdges(function(){
	        return this.data('source') === ele.id() && this.data('target') !== ele.id();
	      }).length > 0;
	
	      if( !hasEdgesPointingOut ){
	        leaves.push( ele );
	      }
	    }
	
	    return this.spawn( leaves, { unique: true } ).filter( selector );
	  },
	
	  // normally called children in graph theory
	  // these nodes =edges=> outgoing nodes
	  outgoers: function( selector ){
	    var eles = this;
	    var oEles = [];
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var eleId = ele.id();
	
	      if( !ele.isNode() ){ continue; }
	
	      var edges = ele._private.edges;
	      for( var j = 0; j < edges.length; j++ ){
	        var edge = edges[j];
	        var srcId = edge._private.data.source;
	        var tgtId = edge._private.data.target;
	
	        if( srcId === eleId && tgtId !== eleId ){
	          oEles.push( edge );
	          oEles.push( edge.target()[0] );
	        }
	      }
	    }
	
	    return this.spawn( oEles, { unique: true } ).filter( selector );
	  },
	
	  // aka DAG descendants
	  successors: function( selector ){
	    var eles = this;
	    var sEles = [];
	    var sElesIds = {};
	
	    for(;;){
	      var outgoers = eles.outgoers();
	
	      if( outgoers.length === 0 ){ break; } // done if no outgoers left
	
	      var newOutgoers = false;
	      for( var i = 0; i < outgoers.length; i++ ){
	        var outgoer = outgoers[i];
	        var outgoerId = outgoer.id();
	
	        if( !sElesIds[ outgoerId ] ){
	          sElesIds[ outgoerId ] = true;
	          sEles.push( outgoer );
	          newOutgoers = true;
	        }
	      }
	
	      if( !newOutgoers ){ break; } // done if touched all outgoers already
	
	      eles = outgoers;
	    }
	
	    return this.spawn( sEles, { unique: true } ).filter( selector );
	  },
	
	  // normally called parents in graph theory
	  // these nodes <=edges= incoming nodes
	  incomers: function( selector ){
	    var eles = this;
	    var oEles = [];
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	      var eleId = ele.id();
	
	      if( !ele.isNode() ){ continue; }
	
	      var edges = ele._private.edges;
	      for( var j = 0; j < edges.length; j++ ){
	        var edge = edges[j];
	        var srcId = edge._private.data.source;
	        var tgtId = edge._private.data.target;
	
	        if( tgtId === eleId && srcId !== eleId ){
	          oEles.push( edge );
	          oEles.push( edge.source()[0] );
	        }
	      }
	    }
	
	    return this.spawn( oEles, { unique: true } ).filter( selector );
	  },
	
	  // aka DAG ancestors
	  predecessors: function( selector ){
	    var eles = this;
	    var pEles = [];
	    var pElesIds = {};
	
	    for(;;){
	      var incomers = eles.incomers();
	
	      if( incomers.length === 0 ){ break; } // done if no incomers left
	
	      var newIncomers = false;
	      for( var i = 0; i < incomers.length; i++ ){
	        var incomer = incomers[i];
	        var incomerId = incomer.id();
	
	        if( !pElesIds[ incomerId ] ){
	          pElesIds[ incomerId ] = true;
	          pEles.push( incomer );
	          newIncomers = true;
	        }
	      }
	
	      if( !newIncomers ){ break; } // done if touched all incomers already
	
	      eles = incomers;
	    }
	
	    return this.spawn( pEles, { unique: true } ).filter( selector );
	  }
	});
	
	
	// Neighbourhood functions
	//////////////////////////
	
	util.extend(elesfn, {
	  neighborhood: function(selector){
	    var elements = [];
	    var nodes = this.nodes();
	
	    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
	      var node = nodes[i];
	      var connectedEdges = node.connectedEdges();
	
	      // for each connected edge, add the edge and the other node
	      for( var j = 0; j < connectedEdges.length; j++ ){
	        var edge = connectedEdges[j];
	        var src = edge._private.source;
	        var tgt = edge._private.target;
	        var otherNode = node === src ? tgt : src;
	
	        // need check in case of loop
	        if( otherNode.length > 0 ){
	          elements.push( otherNode[0] ); // add node 1 hop away
	        }
	
	        // add connected edge
	        elements.push( edge[0] );
	      }
	
	    }
	
	    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
	  },
	
	  closedNeighborhood: function(selector){
	    return this.neighborhood().add( this ).filter( selector );
	  },
	
	  openNeighborhood: function(selector){
	    return this.neighborhood( selector );
	  }
	});
	
	// aliases
	elesfn.neighbourhood = elesfn.neighborhood;
	elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
	elesfn.openNeighbourhood = elesfn.openNeighborhood;
	
	// Edge functions
	/////////////////
	
	util.extend(elesfn, {
	  source: function( selector ){
	    var ele = this[0];
	    var src;
	
	    if( ele ){
	      src = ele._private.source;
	    }
	
	    return src && selector ? src.filter( selector ) : src;
	  },
	
	  target: function( selector ){
	    var ele = this[0];
	    var tgt;
	
	    if( ele ){
	      tgt = ele._private.target;
	    }
	
	    return tgt && selector ? tgt.filter( selector ) : tgt;
	  },
	
	  sources: defineSourceFunction({
	    attr: 'source'
	  }),
	
	  targets: defineSourceFunction({
	    attr: 'target'
	  })
	});
	
	function defineSourceFunction( params ){
	  return function( selector ){
	    var sources = [];
	
	    for( var i = 0; i < this.length; i++ ){
	      var ele = this[i];
	      var src = ele._private[ params.attr ];
	
	      if( src ){
	        sources.push( src );
	      }
	    }
	
	    return this.spawn( sources, { unique: true } ).filter( selector );
	  };
	}
	
	util.extend(elesfn, {
	  edgesWith: defineEdgesWithFunction(),
	
	  edgesTo: defineEdgesWithFunction({
	    thisIs: 'source'
	  })
	});
	
	function defineEdgesWithFunction( params ){
	
	  return function edgesWithImpl( otherNodes ){
	    var elements = [];
	    var cy = this._private.cy;
	    var p = params || {};
	
	    // get elements if a selector is specified
	    if( is.string(otherNodes) ){
	      otherNodes = cy.$( otherNodes );
	    }
	
	    var thisIds = this._private.ids;
	    var otherIds = otherNodes._private.ids;
	
	    for( var h = 0; h < otherNodes.length; h++ ){
	      var edges = otherNodes[h]._private.edges;
	
	      for( var i = 0; i < edges.length; i++ ){
	        var edge = edges[i];
	        var edgeData = edge._private.data;
	        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
	        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
	        var edgeConnectsThisAndOther = thisToOther || otherToThis;
	
	        if( !edgeConnectsThisAndOther ){ continue; }
	
	        if( p.thisIs ){
	          if( p.thisIs === 'source' && !thisToOther ){ continue; }
	
	          if( p.thisIs === 'target' && !otherToThis ){ continue; }
	        }
	
	        elements.push( edge );
	      }
	    }
	
	    return this.spawn( elements, { unique: true } );
	  };
	}
	
	util.extend(elesfn, {
	  connectedEdges: function( selector ){
	    var retEles = [];
	
	    var eles = this;
	    for( var i = 0; i < eles.length; i++ ){
	      var node = eles[i];
	      if( !node.isNode() ){ continue; }
	
	      var edges = node._private.edges;
	
	      for( var j = 0; j < edges.length; j++ ){
	        var edge = edges[j];
	        retEles.push( edge );
	      }
	    }
	
	    return this.spawn( retEles, { unique: true } ).filter( selector );
	  },
	
	  connectedNodes: function( selector ){
	    var retEles = [];
	
	    var eles = this;
	    for( var i = 0; i < eles.length; i++ ){
	      var edge = eles[i];
	      if( !edge.isEdge() ){ continue; }
	
	      retEles.push( edge.source()[0] );
	      retEles.push( edge.target()[0] );
	    }
	
	    return this.spawn( retEles, { unique: true } ).filter( selector );
	  },
	
	  parallelEdges: defineParallelEdgesFunction(),
	
	  codirectedEdges: defineParallelEdgesFunction({
	    codirected: true
	  })
	});
	
	function defineParallelEdgesFunction(params){
	  var defaults = {
	    codirected: false
	  };
	  params = util.extend({}, defaults, params);
	
	  return function( selector ){
	    var elements = [];
	    var edges = this.edges();
	    var p = params;
	
	    // look at all the edges in the collection
	    for( var i = 0; i < edges.length; i++ ){
	      var edge1 = edges[i];
	      var src1 = edge1.source()[0];
	      var srcid1 = src1.id();
	      var tgt1 = edge1.target()[0];
	      var tgtid1 = tgt1.id();
	      var srcEdges1 = src1._private.edges;
	
	      // look at edges connected to the src node of this edge
	      for( var j = 0; j < srcEdges1.length; j++ ){
	        var edge2 = srcEdges1[j];
	        var edge2data = edge2._private.data;
	        var tgtid2 = edge2data.target;
	        var srcid2 = edge2data.source;
	
	        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
	        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
	
	        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
	          elements.push( edge2 );
	        }
	      }
	    }
	
	    return this.spawn( elements, { unique: true } ).filter( selector );
	  };
	
	}
	
	// Misc functions
	/////////////////
	
	util.extend(elesfn, {
	  components: function(){
	    var cy = this.cy();
	    var visited = cy.collection();
	    var unvisited = this.nodes();
	    var components = [];
	
	    var visitInComponent = function( node, component ){
	      visited.merge( node );
	      unvisited.unmerge( node );
	      component.merge( node );
	    };
	
	    do {
	      var component = cy.collection();
	      components.push( component );
	
	      var root = unvisited[0];
	      visitInComponent( root, component );
	
	      this.bfs({
	        directed: false,
	        roots: root,
	        visit: function( i, depth, v, e, u ){
	          visitInComponent( v, component );
	        }
	      });
	
	    } while( unvisited.length > 0 );
	
	    return components.map(function( component ){
	      var connectedEdges = component.connectedEdges().stdFilter(function( edge ){
	        return component.anySame( edge.source() ) && component.anySame( edge.target() );
	      });
	
	      return component.union( connectedEdges );
	    });
	  }
	});
	
	module.exports = elesfn;
	
	},{"../is":77,"../util":94}],29:[function(_dereq_,module,exports){
	'use strict';
	
	var zIndexSort = function( a, b ){
	  var cy = a.cy();
	  var a_p = a._private;
	  var b_p = b._private;
	  var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
	  var depthA = 0;
	  var depthB = 0;
	  var hasCompoundNodes = cy.hasCompoundNodes();
	  var aIsNode = a_p.group === 'nodes';
	  var aIsEdge = a_p.group === 'edges';
	  var bIsNode = b_p.group === 'nodes';
	  var bIsEdge = b_p.group === 'edges';
	
	  // no need to calculate element depth if there is no compound node
	  if( hasCompoundNodes ){
	    depthA = a.zDepth();
	    depthB = b.zDepth();
	  }
	
	  var depthDiff = depthA - depthB;
	  var sameDepth = depthDiff === 0;
	
	  if( sameDepth ){
	
	    if( aIsNode && bIsEdge ){
	      return 1; // 'a' is a node, it should be drawn later
	
	    } else if( aIsEdge && bIsNode ){
	      return -1; // 'a' is an edge, it should be drawn first
	
	    } else { // both nodes or both edges
	      if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
	        return a_p.index - b_p.index;
	      } else {
	        return zDiff;
	      }
	    }
	
	  // elements on different level
	  } else {
	    return depthDiff; // deeper element should be drawn later
	  }
	
	};
	
	module.exports = zIndexSort;
	
	},{}],30:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var util = _dereq_('../util');
	var Collection = _dereq_('../collection');
	var Element = _dereq_('../collection/element');
	var window = _dereq_('../window');
	var document = window ? window.document : null;
	var NullRenderer = _dereq_('../extensions/renderer/null');
	
	var corefn = {
	  add: function(opts){
	
	    var elements;
	    var cy = this;
	
	    // add the elements
	    if( is.elementOrCollection(opts) ){
	      var eles = opts;
	
	      if( eles._private.cy === cy ){ // same instance => just restore
	        elements = eles.restore();
	
	      } else { // otherwise, copy from json
	        var jsons = [];
	
	        for( var i = 0; i < eles.length; i++ ){
	          var ele = eles[i];
	          jsons.push( ele.json() );
	        }
	
	        elements = new Collection( cy, jsons );
	      }
	    }
	
	    // specify an array of options
	    else if( is.array(opts) ){
	      var jsons = opts;
	
	      elements = new Collection(cy, jsons);
	    }
	
	    // specify via opts.nodes and opts.edges
	    else if( is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges)) ){
	      var elesByGroup = opts;
	      var jsons = [];
	
	      var grs = ['nodes', 'edges'];
	      for( var i = 0, il = grs.length; i < il; i++ ){
	        var group = grs[i];
	        var elesArray = elesByGroup[group];
	
	        if( is.array(elesArray) ){
	
	          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
	            var json = util.extend( { group: group }, elesArray[j] );
	
	            jsons.push( json );
	          }
	        }
	      }
	
	      elements = new Collection(cy, jsons);
	    }
	
	    // specify options for one element
	    else {
	      var json = opts;
	      elements = (new Element( cy, json )).collection();
	    }
	
	    return elements;
	  },
	
	  remove: function(collection){
	    if( is.elementOrCollection(collection) ){
	      collection = collection;
	    } else if( is.string(collection) ){
	      var selector = collection;
	      collection = this.$( selector );
	    }
	
	    return collection.remove();
	  },
	
	  load: function(elements, onload, ondone){
	    var cy = this;
	
	    cy.notifications(false);
	
	    // remove old elements
	    var oldEles = cy.elements();
	    if( oldEles.length > 0 ){
	      oldEles.remove();
	    }
	
	    if( elements != null ){
	      if( is.plainObject(elements) || is.array(elements) ){
	        cy.add( elements );
	      }
	    }
	
	    cy.one('layoutready', function(e){
	      cy.notifications(true);
	      cy.trigger(e); // we missed this event by turning notifications off, so pass it on
	
	      cy.notify({
	        type: 'load',
	        collection: cy.elements()
	      });
	
	      cy.one('load', onload);
	      cy.trigger('load');
	    }).one('layoutstop', function(){
	      cy.one('done', ondone);
	      cy.trigger('done');
	    });
	
	    var layoutOpts = util.extend({}, cy._private.options.layout);
	    layoutOpts.eles = cy.$();
	
	    cy.layout( layoutOpts );
	
	    return this;
	  }
	};
	
	module.exports = corefn;
	
	},{"../collection":23,"../collection/element":19,"../extensions/renderer/null":73,"../is":77,"../util":94,"../window":100}],31:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var corefn = ({
	
	  // pull in animation functions
	  animate: define.animate(),
	  animation: define.animation(),
	  animated: define.animated(),
	  clearQueue: define.clearQueue(),
	  delay: define.delay(),
	  delayAnimation: define.delayAnimation(),
	  stop: define.stop(),
	
	  addToAnimationPool: function( eles ){
	    var cy = this;
	
	    if( !cy.styleEnabled() ){ return; } // save cycles when no style used
	
	    cy._private.aniEles.merge( eles );
	  },
	
	  stopAnimationLoop: function(){
	    this._private.animationsRunning = false;
	  },
	
	  startAnimationLoop: function(){
	    var cy = this;
	
	    cy._private.animationsRunning = true;
	
	    if( !cy.styleEnabled() ){ return; } // save cycles when no style used
	
	    // NB the animation loop will exec in headless environments if style enabled
	    // and explicit cy.destroy() is necessary to stop the loop
	
	    function globalAnimationStep(){
	      if( !cy._private.animationsRunning ){ return; }
	
	      util.requestAnimationFrame(function(now){
	        handleElements(now);
	        globalAnimationStep();
	      });
	    }
	
	    globalAnimationStep(); // first call
	
	    function handleElements( now ){
	      var eles = cy._private.aniEles;
	      var doneEles = [];
	
	      function handleElement( ele, isCore ){
	        var _p = ele._private;
	        var current = _p.animation.current;
	        var queue = _p.animation.queue;
	        var ranAnis = false;
	
	        // if nothing currently animating, get something from the queue
	        if( current.length === 0 ){
	          var next = queue.shift();
	
	          if( next ){
	            current.push( next );
	          }
	        }
	
	        var callbacks = function( callbacks ){
	          for( var j = callbacks.length - 1; j >= 0; j-- ){
	            var cb = callbacks[j];
	
	            cb();
	          }
	
	          callbacks.splice( 0, callbacks.length );
	        };
	
	        // step and remove if done
	        for( var i = current.length - 1; i >= 0; i-- ){
	          var ani = current[i];
	          var ani_p = ani._private;
	
	          if( ani_p.stopped ){
	            current.splice( i, 1 );
	
	            ani_p.hooked = false;
	            ani_p.playing = false;
	            ani_p.started = false;
	
	            callbacks( ani_p.frames );
	
	            continue;
	          }
	
	          if( !ani_p.playing && !ani_p.applying ){ continue; }
	
	          // an apply() while playing shouldn't do anything
	          if( ani_p.playing && ani_p.applying ){
	            ani_p.applying = false;
	          }
	
	          if( !ani_p.started ){
	            startAnimation( ele, ani, now );
	          }
	
	          step( ele, ani, now, isCore );
	
	          if( ani_p.applying ){
	            ani_p.applying = false;
	          }
	
	          callbacks( ani_p.frames );
	
	          if( ani.completed() ){
	            current.splice(i, 1);
	
	            ani_p.hooked = false;
	            ani_p.playing = false;
	            ani_p.started = false;
	
	            callbacks( ani_p.completes );
	          }
	
	          ranAnis = true;
	        }
	
	        if( !isCore && current.length === 0 && queue.length === 0 ){
	          doneEles.push( ele );
	        }
	
	        return ranAnis;
	      } // handleElement
	
	      // handle all eles
	      var ranEleAni = false;
	      for( var e = 0; e < eles.length; e++ ){
	        var ele = eles[e];
	        var handledThisEle = handleElement( ele );
	
	        ranEleAni = ranEleAni || handledThisEle;
	      } // each element
	
	      var ranCoreAni = handleElement( cy, true );
	
	      // notify renderer
	      if( ranEleAni || ranCoreAni ){
	        var toNotify;
	
	        if( eles.length > 0 ){
	          var updatedEles = eles.updateCompoundBounds();
	          toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
	        }
	
	        cy.notify({
	          type: 'draw',
	          collection: toNotify
	        });
	      }
	
	      // remove elements from list of currently animating if its queues are empty
	      eles.unmerge( doneEles );
	
	    } // handleElements
	
	    function startAnimation( self, ani, now ){
	      var isCore = is.core( self );
	      var isEles = !isCore;
	      var ele = self;
	      var style = cy._private.style;
	      var ani_p = ani._private;
	
	      if( isEles ){
	        var pos = ele._private.position;
	
	        ani_p.startPosition = ani_p.startPosition || {
	          x: pos.x,
	          y: pos.y
	        };
	
	        ani_p.startStyle = ani_p.startStyle || style.getValueStyle( ele );
	      }
	
	      if( isCore ){
	        var pan = cy._private.pan;
	
	        ani_p.startPan = ani_p.startPan || {
	          x: pan.x,
	          y: pan.y
	        };
	
	        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
	      }
	
	      ani_p.started = true;
	      ani_p.startTime = now - ani_p.progress * ani_p.duration;
	    }
	
	    function step( self, ani, now, isCore ){
	      var style = cy._private.style;
	      var isEles = !isCore;
	      var _p = self._private;
	      var ani_p = ani._private;
	      var pEasing = ani_p.easing;
	      var startTime = ani_p.startTime;
	
	      if( !ani_p.easingImpl ){
	
	        if( pEasing == null ){ // use default
	          ani_p.easingImpl = easings['linear'];
	
	        } else { // then define w/ name
	          var easingVals;
	
	          if( is.string( pEasing ) ){
	            var easingProp = style.parse('transition-timing-function', pEasing);
	
	            easingVals = easingProp.value;
	
	          } else { // then assume preparsed array
	            easingVals = pEasing;
	          }
	
	          var name, args;
	
	          if( is.string( easingVals ) ){
	            name = easingVals;
	            args = [];
	          } else {
	            name = easingVals[1];
	            args = easingVals.slice(2).map(function(n){ return +n; });
	          }
	
	          if( args.length > 0 ){ // create with args
	            if( name === 'spring' ){
	              args.push( ani_p.duration ); // need duration to generate spring
	            }
	
	            ani_p.easingImpl = easings[ name ].apply( null, args );
	          } else { // static impl by name
	            ani_p.easingImpl = easings[ name ];
	          }
	        }
	
	      }
	
	      var easing = ani_p.easingImpl;
	      var percent;
	
	      if( ani_p.duration === 0 ){
	        percent = 1;
	      } else {
	        percent = (now - startTime) / ani_p.duration;
	      }
	
	      if( ani_p.applying ){
	        percent = ani_p.progress;
	      }
	
	      if( percent < 0 ){
	        percent = 0;
	      } else if( percent > 1 ){
	        percent = 1;
	      }
	
	      if( ani_p.delay == null ){ // then update
	
	        var startPos = ani_p.startPosition;
	        var endPos = ani_p.position;
	        var pos = _p.position;
	        if( endPos && isEles ){
	          if( valid( startPos.x, endPos.x ) ){
	            pos.x = ease( startPos.x, endPos.x, percent, easing );
	          }
	
	          if( valid( startPos.y, endPos.y ) ){
	            pos.y = ease( startPos.y, endPos.y, percent, easing );
	          }
	        }
	
	        var startPan = ani_p.startPan;
	        var endPan = ani_p.pan;
	        var pan = _p.pan;
	        var animatingPan = endPan != null && isCore;
	        if( animatingPan ){
	          if( valid( startPan.x, endPan.x ) ){
	            pan.x = ease( startPan.x, endPan.x, percent, easing );
	          }
	
	          if( valid( startPan.y, endPan.y ) ){
	            pan.y = ease( startPan.y, endPan.y, percent, easing );
	          }
	
	          self.trigger('pan');
	        }
	
	        var startZoom = ani_p.startZoom;
	        var endZoom = ani_p.zoom;
	        var animatingZoom = endZoom != null && isCore;
	        if( animatingZoom ){
	          if( valid( startZoom, endZoom ) ){
	            _p.zoom = ease( startZoom, endZoom, percent, easing );
	          }
	
	          self.trigger('zoom');
	        }
	
	        if( animatingPan || animatingZoom ){
	          self.trigger('viewport');
	        }
	
	        var props = ani_p.style;
	        if( props && isEles ){
	
	          for( var i = 0; i < props.length; i++ ){
	            var prop = props[i];
	            var name = prop.name;
	            var end = prop;
	
	            var start = ani_p.startStyle[ name ];
	            var easedVal = ease( start, end, percent, easing );
	
	            style.overrideBypass( self, name, easedVal );
	          } // for props
	
	        } // if
	
	      }
	
	      if( is.fn(ani_p.step) ){
	        ani_p.step.apply( self, [ now ] );
	      }
	
	      ani_p.progress = percent;
	
	      return percent;
	    }
	
	    function valid(start, end){
	      if( start == null || end == null ){
	        return false;
	      }
	
	      if( is.number(start) && is.number(end) ){
	        return true;
	      } else if( (start) && (end) ){
	        return true;
	      }
	
	      return false;
	    }
	
	    // assumes p0 = 0, p3 = 1
	    function evalCubicBezier( p1, p2, t ){
	      var one_t = 1 - t;
	      var tsq = t*t;
	
	      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
	    }
	
	    function cubicBezier( p1, p2 ){
	      return function( start, end, percent ){
	        return start + (end - start) * evalCubicBezier( p1, p2, percent );
	      };
	    }
	
	    /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
	    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
	       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
	    var generateSpringRK4 = (function () {
	        function springAccelerationForState (state) {
	            return (-state.tension * state.x) - (state.friction * state.v);
	        }
	
	        function springEvaluateStateWithDerivative (initialState, dt, derivative) {
	            var state = {
	                x: initialState.x + derivative.dx * dt,
	                v: initialState.v + derivative.dv * dt,
	                tension: initialState.tension,
	                friction: initialState.friction
	            };
	
	            return { dx: state.v, dv: springAccelerationForState(state) };
	        }
	
	        function springIntegrateState (state, dt) {
	            var a = {
	                    dx: state.v,
	                    dv: springAccelerationForState(state)
	                },
	                b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
	                c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
	                d = springEvaluateStateWithDerivative(state, dt, c),
	                dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
	                dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
	
	            state.x = state.x + dxdt * dt;
	            state.v = state.v + dvdt * dt;
	
	            return state;
	        }
	
	        return function springRK4Factory (tension, friction, duration) {
	
	            var initState = {
	                    x: -1,
	                    v: 0,
	                    tension: null,
	                    friction: null
	                },
	                path = [0],
	                time_lapsed = 0,
	                tolerance = 1 / 10000,
	                DT = 16 / 1000,
	                have_duration, dt, last_state;
	
	            tension = parseFloat(tension) || 500;
	            friction = parseFloat(friction) || 20;
	            duration = duration || null;
	
	            initState.tension = tension;
	            initState.friction = friction;
	
	            have_duration = duration !== null;
	
	            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
	            if (have_duration) {
	                /* Run the simulation without a duration. */
	                time_lapsed = springRK4Factory(tension, friction);
	                /* Compute the adjusted time delta. */
	                dt = time_lapsed / duration * DT;
	            } else {
	                dt = DT;
	            }
	
	            while (true) {
	                /* Next/step function .*/
	                last_state = springIntegrateState(last_state || initState, dt);
	                /* Store the position. */
	                path.push(1 + last_state.x);
	                time_lapsed += 16;
	                /* If the change threshold is reached, break. */
	                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
	                    break;
	                }
	            }
	
	            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
	               computed path and returns a snapshot of the position according to a given percentComplete. */
	            return !have_duration ? time_lapsed : function(percentComplete) { return path[ (percentComplete * (path.length - 1)) | 0 ]; };
	        };
	    }());
	
	    var easings = {
	      'linear': function( start, end, percent ){
	        return start + (end - start) * percent;
	      },
	
	      // default easings
	      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
	      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
	      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
	      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),
	
	      // sine
	      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
	      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
	      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),
	
	      // quad
	      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
	      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
	      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),
	
	      // cubic
	      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
	      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
	      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),
	
	      // quart
	      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
	      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
	      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),
	
	      // quint
	      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
	      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
	      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),
	
	      // expo
	      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
	      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
	      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),
	
	      // circ
	      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
	      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
	      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),
	
	
	      // user param easings...
	
	      'spring': function( tension, friction, duration ){
	        var spring = generateSpringRK4( tension, friction, duration );
	
	        return function( start, end, percent ){
	          return start + (end - start) * spring( percent );
	        };
	      },
	
	      'cubic-bezier': function( x1, y1, x2, y2 ){
	        return cubicBezier( x1, y1, x2, y2 );
	      }
	    };
	
	    function ease( startProp, endProp, percent, easingFn ){
	      if( percent < 0 ){
	        percent = 0;
	      } else if( percent > 1 ){
	        percent = 1;
	      }
	
	      var start, end;
	
	      if( startProp.pfValue != null || startProp.value != null ){
	        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
	      } else {
	        start = startProp;
	      }
	
	      if( endProp.pfValue != null || endProp.value != null ){
	        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
	      } else {
	        end = endProp;
	      }
	
	      if( is.number(start) && is.number(end) ){
	        return easingFn( start, end, percent );
	
	      } else if( is.array(start) && is.array(end) ){
	        var easedArr = [];
	
	        for( var i = 0; i < end.length; i++ ){
	          var si = start[i];
	          var ei = end[i];
	
	          if( si != null && ei != null ){
	            var val = easingFn(si, ei, percent);
	
	            if( startProp.roundValue ){ val = Math.round( val ); }
	
	            easedArr.push( val );
	          } else {
	            easedArr.push( ei );
	          }
	        }
	
	        return easedArr;
	      }
	
	      return undefined;
	    }
	
	  }
	
	});
	
	module.exports = corefn;
	
	},{"../define":41,"../is":77,"../util":94}],32:[function(_dereq_,module,exports){
	'use strict';
	
	var define = _dereq_('../define');
	
	var corefn = ({
	  on: define.on(), // .on( events [, selector] [, data], handler)
	  one: define.on({ unbindSelfOnTrigger: true }),
	  once: define.on({ unbindAllBindersOnTrigger: true }),
	  off: define.off(), // .off( events [, selector] [, handler] )
	  trigger: define.trigger() // .trigger( events [, extraParams] )
	});
	
	define.eventAliasesOn( corefn );
	
	module.exports = corefn;
	
	},{"../define":41}],33:[function(_dereq_,module,exports){
	'use strict';
	
	var corefn = ({
	
	  png: function( options ){
	    var renderer = this._private.renderer;
	    options = options || {};
	
	    return renderer.png( options );
	  },
	
	  jpg: function( options ){
	    var renderer = this._private.renderer;
	    options = options || {};
	
	    options.bg = options.bg || '#fff';
	
	    return renderer.jpg( options );
	  }
	
	});
	
	corefn.jpeg = corefn.jpg;
	
	module.exports = corefn;
	
	},{}],34:[function(_dereq_,module,exports){
	'use strict';
	
	var window = _dereq_('../window');
	var util = _dereq_('../util');
	var Collection = _dereq_('../collection');
	var is = _dereq_('../is');
	var Promise = _dereq_('../promise');
	var define = _dereq_('../define');
	
	var Core = function( opts ){
	  if( !(this instanceof Core) ){
	    return new Core(opts);
	  }
	  var cy = this;
	
	  opts = util.extend({}, opts);
	
	  var container = opts.container;
	
	  // allow for passing a wrapped jquery object
	  // e.g. cytoscape({ container: $('#cy') })
	  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
	    container = container[0];
	  }
	
	  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
	  reg = reg || {};
	
	  if( reg && reg.cy ){
	    reg.cy.destroy();
	
	    reg = {}; // old instance => replace reg completely
	  }
	
	  var readies = reg.readies = reg.readies || [];
	
	  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
	  reg.cy = cy;
	
	  var head = window !== undefined && container !== undefined && !opts.headless;
	  var options = opts;
	  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
	  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
	
	  var defVal = function( def, val, altVal ){
	    if( val !== undefined ){
	      return val;
	    } else if( altVal !== undefined ){
	      return altVal;
	    } else {
	      return def;
	    }
	  };
	
	  var _p = this._private = {
	    container: container, // html dom ele container
	    ready: false, // whether ready has been triggered
	    initrender: false, // has initrender has been triggered
	    options: options, // cached options
	    elements: [], // array of elements
	    id2index: {}, // element id => index in elements array
	    listeners: [], // list of listeners
	    onRenders: [], // rendering listeners
	    aniEles: Collection(this), // elements being animated
	    scratch: {}, // scratch object for core
	    layout: null,
	    renderer: null,
	    notificationsEnabled: true, // whether notifications are sent to the renderer
	    minZoom: 1e-50,
	    maxZoom: 1e50,
	    zoomingEnabled: defVal(true, options.zoomingEnabled),
	    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
	    panningEnabled: defVal(true, options.panningEnabled),
	    userPanningEnabled: defVal(true, options.userPanningEnabled),
	    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
	    autolock: defVal(false, options.autolock, options.autolockNodes),
	    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
	    autounselectify: defVal(false, options.autounselectify),
	    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
	    zoom: is.number(options.zoom) ? options.zoom : 1,
	    pan: {
	      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
	      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
	    },
	    animation: { // object for currently-running animations
	      current: [],
	      queue: []
	    },
	    hasCompoundNodes: false,
	    deferredExecQueue: []
	  };
	
	  // set selection type
	  var selType = options.selectionType;
	  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
	    // then set default
	
	    _p.selectionType = 'single';
	  } else {
	    _p.selectionType = selType;
	  }
	
	  // init zoom bounds
	  if( is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
	    _p.minZoom = options.minZoom;
	    _p.maxZoom = options.maxZoom;
	  } else if( is.number(options.minZoom) && options.maxZoom === undefined ){
	    _p.minZoom = options.minZoom;
	  } else if( is.number(options.maxZoom) && options.minZoom === undefined ){
	    _p.maxZoom = options.maxZoom;
	  }
	
	  var loadExtData = function( next ){
	    var anyIsPromise = false;
	
	    for( var i = 0; i < extData.length; i++ ){
	      var datum = extData[i];
	
	      if( is.promise(datum) ){
	        anyIsPromise = true;
	        break;
	      }
	    }
	
	    if( anyIsPromise ){
	      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
	    } else {
	      next( extData ); // exec synchronously for convenience
	    }
	  };
	
	  // create the renderer
	  cy.initRenderer( util.extend({
	    hideEdgesOnViewport: options.hideEdgesOnViewport,
	    hideLabelsOnViewport: options.hideLabelsOnViewport,
	    textureOnViewport: options.textureOnViewport,
	    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
	    motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
	    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
	    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
	    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
	    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
	  }, options.renderer) );
	
	  var extData = [ options.style, options.elements ];
	  loadExtData(function( thens ){
	    var initStyle = thens[0];
	    var initEles = thens[1];
	
	    // init style
	    if( _p.styleEnabled ){
	      cy.setStyle( initStyle );
	    }
	
	    // trigger the passed function for the `initrender` event
	    if( options.initrender ){
	      cy.on('initrender', options.initrender);
	      cy.on('initrender', function(){
	        _p.initrender = true;
	      });
	    }
	
	    // initial load
	    cy.load(initEles, function(){ // onready
	      cy.startAnimationLoop();
	      _p.ready = true;
	
	      // if a ready callback is specified as an option, the bind it
	      if( is.fn( options.ready ) ){
	        cy.on('ready', options.ready);
	      }
	
	      // bind all the ready handlers registered before creating this instance
	      for( var i = 0; i < readies.length; i++ ){
	        var fn = readies[i];
	        cy.on('ready', fn);
	      }
	      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
	
	      cy.trigger('ready');
	    }, options.done);
	
	  });
	};
	
	var corefn = Core.prototype; // short alias
	
	util.extend(corefn, {
	  instanceString: function(){
	    return 'core';
	  },
	
	  isReady: function(){
	    return this._private.ready;
	  },
	
	  ready: function( fn ){
	    if( this.isReady() ){
	      this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
	    } else {
	      this.on('ready', fn);
	    }
	
	    return this;
	  },
	
	  initrender: function(){
	    return this._private.initrender;
	  },
	
	  destroy: function(){
	    var cy = this;
	
	    cy.stopAnimationLoop();
	
	    cy.notify({ type: 'destroy' }); // destroy the renderer
	
	    var domEle = cy.container();
	    if( domEle ){
	      domEle._cyreg = null;
	
	      while( domEle.childNodes.length > 0 ){
	        domEle.removeChild( domEle.childNodes[0] );
	      }
	    }
	
	    return cy;
	  },
	
	  getElementById: function( id ){
	    var index = this._private.id2index[ id ];
	    if( index !== undefined ){
	      return this._private.elements[ index ];
	    }
	
	    // worst case, return an empty collection
	    return Collection( this );
	  },
	
	  selectionType: function(){
	    return this._private.selectionType;
	  },
	
	  hasCompoundNodes: function(){
	    return this._private.hasCompoundNodes;
	  },
	
	  styleEnabled: function(){
	    return this._private.styleEnabled;
	  },
	
	  addToPool: function( eles ){
	    var elements = this._private.elements;
	    var id2index = this._private.id2index;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	
	      var id = ele._private.data.id;
	      var index = id2index[ id ];
	      var alreadyInPool = index !== undefined;
	
	      if( !alreadyInPool ){
	        index = elements.length;
	        elements.push( ele );
	        id2index[ id ] = index;
	        ele._private.index = index;
	      }
	    }
	
	    return this; // chaining
	  },
	
	  removeFromPool: function( eles ){
	    var elements = this._private.elements;
	    var id2index = this._private.id2index;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	
	      var id = ele._private.data.id;
	      var index = id2index[ id ];
	      var inPool = index !== undefined;
	
	      if( inPool ){
	        this._private.id2index[ id ] = undefined;
	        elements.splice(index, 1);
	
	        // adjust the index of all elements past this index
	        for( var j = index; j < elements.length; j++ ){
	          var jid = elements[j]._private.data.id;
	          id2index[ jid ]--;
	          elements[j]._private.index--;
	        }
	      }
	    }
	  },
	
	  container: function(){
	    return this._private.container;
	  },
	
	  options: function(){
	    return util.copy( this._private.options );
	  },
	
	  json: function( obj ){
	    var cy = this;
	    var _p = cy._private;
	
	    if( is.plainObject(obj) ){ // set
	
	      cy.startBatch();
	
	      if( obj.elements ){
	        var idInJson = {};
	
	        var updateEles = function( jsons, gr ){
	          for( var i = 0; i < jsons.length; i++ ){
	            var json = jsons[i];
	            var id = json.data.id;
	            var ele = cy.getElementById( id );
	
	            idInJson[ id ] = true;
	
	            if( ele.length !== 0 ){ // existing element should be updated
	              ele.json( json );
	            } else { // otherwise should be added
	              if( gr ){
	                cy.add( util.extend({ group: gr }, json) );
	              } else {
	                cy.add( json );
	              }
	            }
	          }
	        };
	
	        if( is.array(obj.elements) ){ // elements: []
	          updateEles( obj.elements );
	
	        } else { // elements: { nodes: [], edges: [] }
	          var grs = ['nodes', 'edges'];
	          for( var i = 0; i < grs.length; i++ ){
	            var gr = grs[i];
	            var elements = obj.elements[ gr ];
	
	            if( is.array(elements) ){
	              updateEles( elements, gr );
	            }
	          }
	        }
	
	        // elements not specified in json should be removed
	        cy.elements().stdFilter(function( ele ){
	          return !idInJson[ ele.id() ];
	        }).remove();
	      }
	
	      if( obj.style ){
	        cy.style( obj.style );
	      }
	
	      if( obj.zoom != null && obj.zoom !== _p.zoom ){
	        cy.zoom( obj.zoom );
	      }
	
	      if( obj.pan ){
	        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
	          cy.pan( obj.pan );
	        }
	      }
	
	      var fields = [
	        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
	        'panningEnabled', 'userPanningEnabled',
	        'boxSelectionEnabled',
	        'autolock', 'autoungrabify', 'autounselectify'
	      ];
	
	      for( var i = 0; i < fields.length; i++ ){
	        var f = fields[i];
	
	        if( obj[f] != null ){
	          cy[f]( obj[f] );
	        }
	      }
	
	      cy.endBatch();
	
	      return this; // chaining
	    } else if( obj === undefined ){ // get
	      var json = {};
	
	      json.elements = {};
	      cy.elements().each(function(i, ele){
	        var group = ele.group();
	
	        if( !json.elements[group] ){
	          json.elements[group] = [];
	        }
	
	        json.elements[group].push( ele.json() );
	      });
	
	      if( this._private.styleEnabled ){
	        json.style = cy.style().json();
	      }
	
	      json.zoomingEnabled = cy._private.zoomingEnabled;
	      json.userZoomingEnabled = cy._private.userZoomingEnabled;
	      json.zoom = cy._private.zoom;
	      json.minZoom = cy._private.minZoom;
	      json.maxZoom = cy._private.maxZoom;
	      json.panningEnabled = cy._private.panningEnabled;
	      json.userPanningEnabled = cy._private.userPanningEnabled;
	      json.pan = util.copy( cy._private.pan );
	      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
	      json.renderer = util.copy( cy._private.options.renderer );
	      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
	      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
	      json.textureOnViewport = cy._private.options.textureOnViewport;
	      json.wheelSensitivity = cy._private.options.wheelSensitivity;
	      json.motionBlur = cy._private.options.motionBlur;
	
	      return json;
	    }
	  },
	
	  scratch: define.data({
	    field: 'scratch',
	    bindingEvent: 'scratch',
	    allowBinding: true,
	    allowSetting: true,
	    settingEvent: 'scratch',
	    settingTriggersEvent: true,
	    triggerFnName: 'trigger',
	    allowGetting: true
	  }),
	
	  removeScratch: define.removeData({
	    field: 'scratch',
	    event: 'scratch',
	    triggerFnName: 'trigger',
	    triggerEvent: true
	  })
	
	});
	
	[
	  _dereq_('./add-remove'),
	  _dereq_('./animation'),
	  _dereq_('./events'),
	  _dereq_('./export'),
	  _dereq_('./layout'),
	  _dereq_('./notification'),
	  _dereq_('./renderer'),
	  _dereq_('./search'),
	  _dereq_('./style'),
	  _dereq_('./viewport')
	].forEach(function( props ){
	  util.extend( corefn, props );
	});
	
	module.exports = Core;
	
	},{"../collection":23,"../define":41,"../is":77,"../promise":80,"../util":94,"../window":100,"./add-remove":30,"./animation":31,"./events":32,"./export":33,"./layout":35,"./notification":36,"./renderer":37,"./search":38,"./style":39,"./viewport":40}],35:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var corefn = ({
	
	  layout: function( params ){
	    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );
	
	    layout.run();
	
	    return this; // chaining
	  },
	
	  makeLayout: function( options ){
	    var cy = this;
	
	    if( options == null ){
	      util.error('Layout options must be specified to make a layout');
	      return;
	    }
	
	    if( options.name == null ){
	      util.error('A `name` must be specified to make a layout');
	      return;
	    }
	
	    var name = options.name;
	    var Layout = cy.extension('layout', name);
	
	    if( Layout == null ){
	      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
	      return;
	    }
	
	    var eles;
	    if( is.string( options.eles ) ){
	      eles = cy.$( options.eles );
	    } else {
	      eles = options.eles != null ? options.eles : cy.$();
	    }
	
	    var layout = new Layout( util.extend({}, options, {
	      cy: cy,
	      eles: eles
	    }) );
	
	    return layout;
	  }
	
	});
	
	corefn.createLayout = corefn.makeLayout;
	
	module.exports = corefn;
	
	},{"../is":77,"../util":94}],36:[function(_dereq_,module,exports){
	'use strict';
	
	var corefn = ({
	  notify: function( params ){
	    var _p = this._private;
	
	    if( _p.batchingNotify ){
	      var bEles = _p.batchNotifyEles;
	      var bTypes = _p.batchNotifyTypes;
	
	      if( params.collection ){
	        bEles.merge( params.collection );
	      }
	
	      if( !bTypes.ids[ params.type ] ){
	        bTypes.push( params.type );
	      }
	
	      return; // notifications are disabled during batching
	    }
	
	    if( !_p.notificationsEnabled ){ return; } // exit on disabled
	
	    var renderer = this.renderer();
	
	    renderer.notify(params);
	  },
	
	  notifications: function( bool ){
	    var p = this._private;
	
	    if( bool === undefined ){
	      return p.notificationsEnabled;
	    } else {
	      p.notificationsEnabled = bool ? true : false;
	    }
	  },
	
	  noNotifications: function( callback ){
	    this.notifications(false);
	    callback();
	    this.notifications(true);
	  },
	
	  startBatch: function(){
	    var _p = this._private;
	
	    if( _p.batchCount == null ){
	      _p.batchCount = 0;
	    }
	
	    if( _p.batchCount === 0 ){
	      _p.batchingStyle = _p.batchingNotify = true;
	      _p.batchStyleEles = this.collection();
	      _p.batchNotifyEles = this.collection();
	      _p.batchNotifyTypes = [];
	
	      _p.batchNotifyTypes.ids = {};
	    }
	
	    _p.batchCount++;
	
	    return this;
	  },
	
	  endBatch: function(){
	    var _p = this._private;
	
	    _p.batchCount--;
	
	    if( _p.batchCount === 0 ){
	      // update style for dirty eles
	      _p.batchingStyle = false;
	      _p.batchStyleEles.updateStyle();
	
	      // notify the renderer of queued eles and event types
	      _p.batchingNotify = false;
	      this.notify({
	        type: _p.batchNotifyTypes,
	        collection: _p.batchNotifyEles
	      });
	    }
	
	    return this;
	  },
	
	  batch: function( callback ){
	    this.startBatch();
	    callback();
	    this.endBatch();
	
	    return this;
	  },
	
	  // for backwards compatibility
	  batchData: function( map ){
	    var cy = this;
	
	    return this.batch(function(){
	      for( var id in map ){
	        var data = map[id];
	        var ele = cy.getElementById( id );
	
	        ele.data( data );
	      }
	    });
	  }
	});
	
	module.exports = corefn;
	
	},{}],37:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	
	var corefn = ({
	
	  renderTo: function( context, zoom, pan, pxRatio ){
	    var r = this._private.renderer;
	
	    r.renderTo( context, zoom, pan, pxRatio );
	    return this;
	  },
	
	  renderer: function(){
	    return this._private.renderer;
	  },
	
	  forceRender: function(){
	    this.notify({
	      type: 'draw'
	    });
	
	    return this;
	  },
	
	  resize: function(){
	    this.notify({
	      type: 'resize'
	    });
	
	    this.trigger('resize');
	
	    return this;
	  },
	
	  initRenderer: function( options ){
	    var cy = this;
	
	    var RendererProto = cy.extension('renderer', options.name);
	    if( RendererProto == null ){
	      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
	      return;
	    }
	
	    var rOpts = util.extend({}, options, {
	      cy: cy
	    });
	    var renderer = cy._private.renderer = new RendererProto( rOpts );
	
	    renderer.init( rOpts );
	
	  },
	
	  triggerOnRender: function(){
	    var cbs = this._private.onRenders;
	
	    for( var i = 0; i < cbs.length; i++ ){
	      var cb = cbs[i];
	
	      cb();
	    }
	
	    return this;
	  },
	
	  onRender: function( cb ){
	    this._private.onRenders.push( cb );
	
	    return this;
	  },
	
	  offRender: function( fn ){
	    var cbs = this._private.onRenders;
	
	    if( fn == null ){ // unbind all
	      this._private.onRenders = [];
	      return this;
	    }
	
	    for( var i = 0; i < cbs.length; i++ ){ // unbind specified
	      var cb = cbs[i];
	
	      if( fn === cb ){
	        cbs.splice( i, 1 );
	        break;
	      }
	    }
	
	    return this;
	  }
	
	});
	
	corefn.invalidateDimensions = corefn.resize;
	
	module.exports = corefn;
	
	},{"../util":94}],38:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var Collection = _dereq_('../collection');
	
	var corefn = ({
	
	  // get a collection
	  // - empty collection on no args
	  // - collection of elements in the graph on selector arg
	  // - guarantee a returned collection when elements or collection specified
	  collection: function( eles, opts ){
	
	    if( is.string( eles ) ){
	      return this.$( eles );
	
	    } else if( is.elementOrCollection( eles ) ){
	      return eles.collection();
	
	    } else if( is.array( eles ) ){
	      return Collection( this, eles, opts );
	    }
	
	    return Collection( this );
	  },
	
	  nodes: function( selector ){
	    var nodes = this.$(function(){
	      return this.isNode();
	    });
	
	    if( selector ){
	      return nodes.filter( selector );
	    }
	
	    return nodes;
	  },
	
	  edges: function( selector ){
	    var edges = this.$(function(){
	      return this.isEdge();
	    });
	
	    if( selector ){
	      return edges.filter( selector );
	    }
	
	    return edges;
	  },
	
	  // search the graph like jQuery
	  $: function( selector ){
	    var eles = new Collection( this, this._private.elements );
	
	    if( selector ){
	      return eles.filter( selector );
	    }
	
	    return eles;
	  }
	
	});
	
	// aliases
	corefn.elements = corefn.filter = corefn.$;
	
	module.exports = corefn;
	
	},{"../collection":23,"../is":77}],39:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var Style = _dereq_('../style');
	
	var corefn = ({
	
	  style: function( newStyle ){
	    if( newStyle ){
	      var s = this.setStyle( newStyle );
	
	      s.update();
	    }
	
	    return this._private.style;
	  },
	
	  setStyle: function( style ){
	    var _p = this._private;
	
	    if( is.stylesheet(style) ){
	      _p.style = style.generateStyle(this);
	
	    } else if( is.array(style) ) {
	      _p.style = Style.fromJson(this, style);
	
	    } else if( is.string(style) ){
	      _p.style = Style.fromString(this, style);
	
	    } else {
	      _p.style = Style( this );
	    }
	
	    return _p.style;
	  }
	});
	
	module.exports = corefn;
	
	},{"../is":77,"../style":86}],40:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	
	var corefn = ({
	
	  autolock: function(bool){
	    if( bool !== undefined ){
	      this._private.autolock = bool ? true : false;
	    } else {
	      return this._private.autolock;
	    }
	
	    return this; // chaining
	  },
	
	  autoungrabify: function(bool){
	    if( bool !== undefined ){
	      this._private.autoungrabify = bool ? true : false;
	    } else {
	      return this._private.autoungrabify;
	    }
	
	    return this; // chaining
	  },
	
	  autounselectify: function(bool){
	    if( bool !== undefined ){
	      this._private.autounselectify = bool ? true : false;
	    } else {
	      return this._private.autounselectify;
	    }
	
	    return this; // chaining
	  },
	
	  panningEnabled: function( bool ){
	    if( bool !== undefined ){
	      this._private.panningEnabled = bool ? true : false;
	    } else {
	      return this._private.panningEnabled;
	    }
	
	    return this; // chaining
	  },
	
	  userPanningEnabled: function( bool ){
	    if( bool !== undefined ){
	      this._private.userPanningEnabled = bool ? true : false;
	    } else {
	      return this._private.userPanningEnabled;
	    }
	
	    return this; // chaining
	  },
	
	  zoomingEnabled: function( bool ){
	    if( bool !== undefined ){
	      this._private.zoomingEnabled = bool ? true : false;
	    } else {
	      return this._private.zoomingEnabled;
	    }
	
	    return this; // chaining
	  },
	
	  userZoomingEnabled: function( bool ){
	    if( bool !== undefined ){
	      this._private.userZoomingEnabled = bool ? true : false;
	    } else {
	      return this._private.userZoomingEnabled;
	    }
	
	    return this; // chaining
	  },
	
	  boxSelectionEnabled: function( bool ){
	    if( bool !== undefined ){
	      this._private.boxSelectionEnabled = bool ? true : false;
	    } else {
	      return this._private.boxSelectionEnabled;
	    }
	
	    return this; // chaining
	  },
	
	  pan: function(){
	    var args = arguments;
	    var pan = this._private.pan;
	    var dim, val, dims, x, y;
	
	    switch( args.length ){
	    case 0: // .pan()
	      return pan;
	
	    case 1:
	
	      if( is.string( args[0] ) ){ // .pan('x')
	        dim = args[0];
	        return pan[ dim ];
	
	      } else if( is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
	        if( !this._private.panningEnabled ){
	          return this;
	        }
	
	        dims = args[0];
	        x = dims.x;
	        y = dims.y;
	
	        if( is.number(x) ){
	          pan.x = x;
	        }
	
	        if( is.number(y) ){
	          pan.y = y;
	        }
	
	        this.trigger('pan viewport');
	      }
	      break;
	
	    case 2: // .pan('x', 100)
	      if( !this._private.panningEnabled ){
	        return this;
	      }
	
	      dim = args[0];
	      val = args[1];
	
	      if( (dim === 'x' || dim === 'y') && is.number(val) ){
	        pan[dim] = val;
	      }
	
	      this.trigger('pan viewport');
	      break;
	
	    default:
	      break; // invalid
	    }
	
	    this.notify({ // notify the renderer that the viewport changed
	      type: 'viewport'
	    });
	
	    return this; // chaining
	  },
	
	  panBy: function(params){
	    var args = arguments;
	    var pan = this._private.pan;
	    var dim, val, dims, x, y;
	
	    if( !this._private.panningEnabled ){
	      return this;
	    }
	
	    switch( args.length ){
	    case 1:
	
	      if( is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
	        dims = args[0];
	        x = dims.x;
	        y = dims.y;
	
	        if( is.number(x) ){
	          pan.x += x;
	        }
	
	        if( is.number(y) ){
	          pan.y += y;
	        }
	
	        this.trigger('pan viewport');
	      }
	      break;
	
	    case 2: // .panBy('x', 100)
	      dim = args[0];
	      val = args[1];
	
	      if( (dim === 'x' || dim === 'y') && is.number(val) ){
	        pan[dim] += val;
	      }
	
	      this.trigger('pan viewport');
	      break;
	
	    default:
	      break; // invalid
	    }
	
	    this.notify({ // notify the renderer that the viewport changed
	      type: 'viewport'
	    });
	
	    return this; // chaining
	  },
	
	  fit: function( elements, padding ){
	    var viewportState = this.getFitViewport( elements, padding );
	
	    if( viewportState ){
	      var _p = this._private;
	      _p.zoom = viewportState.zoom;
	      _p.pan = viewportState.pan;
	
	      this.trigger('pan zoom viewport');
	
	      this.notify({ // notify the renderer that the viewport changed
	        type: 'viewport'
	      });
	    }
	
	    return this; // chaining
	  },
	
	  getFitViewport: function( elements, padding ){
	    if( is.number(elements) && padding === undefined ){ // elements is optional
	      padding = elements;
	      elements = undefined;
	    }
	
	    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
	      return;
	    }
	
	    var bb;
	
	    if( is.string(elements) ){
	      var sel = elements;
	      elements = this.$( sel );
	
	    } else if( is.boundingBox(elements) ){ // assume bb
	      var bbe = elements;
	      bb = {
	        x1: bbe.x1,
	        y1: bbe.y1,
	        x2: bbe.x2,
	        y2: bbe.y2
	      };
	
	      bb.w = bb.x2 - bb.x1;
	      bb.h = bb.y2 - bb.y1;
	
	    } else if( !is.elementOrCollection(elements) ){
	      elements = this.elements();
	    }
	
	    bb = bb || elements.boundingBox();
	
	    var w = this.width();
	    var h = this.height();
	    var zoom;
	    padding = is.number(padding) ? padding : 0;
	
	    if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
	      zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );
	
	      // crop zoom
	      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
	      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
	
	      var pan = { // now pan to middle
	        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
	        y: (h - zoom*( bb.y1 + bb.y2 ))/2
	      };
	
	      return {
	        zoom: zoom,
	        pan: pan
	      };
	    }
	
	    return;
	  },
	
	  minZoom: function( zoom ){
	    if( zoom === undefined ){
	      return this._private.minZoom;
	    } else if( is.number(zoom) ){
	      this._private.minZoom = zoom;
	    }
	
	    return this;
	  },
	
	  maxZoom: function( zoom ){
	    if( zoom === undefined ){
	      return this._private.maxZoom;
	    } else if( is.number(zoom) ){
	      this._private.maxZoom = zoom;
	    }
	
	    return this;
	  },
	
	  zoom: function( params ){
	    var pos; // in rendered px
	    var zoom;
	
	    if( params === undefined ){ // then get the zoom
	      return this._private.zoom;
	
	    } else if( is.number(params) ){ // then set the zoom
	      zoom = params;
	
	    } else if( is.plainObject(params) ){ // then zoom about a point
	      zoom = params.level;
	
	      if( params.position ){
	        var p = params.position;
	        var pan = this._private.pan;
	        var z = this._private.zoom;
	
	        pos = { // convert to rendered px
	          x: p.x * z + pan.x,
	          y: p.y * z + pan.y
	        };
	      } else if( params.renderedPosition ){
	        pos = params.renderedPosition;
	      }
	
	      if( pos && !this._private.panningEnabled ){
	        return this; // panning disabled
	      }
	    }
	
	    if( !this._private.zoomingEnabled ){
	      return this; // zooming disabled
	    }
	
	    if( !is.number(zoom) || ( pos && (!is.number(pos.x) || !is.number(pos.y)) ) ){
	      return this; // can't zoom with invalid params
	    }
	
	    // crop zoom
	    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
	    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
	
	    if( pos ){ // set zoom about position
	      var pan1 = this._private.pan;
	      var zoom1 = this._private.zoom;
	      var zoom2 = zoom;
	
	      var pan2 = {
	        x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
	        y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
	      };
	
	      this._private.zoom = zoom;
	      this._private.pan = pan2;
	
	      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
	      this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
	
	    } else { // just set the zoom
	      this._private.zoom = zoom;
	      this.trigger('zoom viewport');
	    }
	
	    this.notify({ // notify the renderer that the viewport changed
	      type: 'viewport'
	    });
	
	    return this; // chaining
	  },
	
	  viewport: function( opts ){
	    var _p = this._private;
	    var zoomDefd = true;
	    var panDefd = true;
	    var events = []; // to trigger
	    var zoomFailed = false;
	    var panFailed = false;
	
	    if( !opts ){ return this; }
	    if( !is.number(opts.zoom) ){ zoomDefd = false; }
	    if( !is.plainObject(opts.pan) ){ panDefd = false; }
	    if( !zoomDefd && !panDefd ){ return this; }
	
	    if( zoomDefd ){
	      var z = opts.zoom;
	
	      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
	        zoomFailed = true;
	
	      } else {
	        _p.zoom = z;
	
	        events.push('zoom');
	      }
	    }
	
	    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
	      var p = opts.pan;
	
	      if( is.number(p.x) ){
	        _p.pan.x = p.x;
	        panFailed = false;
	      }
	
	      if( is.number(p.y) ){
	        _p.pan.y = p.y;
	        panFailed = false;
	      }
	
	      if( !panFailed ){
	        events.push('pan');
	      }
	    }
	
	    if( events.length > 0 ){
	      events.push('viewport');
	      this.trigger( events.join(' ') );
	
	      this.notify({
	        type: 'viewport'
	      });
	    }
	
	    return this; // chaining
	  },
	
	  center: function( elements ){
	    var pan = this.getCenterPan( elements );
	
	    if( pan ){
	      this._private.pan = pan;
	
	      this.trigger('pan viewport');
	
	      this.notify({ // notify the renderer that the viewport changed
	        type: 'viewport'
	      });
	    }
	
	    return this; // chaining
	  },
	
	  getCenterPan: function( elements, zoom ){
	    if( !this._private.panningEnabled ){
	      return;
	    }
	
	    if( is.string(elements) ){
	      var selector = elements;
	      elements = this.elements( selector );
	    } else if( !is.elementOrCollection(elements) ){
	      elements = this.elements();
	    }
	
	    var bb = elements.boundingBox();
	    var w = this.width();
	    var h = this.height();
	    zoom = zoom === undefined ? this._private.zoom : zoom;
	
	    var pan = { // middle
	      x: (w - zoom*( bb.x1 + bb.x2 ))/2,
	      y: (h - zoom*( bb.y1 + bb.y2 ))/2
	    };
	
	    return pan;
	  },
	
	  reset: function(){
	    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
	      return this;
	    }
	
	    this.viewport({
	      pan: { x: 0, y: 0 },
	      zoom: 1
	    });
	
	    return this; // chaining
	  },
	
	  width: function(){
	    var container = this._private.container;
	
	    if( container ){
	      return container.clientWidth;
	    }
	
	    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
	  },
	
	  height: function(){
	    var container = this._private.container;
	
	    if( container ){
	      return container.clientHeight;
	    }
	
	    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
	  },
	
	  extent: function(){
	    var pan = this._private.pan;
	    var zoom = this._private.zoom;
	    var rb = this.renderedExtent();
	
	    var b = {
	      x1: ( rb.x1 - pan.x )/zoom,
	      x2: ( rb.x2 - pan.x )/zoom,
	      y1: ( rb.y1 - pan.y )/zoom,
	      y2: ( rb.y2 - pan.y )/zoom
	    };
	
	    b.w = b.x2 - b.x1;
	    b.h = b.y2 - b.y1;
	
	    return b;
	  },
	
	  renderedExtent: function(){
	    var width = this.width();
	    var height = this.height();
	
	    return {
	      x1: 0,
	      y1: 0,
	      x2: width,
	      y2: height,
	      w: width,
	      h: height
	    };
	  }
	});
	
	// aliases
	corefn.centre = corefn.center;
	
	// backwards compatibility
	corefn.autolockNodes = corefn.autolock;
	corefn.autoungrabifyNodes = corefn.autoungrabify;
	
	module.exports = corefn;
	
	},{"../is":77}],41:[function(_dereq_,module,exports){
	'use strict';
	
	// use this module to cherry pick functions into your prototype
	// (useful for functions shared between the core and collections, for example)
	
	// e.g.
	// var foo = define.foo({ /* params... */ })
	
	var util = _dereq_('./util');
	var is = _dereq_('./is');
	var Selector = _dereq_('./selector');
	var Promise = _dereq_('./promise');
	var Event = _dereq_('./event');
	var Animation = _dereq_('./animation');
	
	var define = {
	
	  // access data field
	  data: function( params ){
	    var defaults = {
	      field: 'data',
	      bindingEvent: 'data',
	      allowBinding: false,
	      allowSetting: false,
	      allowGetting: false,
	      settingEvent: 'data',
	      settingTriggersEvent: false,
	      triggerFnName: 'trigger',
	      immutableKeys: {}, // key => true if immutable
	      updateStyle: false,
	      onSet: function( self ){},
	      canSet: function( self ){ return true; }
	    };
	    params = util.extend({}, defaults, params);
	
	    return function dataImpl( name, value ){
	      var p = params;
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var single = selfIsArrayLike ? self[0] : self;
	
	      // .data('foo', ...)
	      if( is.string(name) ){ // set or get property
	
	        // .data('foo')
	        if( p.allowGetting && value === undefined ){ // get
	
	          var ret;
	          if( single ){
	            ret = single._private[ p.field ][ name ];
	          }
	          return ret;
	
	        // .data('foo', 'bar')
	        } else if( p.allowSetting && value !== undefined ) { // set
	          var valid = !p.immutableKeys[name];
	          if( valid ){
	            for( var i = 0, l = all.length; i < l; i++ ){
	              if( p.canSet( all[i] ) ){
	                all[i]._private[ p.field ][ name ] = value;
	              }
	            }
	
	            // update mappers if asked
	            if( p.updateStyle ){ self.updateStyle(); }
	
	            // call onSet callback
	            p.onSet( self );
	
	            if( p.settingTriggersEvent ){
	              self[ p.triggerFnName ]( p.settingEvent );
	            }
	          }
	        }
	
	      // .data({ 'foo': 'bar' })
	      } else if( p.allowSetting && is.plainObject(name) ){ // extend
	        var obj = name;
	        var k, v;
	
	        for( k in obj ){
	          v = obj[ k ];
	
	          var valid = !p.immutableKeys[k];
	          if( valid ){
	            for( var i = 0, l = all.length; i < l; i++ ){
	              if( p.canSet( all[i] ) ){
	                all[i]._private[ p.field ][ k ] = v;
	              }
	            }
	          }
	        }
	
	        // update mappers if asked
	        if( p.updateStyle ){ self.updateStyle(); }
	
	        // call onSet callback
	        p.onSet( self );
	
	        if( p.settingTriggersEvent ){
	          self[ p.triggerFnName ]( p.settingEvent );
	        }
	
	      // .data(function(){ ... })
	      } else if( p.allowBinding && is.fn(name) ){ // bind to event
	        var fn = name;
	        self.bind( p.bindingEvent, fn );
	
	      // .data()
	      } else if( p.allowGetting && name === undefined ){ // get whole object
	        var ret;
	        if( single ){
	          ret = single._private[ p.field ];
	        }
	        return ret;
	      }
	
	      return self; // maintain chainability
	    }; // function
	  }, // data
	
	  // remove data field
	  removeData: function( params ){
	    var defaults = {
	      field: 'data',
	      event: 'data',
	      triggerFnName: 'trigger',
	      triggerEvent: false,
	      immutableKeys: {} // key => true if immutable
	    };
	    params = util.extend({}, defaults, params);
	
	    return function removeDataImpl( names ){
	      var p = params;
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	
	      // .removeData('foo bar')
	      if( is.string(names) ){ // then get the list of keys, and delete them
	        var keys = names.split(/\s+/);
	        var l = keys.length;
	
	        for( var i = 0; i < l; i++ ){ // delete each non-empty key
	          var key = keys[i];
	          if( is.emptyString(key) ){ continue; }
	
	          var valid = !p.immutableKeys[ key ]; // not valid if immutable
	          if( valid ){
	            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
	              all[ i_a ]._private[ p.field ][ key ] = undefined;
	            }
	          }
	        }
	
	        if( p.triggerEvent ){
	          self[ p.triggerFnName ]( p.event );
	        }
	
	      // .removeData()
	      } else if( names === undefined ){ // then delete all keys
	
	        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
	          var _privateFields = all[ i_a ]._private[ p.field ];
	
	          for( var key in _privateFields ){
	            var validKeyToDelete = !p.immutableKeys[ key ];
	
	            if( validKeyToDelete ){
	              _privateFields[ key ] = undefined;
	            }
	          }
	        }
	
	        if( p.triggerEvent ){
	          self[ p.triggerFnName ]( p.event );
	        }
	      }
	
	      return self; // maintain chaining
	    }; // function
	  }, // removeData
	
	  // event function reusable stuff
	  event: {
	    regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
	    optionalTypeRegex: /(\w+)?(\.\w+)?/,
	    falseCallback: function(){ return false; }
	  },
	
	  // event binding
	  on: function( params ){
	    var defaults = {
	      unbindSelfOnTrigger: false,
	      unbindAllBindersOnTrigger: false
	    };
	    params = util.extend({}, defaults, params);
	
	    return function onImpl(events, selector, data, callback){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var eventsIsString = is.string(events);
	      var p = params;
	
	      if( is.plainObject(selector) ){ // selector is actually data
	        callback = data;
	        data = selector;
	        selector = undefined;
	      } else if( is.fn(selector) || selector === false ){ // selector is actually callback
	        callback = selector;
	        data = undefined;
	        selector = undefined;
	      }
	
	      if( is.fn(data) || data === false ){ // data is actually callback
	        callback = data;
	        data = undefined;
	      }
	
	      // if there isn't a callback, we can't really do anything
	      // (can't speak for mapped events arg version)
	      if( !(is.fn(callback) || callback === false) && eventsIsString ){
	        return self; // maintain chaining
	      }
	
	      if( eventsIsString ){ // then convert to map
	        var map = {};
	        map[ events ] = callback;
	        events = map;
	      }
	
	      for( var evts in events ){
	        callback = events[evts];
	        if( callback === false ){
	          callback = define.event.falseCallback;
	        }
	
	        if( !is.fn(callback) ){ continue; }
	
	        evts = evts.split(/\s+/);
	        for( var i = 0; i < evts.length; i++ ){
	          var evt = evts[i];
	          if( is.emptyString(evt) ){ continue; }
	
	          var match = evt.match( define.event.regex ); // type[.namespace]
	
	          if( match ){
	            var type = match[1];
	            var namespace = match[2] ? match[2] : undefined;
	
	            var listener = {
	              callback: callback, // callback to run
	              data: data, // extra data in eventObj.data
	              delegated: selector ? true : false, // whether the evt is delegated
	              selector: selector, // the selector to match for delegated events
	              selObj: new Selector(selector), // cached selector object to save rebuilding
	              type: type, // the event type (e.g. 'click')
	              namespace: namespace, // the event namespace (e.g. ".foo")
	              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
	              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
	              binders: all // who bound together
	            };
	
	            for( var j = 0; j < all.length; j++ ){
	              var _p = all[j]._private;
	
	              _p.listeners = _p.listeners || [];
	              _p.listeners.push( listener );
	            }
	          }
	        } // for events array
	      } // for events map
	
	      return self; // maintain chaining
	    }; // function
	  }, // on
	
	  eventAliasesOn: function( proto ){
	    var p = proto;
	
	    p.addListener = p.listen = p.bind = p.on;
	    p.removeListener = p.unlisten = p.unbind = p.off;
	    p.emit = p.trigger;
	
	    // this is just a wrapper alias of .on()
	    p.pon = p.promiseOn = function( events, selector ){
	      var self = this;
	      var args = Array.prototype.slice.call( arguments, 0 );
	
	      return new Promise(function( resolve, reject ){
	        var callback = function( e ){
	          self.off.apply( self, offArgs );
	
	          resolve( e );
	        };
	
	        var onArgs = args.concat([ callback ]);
	        var offArgs = onArgs.concat([]);
	
	        self.on.apply( self, onArgs );
	      });
	    };
	  },
	
	  off: function offImpl( params ){
	    var defaults = {
	    };
	    params = util.extend({}, defaults, params);
	
	    return function(events, selector, callback){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var eventsIsString = is.string(events);
	
	      if( arguments.length === 0 ){ // then unbind all
	
	        for( var i = 0; i < all.length; i++ ){
	          all[i]._private.listeners = [];
	        }
	
	        return self; // maintain chaining
	      }
	
	      if( is.fn(selector) || selector === false ){ // selector is actually callback
	        callback = selector;
	        selector = undefined;
	      }
	
	      if( eventsIsString ){ // then convert to map
	        var map = {};
	        map[ events ] = callback;
	        events = map;
	      }
	
	      for( var evts in events ){
	        callback = events[evts];
	
	        if( callback === false ){
	          callback = define.event.falseCallback;
	        }
	
	        evts = evts.split(/\s+/);
	        for( var h = 0; h < evts.length; h++ ){
	          var evt = evts[h];
	          if( is.emptyString(evt) ){ continue; }
	
	          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
	          if( match ){
	            var type = match[1] ? match[1] : undefined;
	            var namespace = match[2] ? match[2] : undefined;
	
	            for( var i = 0; i < all.length; i++ ){ //
	              var listeners = all[i]._private.listeners = all[i]._private.listeners || [];
	
	              for( var j = 0; j < listeners.length; j++ ){
	                var listener = listeners[j];
	                var nsMatches = !namespace || namespace === listener.namespace;
	                var typeMatches = !type || listener.type === type;
	                var cbMatches = !callback || callback === listener.callback;
	                var listenerMatches = nsMatches && typeMatches && cbMatches;
	
	                // delete listener if it matches
	                if( listenerMatches ){
	                  listeners.splice(j, 1);
	                  j--;
	                }
	              } // for listeners
	            } // for all
	          } // if match
	        } // for events array
	
	      } // for events map
	
	      return self; // maintain chaining
	    }; // function
	  }, // off
	
	  trigger: function( params ){
	    var defaults = {};
	    params = util.extend({}, defaults, params);
	
	    return function triggerImpl(events, extraParams, fnToTrigger){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var eventsIsString = is.string(events);
	      var eventsIsObject = is.plainObject(events);
	      var eventsIsEvent = is.event(events);
	      var cy = this._private.cy || ( is.core(this) ? this : null );
	      var hasCompounds = cy ? cy.hasCompoundNodes() : false;
	
	      if( eventsIsString ){ // then make a plain event object for each event name
	        var evts = events.split(/\s+/);
	        events = [];
	
	        for( var i = 0; i < evts.length; i++ ){
	          var evt = evts[i];
	          if( is.emptyString(evt) ){ continue; }
	
	          var match = evt.match( define.event.regex ); // type[.namespace]
	          var type = match[1];
	          var namespace = match[2] ? match[2] : undefined;
	
	          events.push( {
	            type: type,
	            namespace: namespace
	          } );
	        }
	      } else if( eventsIsObject ){ // put in length 1 array
	        var eventArgObj = events;
	
	        events = [ eventArgObj ];
	      }
	
	      if( extraParams ){
	        if( !is.array(extraParams) ){ // make sure extra params are in an array if specified
	          extraParams = [ extraParams ];
	        }
	      } else { // otherwise, we've got nothing
	        extraParams = [];
	      }
	
	      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
	        var evtObj = events[i];
	
	        for( var j = 0; j < all.length; j++ ){ // for each
	          var triggerer = all[j];
	          var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
	          var triggererIsElement = is.element(triggerer);
	          var bubbleUp = triggererIsElement || params.layout;
	
	          // create the event for this element from the event object
	          var evt;
	
	          if( eventsIsEvent ){ // then just get the object
	            evt = evtObj;
	
	            evt.cyTarget = evt.cyTarget || triggerer;
	            evt.cy = evt.cy || cy;
	
	          } else { // then we have to make one
	            evt = new Event( evtObj, {
	              cyTarget: triggerer,
	              cy: cy,
	              namespace: evtObj.namespace
	            } );
	          }
	
	          // if a layout was specified, then put it in the typed event
	          if( evtObj.layout ){
	            evt.layout = evtObj.layout;
	          }
	
	          // if triggered by layout, put in event
	          if( params.layout ){
	            evt.layout = triggerer;
	          }
	
	          // create a rendered position based on the passed position
	          if( evt.cyPosition ){
	            var pos = evt.cyPosition;
	            var zoom = cy.zoom();
	            var pan = cy.pan();
	
	            evt.cyRenderedPosition = {
	              x: pos.x * zoom + pan.x,
	              y: pos.y * zoom + pan.y
	            };
	          }
	
	          if( fnToTrigger ){ // then override the listeners list with just the one we specified
	            listeners = [{
	              namespace: evt.namespace,
	              type: evt.type,
	              callback: fnToTrigger
	            }];
	          }
	
	          for( var k = 0; k < listeners.length; k++ ){ // check each listener
	            var lis = listeners[k];
	            var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
	            var typeMatches = lis.type === evt.type;
	            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
	            var listenerMatches = nsMatches && typeMatches && targetMatches;
	
	            if( listenerMatches ){ // then trigger it
	              var args = [ evt ];
	              args = args.concat( extraParams ); // add extra params to args list
	
	              if( lis.data ){ // add on data plugged into binding
	                evt.data = lis.data;
	              } else { // or clear it in case the event obj is reused
	                evt.data = undefined;
	              }
	
	              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
	                listeners.splice(k, 1);
	                k--;
	              }
	
	              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
	                var binders = lis.binders;
	                for( var l = 0; l < binders.length; l++ ){
	                  var binder = binders[l];
	                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it
	
	                  var binderListeners = binder._private.listeners;
	                  for( var m = 0; m < binderListeners.length; m++ ){
	                    var binderListener = binderListeners[m];
	
	                    if( binderListener === lis ){ // delete listener from list
	                      binderListeners.splice(m, 1);
	                      m--;
	                    }
	                  }
	                }
	              }
	
	              // run the callback
	              var context = lis.delegated ? evt.cyTarget : triggerer;
	              var ret = lis.callback.apply( context, args );
	
	              if( ret === false || evt.isPropagationStopped() ){
	                // then don't bubble
	                bubbleUp = false;
	
	                if( ret === false ){
	                  // returning false is a shorthand for stopping propagation and preventing the def. action
	                  evt.stopPropagation();
	                  evt.preventDefault();
	                }
	              }
	            } // if listener matches
	          } // for each listener
	
	          // bubble up event for elements
	          if( bubbleUp ){
	            var parent = hasCompounds ? triggerer._private.parent : null;
	            var hasParent = parent != null && parent.length !== 0;
	
	            if( hasParent ){ // then bubble up to parent
	              parent = parent[0];
	              parent.trigger(evt);
	            } else { // otherwise, bubble up to the core
	              cy.trigger(evt);
	            }
	          }
	
	        } // for each of all
	      } // for each event
	
	      return self; // maintain chaining
	    }; // function
	  }, // trigger
	
	  animated: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function animatedImpl(){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return false; }
	
	      var ele = all[0];
	
	      if( ele ){
	        return ele._private.animation.current.length > 0;
	      }
	    };
	  }, // animated
	
	  clearQueue: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function clearQueueImpl(){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      for( var i = 0; i < all.length; i++ ){
	        var ele = all[i];
	        ele._private.animation.queue = [];
	      }
	
	      return this;
	    };
	  }, // clearQueue
	
	  delay: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function delayImpl( time, complete ){
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      return this.animate({
	        delay: time,
	        duration: time,
	        complete: complete
	      });
	    };
	  }, // delay
	
	  delayAnimation: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function delayAnimationImpl( time, complete ){
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      return this.animation({
	        delay: time,
	        duration: time,
	        complete: complete
	      });
	    };
	  }, // delay
	
	  animation: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function animationImpl( properties, params ){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var cy = this._private.cy || this;
	      var isCore = !selfIsArrayLike;
	      var isEles = !isCore;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      var style = cy.style();
	
	      properties = util.extend( {}, properties, params );
	
	      if( properties.duration === undefined ){
	        properties.duration = 400;
	      }
	
	      switch( properties.duration ){
	      case 'slow':
	        properties.duration = 600;
	        break;
	      case 'fast':
	        properties.duration = 200;
	        break;
	      }
	
	      var propertiesEmpty = true;
	      if( properties ){ for( var i in properties ){ // jshint ignore:line
	        propertiesEmpty = false;
	        break;
	      } }
	
	      if( propertiesEmpty ){
	        return new Animation( all[0], properties ); // nothing to animate
	      }
	
	      if( isEles ){
	        properties.style = style.getPropsList( properties.style || properties.css );
	
	        properties.css = undefined;
	      }
	
	      if( properties.renderedPosition && isEles ){
	        var rpos = properties.renderedPosition;
	        var pan = cy.pan();
	        var zoom = cy.zoom();
	
	        properties.position = {
	          x: ( rpos.x - pan.x ) /zoom,
	          y: ( rpos.y - pan.y ) /zoom
	        };
	      }
	
	      // override pan w/ panBy if set
	      if( properties.panBy && isCore ){
	        var panBy = properties.panBy;
	        var cyPan = cy.pan();
	
	        properties.pan = {
	          x: cyPan.x + panBy.x,
	          y: cyPan.y + panBy.y
	        };
	      }
	
	      // override pan w/ center if set
	      var center = properties.center || properties.centre;
	      if( center && isCore ){
	        var centerPan = cy.getCenterPan( center.eles, properties.zoom );
	
	        if( centerPan ){
	          properties.pan = centerPan;
	        }
	      }
	
	      // override pan & zoom w/ fit if set
	      if( properties.fit && isCore ){
	        var fit = properties.fit;
	        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );
	
	        if( fitVp ){
	          properties.pan = fitVp.pan;
	          properties.zoom = fitVp.zoom;
	        }
	      }
	
	      return new Animation( all[0], properties );
	    };
	  }, // animate
	
	  animate: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function animateImpl( properties, params ){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      if( params ){
	        properties = util.extend( {}, properties, params );
	      }
	
	      // manually hook and run the animation
	      for( var i = 0; i < all.length; i++ ){
	        var ele = all[i];
	        var queue = ele.animated() && (properties.queue === undefined || properties.queue);
	
	        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );
	
	        ani.play();
	      }
	
	      return this; // chaining
	    };
	  }, // animate
	
	  stop: function( fnParams ){
	    var defaults = {};
	    fnParams = util.extend({}, defaults, fnParams);
	
	    return function stopImpl( clearQueue, jumpToEnd ){
	      var self = this;
	      var selfIsArrayLike = self.length !== undefined;
	      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
	      var cy = this._private.cy || this;
	
	      if( !cy.styleEnabled() ){ return this; }
	
	      for( var i = 0; i < all.length; i++ ){
	        var ele = all[i];
	        var _p = ele._private;
	        var anis = _p.animation.current;
	
	        for( var j = 0; j < anis.length; j++ ){
	          var ani = anis[j];
	          var ani_p = ani._private;
	
	          if( jumpToEnd ){
	            // next iteration of the animation loop, the animation
	            // will go straight to the end and be removed
	            ani_p.duration = 0;
	          }
	        }
	
	        // clear the queue of future animations
	        if( clearQueue ){
	          _p.animation.queue = [];
	        }
	
	        if( !jumpToEnd ){
	          _p.animation.current = [];
	        }
	      }
	
	      // we have to notify (the animation loop doesn't do it for us on `stop`)
	      cy.notify({
	        collection: this,
	        type: 'draw'
	      });
	
	      return this;
	    };
	  } // stop
	
	}; // define
	
	module.exports = define;
	
	},{"./animation":1,"./event":42,"./is":77,"./promise":80,"./selector":81,"./util":94}],42:[function(_dereq_,module,exports){
	'use strict';
	
	/*!
	Event object based on jQuery events, MIT license
	
	https://jquery.org/license/
	https://tldrlegal.com/license/mit-license
	https://github.com/jquery/jquery/blob/master/src/event.js
	*/
	
	var Event = function( src, props ) {
	  // Allow instantiation without the 'new' keyword
	  if ( !(this instanceof Event) ) {
	    return new Event( src, props );
	  }
	
	  // Event object
	  if ( src && src.type ) {
	    this.originalEvent = src;
	    this.type = src.type;
	
	    // Events bubbling up the document may have been marked as prevented
	    // by a handler lower down the tree; reflect the correct value.
	    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;
	
	  // Event type
	  } else {
	    this.type = src;
	  }
	
	  // Put explicitly provided properties onto the event object
	  if ( props ) {
	    // util.extend( this, props );
	
	    // more efficient to manually copy fields we use
	    this.type = props.type !== undefined ? props.type : this.type;
	    this.cy = props.cy;
	    this.cyTarget = props.cyTarget;
	    this.cyPosition = props.cyPosition;
	    this.cyRenderedPosition = props.cyRenderedPosition;
	    this.namespace = props.namespace;
	    this.layout = props.layout;
	    this.data = props.data;
	    this.message = props.message;
	  }
	
	  // Create a timestamp if incoming event doesn't have one
	  this.timeStamp = src && src.timeStamp || Date.now();
	};
	
	function returnFalse() {
	  return false;
	}
	
	function returnTrue() {
	  return true;
	}
	
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	Event.prototype = {
	  instanceString: function(){
	    return 'event';
	  },
	
	  preventDefault: function() {
	    this.isDefaultPrevented = returnTrue;
	
	    var e = this.originalEvent;
	    if ( !e ) {
	      return;
	    }
	
	    // if preventDefault exists run it on the original event
	    if ( e.preventDefault ) {
	      e.preventDefault();
	    }
	  },
	
	  stopPropagation: function() {
	    this.isPropagationStopped = returnTrue;
	
	    var e = this.originalEvent;
	    if ( !e ) {
	      return;
	    }
	
	    // if stopPropagation exists run it on the original event
	    if ( e.stopPropagation ) {
	      e.stopPropagation();
	    }
	  },
	
	  stopImmediatePropagation: function() {
	    this.isImmediatePropagationStopped = returnTrue;
	    this.stopPropagation();
	  },
	
	  isDefaultPrevented: returnFalse,
	  isPropagationStopped: returnFalse,
	  isImmediatePropagationStopped: returnFalse
	};
	
	module.exports = Event;
	
	},{}],43:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('./util');
	var define = _dereq_('./define');
	var Collection = _dereq_('./collection');
	var Core = _dereq_('./core');
	var incExts = _dereq_('./extensions');
	var is = _dereq_('./is');
	
	// registered extensions to cytoscape, indexed by name
	var extensions = {};
	
	// registered modules for extensions, indexed by name
	var modules = {};
	
	function setExtension( type, name, registrant ){
	
	  var ext = registrant;
	
	  if( type === 'core' ){
	    Core.prototype[ name ] = registrant;
	
	  } else if( type === 'collection' ){
	    Collection.prototype[ name ] = registrant;
	
	  } else if( type === 'layout' ){
	    // fill in missing layout functions in the prototype
	
	    var Layout = function( options ){
	      this.options = options;
	
	      registrant.call( this, options );
	
	      // make sure layout has _private for use w/ std apis like .on()
	      if( !is.plainObject(this._private) ){
	        this._private = {};
	      }
	
	      this._private.cy = options.cy;
	      this._private.listeners = [];
	    };
	
	    var layoutProto = Layout.prototype = Object.create( registrant.prototype );
	
	    var optLayoutFns = [];
	
	    for( var i = 0; i < optLayoutFns.length; i++ ){
	      var fnName = optLayoutFns[i];
	
	      layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
	    }
	
	    // either .start() or .run() is defined, so autogen the other
	    if( layoutProto.start && !layoutProto.run ){
	      layoutProto.run = function(){ this.start(); return this; };
	    } else if( !layoutProto.start && layoutProto.run ){
	      layoutProto.start = function(){ this.run(); return this; };
	    }
	
	    if( !layoutProto.stop ){
	      layoutProto.stop = function(){
	        var opts = this.options;
	
	        if( opts && opts.animate ){
	          var anis = this.animations;
	          for( var i = 0; i < anis.length; i++ ){
	            anis[i].stop();
	          }
	        }
	
	        this.trigger('layoutstop');
	
	        return this;
	      };
	    }
	
	    if( !layoutProto.destroy ){
	      layoutProto.destroy = function(){
	        return this;
	      };
	    }
	
	    layoutProto.on = define.on({ layout: true });
	    layoutProto.one = define.on({ layout: true, unbindSelfOnTrigger: true });
	    layoutProto.once = define.on({ layout: true, unbindAllBindersOnTrigger: true });
	    layoutProto.off = define.off({ layout: true });
	    layoutProto.trigger = define.trigger({ layout: true });
	
	    define.eventAliasesOn( layoutProto );
	
	    ext = Layout; // replace with our wrapped layout
	
	  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
	    // user registered renderers inherit from base
	
	    var bProto = getExtension( 'renderer', 'base' ).prototype;
	    var rProto = registrant.prototype;
	
	    for( var pName in bProto ){
	      var pVal = bProto[ pName ];
	      var existsInR = rProto[ pName ] != null;
	
	      if( existsInR ){
	        util.error('Can not register renderer `' + name + '` since it overrides `' + pName + '` in its prototype');
	        return;
	      }
	
	      rProto[ pName ] = pVal; // take impl from base
	    }
	
	    bProto.clientFunctions.forEach(function( name ){
	      rProto[ name ] = rProto[ name ] || function(){
	        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
	      };
	    });
	
	  }
	
	  return util.setMap({
	    map: extensions,
	    keys: [ type, name ],
	    value: ext
	  });
	}
	
	function getExtension(type, name){
	  return util.getMap({
	    map: extensions,
	    keys: [ type, name ]
	  });
	}
	
	function setModule(type, name, moduleType, moduleName, registrant){
	  return util.setMap({
	    map: modules,
	    keys: [ type, name, moduleType, moduleName ],
	    value: registrant
	  });
	}
	
	function getModule(type, name, moduleType, moduleName){
	  return util.getMap({
	    map: modules,
	    keys: [ type, name, moduleType, moduleName ]
	  });
	}
	
	var extension = function(){
	  // e.g. extension('renderer', 'svg')
	  if( arguments.length === 2 ){
	    return getExtension.apply(null, arguments);
	  }
	
	  // e.g. extension('renderer', 'svg', { ... })
	  else if( arguments.length === 3 ){
	    return setExtension.apply(null, arguments);
	  }
	
	  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
	  else if( arguments.length === 4 ){
	    return getModule.apply(null, arguments);
	  }
	
	  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
	  else if( arguments.length === 5 ){
	    return setModule.apply(null, arguments);
	  }
	
	  else {
	    util.error('Invalid extension access syntax');
	  }
	
	};
	
	// allows a core instance to access extensions internally
	Core.prototype.extension = extension;
	
	// included extensions
	incExts.forEach(function( group ){
	  group.extensions.forEach(function( ext ){
	    setExtension( group.type, ext.name, ext.impl );
	  });
	});
	
	module.exports = extension;
	
	},{"./collection":23,"./core":34,"./define":41,"./extensions":44,"./is":77,"./util":94}],44:[function(_dereq_,module,exports){
	'use strict';
	
	module.exports = [
	  {
	    type: 'layout',
	    extensions: _dereq_('./layout')
	  },
	
	  {
	    type: 'renderer',
	    extensions: _dereq_('./renderer')
	  }
	];
	
	},{"./layout":50,"./renderer":72}],45:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	var is = _dereq_('../../is');
	
	var defaults = {
	  fit: true, // whether to fit the viewport to the graph
	  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
	  padding: 30, // padding on fit
	  circle: false, // put depths in concentric circles if true, put depths top down if false
	  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
	  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
	  roots: undefined, // the roots of the trees
	  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function BreadthFirstLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	BreadthFirstLayout.prototype.run = function(){
	  var params = this.options;
	  var options = params;
	
	  var cy = params.cy;
	  var eles = options.eles;
	  var nodes = eles.nodes().not(':parent');
	  var graph = eles;
	
	  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	    x1: 0, y1: 0, w: cy.width(), h: cy.height()
	  } );
	
	  var roots;
	  if( is.elementOrCollection(options.roots) ){
	    roots = options.roots;
	  } else if( is.array(options.roots) ){
	    var rootsArray = [];
	
	    for( var i = 0; i < options.roots.length; i++ ){
	      var id = options.roots[i];
	      var ele = cy.getElementById( id );
	      rootsArray.push( ele );
	    }
	
	    roots = cy.collection( rootsArray );
	  } else if( is.string(options.roots) ){
	    roots = cy.$( options.roots );
	
	  } else {
	    if( options.directed ){
	      roots = nodes.roots();
	    } else {
	      var components = [];
	      var unhandledNodes = nodes;
	
	      while( unhandledNodes.length > 0 ){
	        var currComp = cy.collection();
	
	        eles.bfs({
	          roots: unhandledNodes[0],
	          visit: function(i, depth, node, edge, pNode){
	            currComp = currComp.add( node );
	          },
	          directed: false
	        });
	
	        unhandledNodes = unhandledNodes.not( currComp );
	        components.push( currComp );
	      }
	
	      roots = cy.collection();
	      for( var i = 0; i < components.length; i++ ){
	        var comp = components[i];
	        var maxDegree = comp.maxDegree( false );
	        var compRoots = comp.filter(function(){
	          return this.degree(false) === maxDegree;
	        });
	
	        roots = roots.add( compRoots );
	      }
	
	    }
	  }
	
	
	  var depths = [];
	  var foundByBfs = {};
	  var id2depth = {};
	  var prevNode = {};
	  var prevEdge = {};
	  var successors = {};
	
	  // find the depths of the nodes
	  graph.bfs({
	    roots: roots,
	    directed: options.directed,
	    visit: function(i, depth, node, edge, pNode){
	      var ele = this[0];
	      var id = ele.id();
	
	      if( !depths[depth] ){
	        depths[depth] = [];
	      }
	
	      depths[depth].push( ele );
	      foundByBfs[ id ] = true;
	      id2depth[ id ] = depth;
	      prevNode[ id ] = pNode;
	      prevEdge[ id ] = edge;
	
	      if( pNode ){
	        var prevId = pNode.id();
	        var succ = successors[ prevId ] = successors[ prevId ] || [];
	
	        succ.push( node );
	      }
	    }
	  });
	
	  // check for nodes not found by bfs
	  var orphanNodes = [];
	  for( var i = 0; i < nodes.length; i++ ){
	    var ele = nodes[i];
	
	    if( foundByBfs[ ele.id() ] ){
	      continue;
	    } else {
	      orphanNodes.push( ele );
	    }
	  }
	
	  // assign orphan nodes a depth from their neighborhood
	  var maxChecks = orphanNodes.length * 3;
	  var checks = 0;
	  while( orphanNodes.length !== 0 && checks < maxChecks ){
	    var node = orphanNodes.shift();
	    var neighbors = node.neighborhood().nodes();
	    var assignedDepth = false;
	
	    for( var i = 0; i < neighbors.length; i++ ){
	      var depth = id2depth[ neighbors[i].id() ];
	
	      if( depth !== undefined ){
	        depths[depth].push( node );
	        assignedDepth = true;
	        break;
	      }
	    }
	
	    if( !assignedDepth ){
	      orphanNodes.push( node );
	    }
	
	    checks++;
	  }
	
	  // assign orphan nodes that are still left to the depth of their subgraph
	  while( orphanNodes.length !== 0 ){
	    var node = orphanNodes.shift();
	    //var subgraph = graph.bfs( node ).path;
	    var assignedDepth = false;
	
	    // for( var i = 0; i < subgraph.length; i++ ){
	    //   var depth = id2depth[ subgraph[i].id() ];
	
	    //   if( depth !== undefined ){
	    //     depths[depth].push( node );
	    //     assignedDepth = true;
	    //     break;
	    //   }
	    // }
	
	    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
	      if( depths.length === 0 ){
	        depths.push([]);
	      }
	
	      depths[0].push( node );
	    }
	  }
	
	  // assign the nodes a depth and index
	  var assignDepthsToEles = function(){
	    for( var i = 0; i < depths.length; i++ ){
	      var eles = depths[i];
	
	      for( var j = 0; j < eles.length; j++ ){
	        var ele = eles[j];
	
	        ele._private.scratch.breadthfirst = {
	          depth: i,
	          index: j
	        };
	      }
	    }
	  };
	  assignDepthsToEles();
	
	
	  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
	    var edges = node.connectedEdges(function(){
	      return this.data('target') === node.id();
	    });
	    var thisInfo = node._private.scratch.breadthfirst;
	    var highestDepthOfOther = 0;
	    var highestOther;
	    for( var i = 0; i < edges.length; i++ ){
	      var edge = edges[i];
	      var otherNode = edge.source()[0];
	      var otherInfo = otherNode._private.scratch.breadthfirst;
	
	      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
	        highestDepthOfOther = otherInfo.depth;
	        highestOther = otherNode;
	      }
	    }
	
	    return highestOther;
	  };
	
	   // make maximal if so set by adjusting depths
	  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){
	
	    var nDepths = depths.length;
	    var elesToMove = [];
	    for( var i = 0; i < nDepths; i++ ){
	      var depth = depths[i];
	
	      var nDepth = depth.length;
	      for( var j = 0; j < nDepth; j++ ){
	        var ele = depth[j];
	        var info = ele._private.scratch.breadthfirst;
	        var intEle = intersectsDepth(ele);
	
	        if( intEle ){
	          info.intEle = intEle;
	          elesToMove.push( ele );
	        }
	      }
	    }
	
	    for( var i = 0; i < elesToMove.length; i++ ){
	      var ele = elesToMove[i];
	      var info = ele._private.scratch.breadthfirst;
	      var intEle = info.intEle;
	      var intInfo = intEle._private.scratch.breadthfirst;
	
	      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index
	
	      // add to end of new depth
	      var newDepth = intInfo.depth + 1;
	      while( newDepth > depths.length - 1 ){
	        depths.push([]);
	      }
	      depths[ newDepth ].push( ele );
	
	      info.depth = newDepth;
	      info.index = depths[newDepth].length - 1;
	    }
	
	    assignDepthsToEles();
	  }
	
	  // find min distance we need to leave between nodes
	  var minDistance = 0;
	  if( options.avoidOverlap ){
	    for( var i = 0; i < nodes.length; i++ ){
	      var n = nodes[i];
	      var nbb = n.boundingBox();
	      var w = nbb.w;
	      var h = nbb.h;
	
	      minDistance = Math.max(minDistance, w, h);
	    }
	    minDistance *= options.spacingFactor; // just to have some nice spacing
	  }
	
	  // get the weighted percent for an element based on its connectivity to other levels
	  var cachedWeightedPercent = {};
	  var getWeightedPercent = function( ele ){
	    if( cachedWeightedPercent[ ele.id() ] ){
	      return cachedWeightedPercent[ ele.id() ];
	    }
	
	    var eleDepth = ele._private.scratch.breadthfirst.depth;
	    var neighbors = ele.neighborhood().nodes().not(':parent');
	    var percent = 0;
	    var samples = 0;
	
	    for( var i = 0; i < neighbors.length; i++ ){
	      var neighbor = neighbors[i];
	      var bf = neighbor._private.scratch.breadthfirst;
	      var index = bf.index;
	      var depth = bf.depth;
	      var nDepth = depths[depth].length;
	
	      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
	        percent += index / nDepth;
	        samples++;
	      }
	    }
	
	    samples = Math.max(1, samples);
	    percent = percent / samples;
	
	    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
	      percent = undefined;
	    }
	
	    cachedWeightedPercent[ ele.id() ] = percent;
	    return percent;
	  };
	
	
	  // rearrange the indices in each depth level based on connectivity
	
	  var sortFn = function(a, b){
	    var apct = getWeightedPercent( a );
	    var bpct = getWeightedPercent( b );
	
	    return apct - bpct;
	  };
	
	  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result
	
	    for( var i = 0; i < depths.length; i++ ){
	      depths[i] = depths[i].sort( sortFn );
	    }
	    assignDepthsToEles(); // and update
	
	  }
	
	  var biggestDepthSize = 0;
	  for( var i = 0; i < depths.length; i++ ){
	    biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
	  }
	
	  var center = {
	    x: bb.x1 + bb.w/2,
	    y: bb.x1 + bb.h/2
	  };
	
	  var getPosition = function( ele, isBottomDepth ){
	    var info = ele._private.scratch.breadthfirst;
	    var depth = info.depth;
	    var index = info.index;
	    var depthSize = depths[depth].length;
	
	    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
	    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
	    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
	    radiusStepSize = Math.max( radiusStepSize, minDistance );
	
	    if( !options.circle ){
	
	      var epos = {
	        x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
	        y: (depth + 1) * distanceY
	      };
	
	      if( isBottomDepth ){
	        return epos;
	      }
	
	      // var succs = successors[ ele.id() ];
	      // if( succs ){
	      //   epos.x = 0;
	      //
	      //   for( var i = 0 ; i < succs.length; i++ ){
	      //     var spos = pos[ succs[i].id() ];
	      //
	      //     epos.x += spos.x;
	      //   }
	      //
	      //   epos.x /= succs.length;
	      // } else {
	      //   //debugger;
	      // }
	
	      return epos;
	
	    } else {
	      if( options.circle ){
	        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
	        var theta = 2 * Math.PI / depths[depth].length * index;
	
	        if( depth === 0 && depths[0].length === 1 ){
	          radius = 1;
	        }
	
	        return {
	          x: center.x + radius * Math.cos(theta),
	          y: center.y + radius * Math.sin(theta)
	        };
	
	      } else {
	        return {
	          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
	          y: (depth + 1) * distanceY
	        };
	      }
	    }
	
	  };
	
	  // get positions in reverse depth order
	  var pos = {};
	  for( var i = depths.length - 1; i >=0; i-- ){
	    var depth = depths[i];
	
	    for( var j = 0; j < depth.length; j++ ){
	      var node = depth[j];
	
	      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
	    }
	  }
	
	  nodes.layoutPositions(this, options, function(){
	    return pos[ this.id() ];
	  });
	
	  return this; // chaining
	};
	
	module.exports = BreadthFirstLayout;
	
	},{"../../is":77,"../../math":79,"../../util":94}],46:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	var is = _dereq_('../../is');
	
	var defaults = {
	  fit: true, // whether to fit the viewport to the graph
	  padding: 30, // the padding on fit
	  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
	  radius: undefined, // the radius of the circle
	  startAngle: 3/2 * Math.PI, // where nodes start in radians
	  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
	  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
	  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function CircleLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	CircleLayout.prototype.run = function(){
	  var params = this.options;
	  var options = params;
	
	  var cy = params.cy;
	  var eles = options.eles;
	
	  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
	
	  var nodes = eles.nodes().not(':parent');
	
	  if( options.sort ){
	    nodes = nodes.sort( options.sort );
	  }
	
	  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	    x1: 0, y1: 0, w: cy.width(), h: cy.height()
	  } );
	
	  var center = {
	    x: bb.x1 + bb.w/2,
	    y: bb.y1 + bb.h/2
	  };
	
	  var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/nodes.length : options.sweep;
	
	  var dTheta = sweep / ( Math.max(1, nodes.length - 1) );
	  var r;
	
	  var minDistance = 0;
	  for( var i = 0; i < nodes.length; i++ ){
	    var n = nodes[i];
	    var nbb = n.boundingBox();
	    var w = nbb.w;
	    var h = nbb.h;
	
	    minDistance = Math.max(minDistance, w, h);
	  }
	
	  if( is.number(options.radius) ){
	    r = options.radius;
	  } else if( nodes.length <= 1 ){
	    r = 0;
	  } else {
	    r = Math.min( bb.h, bb.w )/2 - minDistance;
	  }
	
	  // calculate the radius
	  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
	    minDistance *= 1.75; // just to have some nice spacing
	
	    var dcos = Math.cos(dTheta) - Math.cos(0);
	    var dsin = Math.sin(dTheta) - Math.sin(0);
	    var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
	    r = Math.max( rMin, r );
	  }
	
	  var getPos = function( i, ele ){
	    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );
	
	    var rx = r * Math.cos( theta );
	    var ry = r * Math.sin( theta );
	    var pos = {
	      x: center.x + rx,
	      y: center.y + ry
	    };
	
	    return pos;
	  };
	
	  nodes.layoutPositions( this, options, getPos );
	
	  return this; // chaining
	};
	
	module.exports = CircleLayout;
	
	},{"../../is":77,"../../math":79,"../../util":94}],47:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	
	var defaults = {
	  fit: true, // whether to fit the viewport to the graph
	  padding: 30, // the padding on fit
	  startAngle: 3/2 * Math.PI, // where nodes start in radians
	  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
	  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
	  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
	  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
	  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
	  height: undefined, // height of layout area (overrides container height)
	  width: undefined, // width of layout area (overrides container width)
	  concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
	    return node.degree();
	  },
	  levelWidth: function(nodes){ // the variation of concentric values in each level
	    return nodes.maxDegree() / 4;
	  },
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function ConcentricLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	ConcentricLayout.prototype.run = function(){
	  var params = this.options;
	  var options = params;
	
	  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
	
	  var cy = params.cy;
	
	  var eles = options.eles;
	  var nodes = eles.nodes().not(':parent');
	
	  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	    x1: 0, y1: 0, w: cy.width(), h: cy.height()
	  } );
	
	  var center = {
	    x: bb.x1 + bb.w/2,
	    y: bb.y1 + bb.h/2
	  };
	
	  var nodeValues = []; // { node, value }
	  var theta = options.startAngle;
	  var maxNodeSize = 0;
	
	  for( var i = 0; i < nodes.length; i++ ){
	    var node = nodes[i];
	    var value;
	
	    // calculate the node value
	    value = options.concentric.apply(node, [ node ]);
	    nodeValues.push({
	      value: value,
	      node: node
	    });
	
	    // for style mapping
	    node._private.scratch.concentric = value;
	  }
	
	  // in case we used the `concentric` in style
	  nodes.updateStyle();
	
	  // calculate max size now based on potentially updated mappers
	  for( var i = 0; i < nodes.length; i++ ){
	    var node = nodes[i];
	    var nbb = node.boundingBox();
	
	    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
	  }
	
	  // sort node values in descreasing order
	  nodeValues.sort(function(a, b){
	    return b.value - a.value;
	  });
	
	  var levelWidth = options.levelWidth( nodes );
	
	  // put the values into levels
	  var levels = [ [] ];
	  var currentLevel = levels[0];
	  for( var i = 0; i < nodeValues.length; i++ ){
	    var val = nodeValues[i];
	
	    if( currentLevel.length > 0 ){
	      var diff = Math.abs( currentLevel[0].value - val.value );
	
	      if( diff >= levelWidth ){
	        currentLevel = [];
	        levels.push( currentLevel );
	      }
	    }
	
	    currentLevel.push( val );
	  }
	
	  // create positions from levels
	
	  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes
	
	  if( !options.avoidOverlap ){ // then strictly constrain to bb
	    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
	    var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
	    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );
	
	    minDist = Math.min( minDist, rStep );
	  }
	
	  // find the metrics for each level
	  var r = 0;
	  for( var i = 0; i < levels.length; i++ ){
	    var level = levels[i];
	    var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/level.length : options.sweep;
	    var dTheta = level.dTheta = sweep / ( Math.max(1, level.length - 1) );
	
	    // calculate the radius
	    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
	      var dcos = Math.cos(dTheta) - Math.cos(0);
	      var dsin = Math.sin(dTheta) - Math.sin(0);
	      var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
	
	      r = Math.max( rMin, r );
	    }
	
	    level.r = r;
	
	    r += minDist;
	  }
	
	  if( options.equidistant ){
	    var rDeltaMax = 0;
	    var r = 0;
	
	    for( var i = 0; i < levels.length; i++ ){
	      var level = levels[i];
	      var rDelta = level.r - r;
	
	      rDeltaMax = Math.max( rDeltaMax, rDelta );
	    }
	
	    r = 0;
	    for( var i = 0; i < levels.length; i++ ){
	      var level = levels[i];
	
	      if( i === 0 ){
	        r = level.r;
	      }
	
	      level.r = r;
	
	      r += rDeltaMax;
	    }
	  }
	
	  // calculate the node positions
	  var pos = {}; // id => position
	  for( var i = 0; i < levels.length; i++ ){
	    var level = levels[i];
	    var dTheta = level.dTheta;
	    var r = level.r;
	
	    for( var j = 0; j < level.length; j++ ){
	      var val = level[j];
	      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;
	
	      var p = {
	        x: center.x + r * Math.cos(theta),
	        y: center.y + r * Math.sin(theta)
	      };
	
	      pos[ val.node.id() ] = p;
	    }
	  }
	
	  // position the nodes
	  nodes.layoutPositions(this, options, function(){
	    var id = this.id();
	
	    return pos[id];
	  });
	
	  return this; // chaining
	};
	
	module.exports = ConcentricLayout;
	
	},{"../../math":79,"../../util":94}],48:[function(_dereq_,module,exports){
	'use strict';
	
	/*
	The CoSE layout was written by Gerardo Huck.
	https://www.linkedin.com/in/gerardohuck/
	
	Based on the following article:
	http://dl.acm.org/citation.cfm?id=1498047
	
	Modifications tracked on Github.
	*/
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	var Thread = _dereq_('../../thread');
	var is = _dereq_('../../is');
	
	var DEBUG;
	
	/**
	 * @brief :  default layout options
	 */
	var defaults = {
	  // Called on `layoutready`
	  ready               : function() {},
	
	  // Called on `layoutstop`
	  stop                : function() {},
	
	  // Whether to animate while running the layout
	  animate             : true,
	
	  // The layout animates only after this many milliseconds
	  // (prevents flashing on fast runs)
	  animationThreshold  : 250,
	
	  // Number of iterations between consecutive screen positions update
	  // (0 -> only updated on the end)
	  refresh             : 20,
	
	  // Whether to fit the network view after when done
	  fit                 : true,
	
	  // Padding on fit
	  padding             : 30,
	
	  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  boundingBox         : undefined,
	
	  // Extra spacing between components in non-compound graphs
	  componentSpacing    : 100,
	
	  // Node repulsion (non overlapping) multiplier
	  nodeRepulsion       : function( node ){ return 400000; },
	
	  // Node repulsion (overlapping) multiplier
	  nodeOverlap         : 10,
	
	  // Ideal edge (non nested) length
	  idealEdgeLength     : function( edge ){ return 10; },
	
	  // Divisor to compute edge forces
	  edgeElasticity      : function( edge ){ return 100; },
	
	  // Nesting factor (multiplier) to compute ideal edge length for nested edges
	  nestingFactor       : 5,
	
	  // Gravity force (constant)
	  gravity             : 80,
	
	  // Maximum number of iterations to perform
	  numIter             : 1000,
	
	  // Initial temperature (maximum node displacement)
	  initialTemp         : 200,
	
	  // Cooling factor (how the temperature is reduced between consecutive iterations
	  coolingFactor       : 0.95,
	
	  // Lower temperature threshold (below this point the layout will end)
	  minTemp             : 1.0,
	
	  // Whether to use threading to speed up the layout
	  useMultitasking     : true
	};
	
	
	/**
	 * @brief       : constructor
	 * @arg options : object containing layout options
	 */
	function CoseLayout(options) {
	  this.options = util.extend({}, defaults, options);
	
	  this.options.layout = this;
	}
	
	
	/**
	 * @brief : runs the layout
	 */
	CoseLayout.prototype.run = function() {
	  var options = this.options;
	  var cy      = options.cy;
	  var layout  = this;
	  var thread  = this.thread;
	
	  if( !thread || thread.stopped() ){
	    thread = this.thread = Thread({ disabled: !options.useMultitasking });
	  }
	
	  layout.stopped = false;
	
	  layout.trigger({ type: 'layoutstart', layout: layout });
	
	  // Set DEBUG - Global variable
	  if (true === options.debug) {
	    DEBUG = true;
	  } else {
	    DEBUG = false;
	  }
	
	  // Initialize layout info
	  var layoutInfo = createLayoutInfo(cy, layout, options);
	
	  // Show LayoutInfo contents if debugging
	  if (DEBUG) {
	    printLayoutInfo(layoutInfo);
	  }
	
	  // If required, randomize node positions
	  // if (true === options.randomize) {
	    randomizePositions(layoutInfo, cy);
	  // }
	
	  var startTime = Date.now();
	  var refreshRequested = false;
	  var refresh = function( rOpts ){
	    rOpts = rOpts || {};
	
	    if( refreshRequested ){
	      return;
	    }
	
	    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
	      return;
	    }
	
	    refreshRequested = true;
	
	    util.requestAnimationFrame(function(){
	      refreshPositions(layoutInfo, cy, options);
	
	      // Fit the graph if necessary
	      if (true === options.fit) {
	        cy.fit( options.padding );
	      }
	
	      refreshRequested = false;
	
	      if( rOpts.next ){ rOpts.next(); }
	    });
	  };
	
	  thread.on('message', function( e ){
	    var layoutNodes = e.message;
	
	    layoutInfo.layoutNodes = layoutNodes;
	    refresh();
	  });
	
	  thread.pass({
	    layoutInfo: layoutInfo,
	    options: {
	      animate: options.animate,
	      refresh: options.refresh,
	      componentSpacing: options.componentSpacing,
	      nodeOverlap: options.nodeOverlap,
	      nestingFactor: options.nestingFactor,
	      gravity: options.gravity,
	      numIter: options.numIter,
	      initialTemp: options.initialTemp,
	      coolingFactor: options.coolingFactor,
	      minTemp: options.minTemp
	    }
	  }).run(function( pass ){
	    var layoutInfo = pass.layoutInfo;
	    var options = pass.options;
	    var stopped = false;
	
	    /**
	     * @brief          : Performs one iteration of the physical simulation
	     * @arg layoutInfo : LayoutInfo object already initialized
	     * @arg cy         : Cytoscape object
	     * @arg options    : Layout options
	     */
	    var step = function(layoutInfo, options, step) {
	      // var s = "\n\n###############################";
	      // s += "\nSTEP: " + step;
	      // s += "\n###############################\n";
	      // logDebug(s);
	
	      // Calculate node repulsions
	      calculateNodeForces(layoutInfo, options);
	      // Calculate edge forces
	      calculateEdgeForces(layoutInfo, options);
	      // Calculate gravity forces
	      calculateGravityForces(layoutInfo, options);
	      // Propagate forces from parent to child
	      propagateForces(layoutInfo, options);
	      // Update positions based on calculated forces
	      updatePositions(layoutInfo, options);
	    };
	
	    /**
	     * @brief : Computes the node repulsion forces
	     */
	    var calculateNodeForces = function(layoutInfo, options) {
	      // Go through each of the graphs in graphSet
	      // Nodes only repel each other if they belong to the same graph
	      // var s = 'calculateNodeForces';
	      // logDebug(s);
	      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
	        var graph    = layoutInfo.graphSet[i];
	        var numNodes = graph.length;
	
	        // s = "Set: " + graph.toString();
	        // logDebug(s);
	
	        // Now get all the pairs of nodes
	        // Only get each pair once, (A, B) = (B, A)
	        for (var j = 0; j < numNodes; j++) {
	          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
	
	          for (var k = j + 1; k < numNodes; k++) {
	            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
	
	            nodeRepulsion(node1, node2, layoutInfo, options);
	          }
	        }
	      }
	    };
	
	    /**
	     * @brief : Compute the node repulsion forces between a pair of nodes
	     */
	    var nodeRepulsion = function(node1, node2, layoutInfo, options) {
	      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
	
	      var cmptId1 = node1.cmptId;
	      var cmptId2 = node2.cmptId;
	
	      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }
	
	      // Get direction of line connecting both node centers
	      var directionX = node2.positionX - node1.positionX;
	      var directionY = node2.positionY - node1.positionY;
	      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
	
	      // If both centers are the same, apply a random force
	      if (0 === directionX && 0 === directionY) {
	        // s += "\nNodes have the same position.";
	        return; // TODO could be improved with random force
	      }
	
	      var overlap = nodesOverlap(node1, node2, directionX, directionY);
	
	      if (overlap > 0) {
	        // s += "\nNodes DO overlap.";
	        // s += "\nOverlap: " + overlap;
	        // If nodes overlap, repulsion force is proportional
	        // to the overlap
	        var force    = options.nodeOverlap * overlap;
	
	        // Compute the module and components of the force vector
	        var distance = Math.sqrt(directionX * directionX + directionY * directionY);
	        // s += "\nDistance: " + distance;
	        var forceX   = force * directionX / distance;
	        var forceY   = force * directionY / distance;
	
	      } else {
	        // s += "\nNodes do NOT overlap.";
	        // If there's no overlap, force is inversely proportional
	        // to squared distance
	
	        // Get clipping points for both nodes
	        var point1 = findClippingPoint(node1, directionX, directionY);
	        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);
	
	        // Use clipping points to compute distance
	        var distanceX   = point2.x - point1.x;
	        var distanceY   = point2.y - point1.y;
	        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
	        var distance    = Math.sqrt(distanceSqr);
	        // s += "\nDistance: " + distance;
	
	        // Compute the module and components of the force vector
	        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
	        var forceX = force * distanceX / distance;
	        var forceY = force * distanceY / distance;
	      }
	
	      // Apply force
	      if( !node1.isLocked ){
	        node1.offsetX -= forceX;
	        node1.offsetY -= forceY;
	      }
	
	      if( !node2.isLocked ){
	        node2.offsetX += forceX;
	        node2.offsetY += forceY;
	      }
	
	      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
	      // logDebug(s);
	
	      return;
	    };
	
	    /**
	     * @brief  : Determines whether two nodes overlap or not
	     * @return : Amount of overlapping (0 => no overlap)
	     */
	    var nodesOverlap = function(node1, node2, dX, dY) {
	
	      if (dX > 0) {
	        var overlapX = node1.maxX - node2.minX;
	      } else {
	        var overlapX = node2.maxX - node1.minX;
	      }
	
	      if (dY > 0) {
	        var overlapY = node1.maxY - node2.minY;
	      } else {
	        var overlapY = node2.maxY - node1.minY;
	      }
	
	      if (overlapX >= 0 && overlapY >= 0) {
	        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
	      } else {
	        return 0;
	      }
	    };
	
	    /**
	     * @brief : Finds the point in which an edge (direction dX, dY) intersects
	     *          the rectangular bounding box of it's source/target node
	     */
	    var findClippingPoint = function(node, dX, dY) {
	
	      // Shorcuts
	      var X = node.positionX;
	      var Y = node.positionY;
	      var H = node.height || 1;
	      var W = node.width || 1;
	      var dirSlope     = dY / dX;
	      var nodeSlope    = H / W;
	
	      // var s = 'Computing clipping point of node ' + node.id +
	      //   " . Height:  " + H + ", Width: " + W +
	      //   "\nDirection " + dX + ", " + dY;
	      //
	      // Compute intersection
	      var res = {};
	      do {
	        // Case: Vertical direction (up)
	        if (0 === dX && 0 < dY) {
	          res.x = X;
	          // s += "\nUp direction";
	          res.y = Y + H / 2;
	          break;
	        }
	
	        // Case: Vertical direction (down)
	        if (0 === dX && 0 > dY) {
	          res.x = X;
	          res.y = Y + H / 2;
	          // s += "\nDown direction";
	          break;
	        }
	
	        // Case: Intersects the right border
	        if (0 < dX &&
	        -1 * nodeSlope <= dirSlope &&
	        dirSlope <= nodeSlope) {
	          res.x = X + W / 2;
	          res.y = Y + (W * dY / 2 / dX);
	          // s += "\nRightborder";
	          break;
	        }
	
	        // Case: Intersects the left border
	        if (0 > dX &&
	        -1 * nodeSlope <= dirSlope &&
	        dirSlope <= nodeSlope) {
	          res.x = X - W / 2;
	          res.y = Y - (W * dY / 2 / dX);
	          // s += "\nLeftborder";
	          break;
	        }
	
	        // Case: Intersects the top border
	        if (0 < dY &&
	        ( dirSlope <= -1 * nodeSlope ||
	          dirSlope >= nodeSlope )) {
	          res.x = X + (H * dX / 2 / dY);
	          res.y = Y + H / 2;
	          // s += "\nTop border";
	          break;
	        }
	
	        // Case: Intersects the bottom border
	        if (0 > dY &&
	        ( dirSlope <= -1 * nodeSlope ||
	          dirSlope >= nodeSlope )) {
	          res.x = X - (H * dX / 2 / dY);
	          res.y = Y - H / 2;
	          // s += "\nBottom border";
	          break;
	        }
	
	      } while (false);
	
	      // s += "\nClipping point found at " + res.x + ", " + res.y;
	      // logDebug(s);
	      return res;
	    };
	
	    /**
	     * @brief : Calculates all edge forces
	     */
	    var calculateEdgeForces = function(layoutInfo, options) {
	      // Iterate over all edges
	      for (var i = 0; i < layoutInfo.edgeSize; i++) {
	        // Get edge, source & target nodes
	        var edge     = layoutInfo.layoutEdges[i];
	        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
	        var source   = layoutInfo.layoutNodes[sourceIx];
	        var targetIx = layoutInfo.idToIndex[edge.targetId];
	        var target   = layoutInfo.layoutNodes[targetIx];
	
	        // Get direction of line connecting both node centers
	        var directionX = target.positionX - source.positionX;
	        var directionY = target.positionY - source.positionY;
	
	        // If both centers are the same, do nothing.
	        // A random force has already been applied as node repulsion
	        if (0 === directionX && 0 === directionY) {
	        return;
	        }
	
	        // Get clipping points for both nodes
	        var point1 = findClippingPoint(source, directionX, directionY);
	        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
	
	
	        var lx = point2.x - point1.x;
	        var ly = point2.y - point1.y;
	        var l  = Math.sqrt(lx * lx + ly * ly);
	
	        var force  = Math.pow(edge.idealLength - l, 2) / edge.elasticity;
	
	        if (0 !== l) {
	          var forceX = force * lx / l;
	          var forceY = force * ly / l;
	        } else {
	          var forceX = 0;
	          var forceY = 0;
	        }
	
	        // Add this force to target and source nodes
	        if( !source.isLocked ){
	          source.offsetX += forceX;
	          source.offsetY += forceY;
	        }
	
	        if( !target.isLocked ){
	          target.offsetX -= forceX;
	          target.offsetY -= forceY;
	        }
	
	        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
	        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
	        // logDebug(s);
	      }
	    };
	
	    /**
	     * @brief : Computes gravity forces for all nodes
	     */
	    var calculateGravityForces = function(layoutInfo, options) {
	      var distThreshold = 1;
	
	      // var s = 'calculateGravityForces';
	      // logDebug(s);
	      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
	        var graph    = layoutInfo.graphSet[i];
	        var numNodes = graph.length;
	
	        // s = "Set: " + graph.toString();
	        // logDebug(s);
	
	        // Compute graph center
	        if (0 === i) {
	          var centerX   = layoutInfo.clientHeight / 2;
	          var centerY   = layoutInfo.clientWidth  / 2;
	        } else {
	          // Get Parent node for this graph, and use its position as center
	          var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
	          var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
	          var centerX = parent.positionX;
	          var centerY = parent.positionY;
	        }
	        // s = "Center found at: " + centerX + ", " + centerY;
	        // logDebug(s);
	
	        // Apply force to all nodes in graph
	        for (var j = 0; j < numNodes; j++) {
	          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
	          // s = "Node: " + node.id;
	
	          if( node.isLocked ){ continue; }
	
	          var dx = centerX - node.positionX;
	          var dy = centerY - node.positionY;
	          var d  = Math.sqrt(dx * dx + dy * dy);
	          if (d > distThreshold) {
	            var fx = options.gravity * dx / d;
	            var fy = options.gravity * dy / d;
	            node.offsetX += fx;
	            node.offsetY += fy;
	            // s += ": Applied force: " + fx + ", " + fy;
	          } else {
	            // s += ": skypped since it's too close to center";
	          }
	          // logDebug(s);
	        }
	      }
	    };
	
	    /**
	     * @brief          : This function propagates the existing offsets from
	     *                   parent nodes to its descendents.
	     * @arg layoutInfo : layoutInfo Object
	     * @arg cy         : cytoscape Object
	     * @arg options    : Layout options
	     */
	    var propagateForces = function(layoutInfo, options) {
	      // Inline implementation of a queue, used for traversing the graph in BFS order
	      var queue = [];
	      var start = 0;   // Points to the start the queue
	      var end   = -1;  // Points to the end of the queue
	
	      // logDebug('propagateForces');
	
	      // Start by visiting the nodes in the root graph
	      queue.push.apply(queue, layoutInfo.graphSet[0]);
	      end += layoutInfo.graphSet[0].length;
	
	      // Traverse the graph, level by level,
	      while (start <= end) {
	        // Get the node to visit and remove it from queue
	        var nodeId    = queue[start++];
	        var nodeIndex = layoutInfo.idToIndex[nodeId];
	        var node      = layoutInfo.layoutNodes[nodeIndex];
	        var children  = node.children;
	
	        // We only need to process the node if it's compound
	        if (0 < children.length && !node.isLocked) {
	          var offX = node.offsetX;
	          var offY = node.offsetY;
	
	          // var s = "Propagating offset from parent node : " + node.id +
	          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
	          // s += "\n Children: " + children.toString();
	          // logDebug(s);
	
	          for (var i = 0; i < children.length; i++) {
	            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
	            // Propagate offset
	            childNode.offsetX += offX;
	            childNode.offsetY += offY;
	            // Add children to queue to be visited
	            queue[++end] = children[i];
	          }
	
	          // Reset parent offsets
	          node.offsetX = 0;
	          node.offsetY = 0;
	        }
	
	      }
	    };
	
	    /**
	     * @brief : Updates the layout model positions, based on
	     *          the accumulated forces
	     */
	    var updatePositions = function(layoutInfo, options) {
	      // var s = 'Updating positions';
	      // logDebug(s);
	
	      // Reset boundaries for compound nodes
	      for (var i = 0; i < layoutInfo.nodeSize; i++) {
	        var n = layoutInfo.layoutNodes[i];
	        if (0 < n.children.length) {
	          // logDebug("Resetting boundaries of compound node: " + n.id);
	          n.maxX = undefined;
	          n.minX = undefined;
	          n.maxY = undefined;
	          n.minY = undefined;
	        }
	      }
	
	      for (var i = 0; i < layoutInfo.nodeSize; i++) {
	        var n = layoutInfo.layoutNodes[i];
	        if (0 < n.children.length || n.isLocked) {
	          // No need to set compound or locked node position
	          // logDebug("Skipping position update of node: " + n.id);
	          continue;
	        }
	        // s = "Node: " + n.id + " Previous position: (" +
	        // n.positionX + ", " + n.positionY + ").";
	
	        // Limit displacement in order to improve stability
	        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
	        n.positionX += tempForce.x;
	        n.positionY += tempForce.y;
	        n.offsetX = 0;
	        n.offsetY = 0;
	        n.minX    = n.positionX - n.width;
	        n.maxX    = n.positionX + n.width;
	        n.minY    = n.positionY - n.height;
	        n.maxY    = n.positionY + n.height;
	        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
	        // logDebug(s);
	
	        // Update ancestry boudaries
	        updateAncestryBoundaries(n, layoutInfo);
	      }
	
	      // Update size, position of compund nodes
	      for (var i = 0; i < layoutInfo.nodeSize; i++) {
	        var n = layoutInfo.layoutNodes[i];
	        if ( 0 < n.children.length && !n.isLocked ) {
	          n.positionX = (n.maxX + n.minX) / 2;
	          n.positionY = (n.maxY + n.minY) / 2;
	          n.width     = n.maxX - n.minX;
	          n.height    = n.maxY - n.minY;
	          // s = "Updating position, size of compound node " + n.id;
	          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
	          // s += "\nWidth: " + n.width + ", Height: " + n.height;
	          // logDebug(s);
	        }
	      }
	    };
	
	    /**
	     * @brief : Limits a force (forceX, forceY) to be not
	     *          greater (in modulo) than max.
	     8          Preserves force direction.
	     */
	    var limitForce = function(forceX, forceY, max) {
	      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
	      var force = Math.sqrt(forceX * forceX + forceY * forceY);
	
	      if (force > max) {
	        var res = {
	        x : max * forceX / force,
	        y : max * forceY / force
	        };
	
	      } else {
	        var res = {
	        x : forceX,
	        y : forceY
	        };
	      }
	
	      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
	      // logDebug(s);
	
	      return res;
	    };
	
	    /**
	     * @brief : Function used for keeping track of compound node
	     *          sizes, since they should bound all their subnodes.
	     */
	    var updateAncestryBoundaries = function(node, layoutInfo) {
	      // var s = "Propagating new position/size of node " + node.id;
	      var parentId = node.parentId;
	      if (null == parentId) {
	        // If there's no parent, we are done
	        // s += ". No parent node.";
	        // logDebug(s);
	        return;
	      }
	
	      // Get Parent Node
	      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
	      var flag = false;
	
	      // MaxX
	      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
	        p.maxX = node.maxX + p.padRight;
	        flag = true;
	        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
	      }
	
	      // MinX
	      if (null == p.minX || node.minX - p.padLeft < p.minX) {
	        p.minX = node.minX - p.padLeft;
	        flag = true;
	        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
	      }
	
	      // MaxY
	      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
	        p.maxY = node.maxY + p.padBottom;
	        flag = true;
	        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
	      }
	
	      // MinY
	      if (null == p.minY || node.minY - p.padTop < p.minY) {
	        p.minY = node.minY - p.padTop;
	        flag = true;
	        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
	      }
	
	      // If updated boundaries, propagate changes upward
	      if (flag) {
	        // logDebug(s);
	        return updateAncestryBoundaries(p, layoutInfo);
	      }
	
	      // s += ". No changes in boundaries/position of parent node " + p.id;
	      // logDebug(s);
	      return;
	    };
	
	    var separateComponents = function(layutInfo, options){
	      var nodes = layoutInfo.layoutNodes;
	      var components = [];
	
	      for( var i = 0; i < nodes.length; i++ ){
	        var node = nodes[i];
	        var cid = node.cmptId;
	        var component = components[ cid ] = components[ cid ] || [];
	
	        component.push( node );
	      }
	
	      var totalA = 0;
	
	      for( var i = 0; i < components.length; i++ ){
	        var c = components[i];
	        c.x1 = Infinity;
	        c.x2 = -Infinity;
	        c.y1 = Infinity;
	        c.y2 = -Infinity;
	
	        for( var j = 0; j < c.length; j++ ){
	          var n = c[j];
	
	          c.x1 = Math.min( c.x1, n.positionX - n.width/2 );
	          c.x2 = Math.max( c.x2, n.positionX + n.width/2 );
	          c.y1 = Math.min( c.y1, n.positionY - n.height/2 );
	          c.y2 = Math.max( c.y2, n.positionY + n.height/2 );
	        }
	
	        c.w = c.x2 - c.x1;
	        c.h = c.y2 - c.y1;
	
	        totalA += c.w * c.h;
	      }
	
	      components.sort(function( c1, c2 ){
	        return c2.w*c2.h - c1.w*c1.h;
	      });
	
	      var x = 0;
	      var y = 0;
	      var usedW = 0;
	      var rowH = 0;
	      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;
	
	      for( var i = 0; i < components.length; i++ ){
	        var c = components[i];
	
	        for( var j = 0; j < c.length; j++ ){
	          var n = c[j];
	
	          if( !n.isLocked ){
	            n.positionX += x;
	            n.positionY += y;
	          }
	        }
	
	        x += c.w + options.componentSpacing;
	        usedW += c.w + options.componentSpacing;
	        rowH = Math.max( rowH, c.h );
	
	        if( usedW > maxRowW ){
	          y += rowH + options.componentSpacing;
	          x = 0;
	          usedW = 0;
	          rowH = 0;
	        }
	      }
	    };
	
	    var mainLoop = function(i){
	      if( stopped ){
	        // logDebug("Layout manually stopped. Stopping computation in step " + i);
	        return false;
	      }
	
	      // Do one step in the phisical simulation
	      step(layoutInfo, options, i);
	
	      // Update temperature
	      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
	      // logDebug("New temperature: " + layoutInfo.temperature);
	
	      if (layoutInfo.temperature < options.minTemp) {
	        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
	        return false;
	      }
	
	      return true;
	    };
	
	    var i = 0;
	    var loopRet;
	
	    do {
	      var f = 0;
	
	      while( f < options.refresh && i < options.numIter ){
	        var loopRet = mainLoop(i);
	        if( !loopRet ){ break; }
	
	        f++;
	        i++;
	      }
	
	      if( options.animate ){
	        broadcast( layoutInfo.layoutNodes ); // jshint ignore:line
	      }
	
	    } while ( loopRet && i + 1 < options.numIter );
	
	    separateComponents( layoutInfo, options );
	
	    return layoutInfo;
	  }).then(function( layoutInfoUpdated ){
	    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions
	
	    thread.stop();
	    done();
	  });
	
	  var done = function(){
	    refresh({ 
	      force: true,
	      next: function(){
	        // Layout has finished
	        layout.one('layoutstop', options.stop);
	        layout.trigger({ type: 'layoutstop', layout: layout });
	      }
	    });
	  };
	
	  return this; // chaining
	};
	
	
	/**
	 * @brief : called on continuous layouts to stop them before they finish
	 */
	CoseLayout.prototype.stop = function(){
	  this.stopped = true;
	
	  if( this.thread ){
	    this.thread.stop();
	  }
	
	  this.trigger('layoutstop');
	
	  return this; // chaining
	};
	
	CoseLayout.prototype.destroy = function(){
	  if( this.thread ){
	    this.thread.stop();
	  }
	
	  return this; // chaining
	};
	
	
	/**
	 * @brief     : Creates an object which is contains all the data
	 *              used in the layout process
	 * @arg cy    : cytoscape.js object
	 * @return    : layoutInfo object initialized
	 */
	var createLayoutInfo = function(cy, layout, options) {
	  // Shortcut
	  var edges = options.eles.edges();
	  var nodes = options.eles.nodes();
	
	  var layoutInfo   = {
	    isCompound   : cy.hasCompoundNodes(),
	    layoutNodes  : [],
	    idToIndex    : {},
	    nodeSize     : nodes.size(),
	    graphSet     : [],
	    indexToGraph : [],
	    layoutEdges  : [],
	    edgeSize     : edges.size(),
	    temperature  : options.initialTemp,
	    clientWidth  : cy.width(),
	    clientHeight : cy.width(),
	    boundingBox  : math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
	                   } )
	  };
	
	  var components = options.eles.components();
	  var id2cmptId = {};
	
	  for( var i = 0; i < components.length; i++ ){
	    var component = components[i];
	
	    for( var j = 0; j < component.length; j++ ){
	      var node = component[j];
	
	      id2cmptId[ node.id() ] = i;
	    }
	  }
	
	  // Iterate over all nodes, creating layout nodes
	  for (var i = 0; i < layoutInfo.nodeSize; i++) {
	    var n = nodes[i];
	    var nbb = n.boundingBox();
	
	    var tempNode        = {};
	    tempNode.isLocked   = n.locked();
	    tempNode.id         = n.data('id');
	    tempNode.parentId   = n.data('parent');
	    tempNode.cmptId     = id2cmptId[ n.id() ];
	    tempNode.children   = [];
	    tempNode.positionX  = n.position('x');
	    tempNode.positionY  = n.position('y');
	    tempNode.offsetX    = 0;
	    tempNode.offsetY    = 0;
	    tempNode.height     = nbb.w;
	    tempNode.width      = nbb.h;
	    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
	    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
	    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
	    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
	    tempNode.padLeft    = parseFloat( n.style('padding-left') );
	    tempNode.padRight   = parseFloat( n.style('padding-right') );
	    tempNode.padTop     = parseFloat( n.style('padding-top') );
	    tempNode.padBottom  = parseFloat( n.style('padding-bottom') );
	
	    // forces
	    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;
	
	    // Add new node
	    layoutInfo.layoutNodes.push(tempNode);
	    // Add entry to id-index map
	    layoutInfo.idToIndex[tempNode.id] = i;
	  }
	
	  // Inline implementation of a queue, used for traversing the graph in BFS order
	  var queue = [];
	  var start = 0;   // Points to the start the queue
	  var end   = -1;  // Points to the end of the queue
	
	  var tempGraph = [];
	
	  // Second pass to add child information and
	  // initialize queue for hierarchical traversal
	  for (var i = 0; i < layoutInfo.nodeSize; i++) {
	    var n = layoutInfo.layoutNodes[i];
	    var p_id = n.parentId;
	    // Check if node n has a parent node
	    if (null != p_id) {
	    // Add node Id to parent's list of children
	    layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
	    } else {
	    // If a node doesn't have a parent, then it's in the root graph
	    queue[++end] = n.id;
	    tempGraph.push(n.id);
	    }
	  }
	
	  // Add root graph to graphSet
	  layoutInfo.graphSet.push(tempGraph);
	
	  // Traverse the graph, level by level,
	  while (start <= end) {
	    // Get the node to visit and remove it from queue
	    var node_id  = queue[start++];
	    var node_ix  = layoutInfo.idToIndex[node_id];
	    var node     = layoutInfo.layoutNodes[node_ix];
	    var children = node.children;
	    if (children.length > 0) {
	    // Add children nodes as a new graph to graph set
	    layoutInfo.graphSet.push(children);
	    // Add children to que queue to be visited
	    for (var i = 0; i < children.length; i++) {
	      queue[++end] = children[i];
	    }
	    }
	  }
	
	  // Create indexToGraph map
	  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
	    var graph = layoutInfo.graphSet[i];
	    for (var j = 0; j < graph.length; j++) {
	    var index = layoutInfo.idToIndex[graph[j]];
	    layoutInfo.indexToGraph[index] = i;
	    }
	  }
	
	  // Iterate over all edges, creating Layout Edges
	  for (var i = 0; i < layoutInfo.edgeSize; i++) {
	    var e = edges[i];
	    var tempEdge = {};
	    tempEdge.id       = e.data('id');
	    tempEdge.sourceId = e.data('source');
	    tempEdge.targetId = e.data('target');
	
	    // Compute ideal length
	    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;
	    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;
	
	    // Check if it's an inter graph edge
	    var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
	    var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
	    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
	    var targetGraph = layoutInfo.indexToGraph[targetIx];
	
	    if (sourceGraph != targetGraph) {
	      // Find lowest common graph ancestor
	      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);
	
	      // Compute sum of node depths, relative to lca graph
	      var lcaGraph = layoutInfo.graphSet[lca];
	      var depth    = 0;
	
	      // Source depth
	      var tempNode = layoutInfo.layoutNodes[sourceIx];
	      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
	        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
	        depth++;
	      }
	
	      // Target depth
	      tempNode = layoutInfo.layoutNodes[targetIx];
	      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
	        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
	        depth++;
	      }
	
	      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
	        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
	        //  ". Depth: " + depth);
	
	      // Update idealLength
	      idealLength *= depth * options.nestingFactor;
	    }
	
	    tempEdge.idealLength = idealLength;
	    tempEdge.elasticity = elasticity;
	
	    layoutInfo.layoutEdges.push(tempEdge);
	  }
	
	  // Finally, return layoutInfo object
	  return layoutInfo;
	};
	
	
	/**
	 * @brief : This function finds the index of the lowest common
	 *          graph ancestor between 2 nodes in the subtree
	 *          (from the graph hierarchy induced tree) whose
	 *          root is graphIx
	 *
	 * @arg node1: node1's ID
	 * @arg node2: node2's ID
	 * @arg layoutInfo: layoutInfo object
	 *
	 */
	var findLCA = function(node1, node2, layoutInfo) {
	  // Find their common ancester, starting from the root graph
	  var res = findLCA_aux(node1, node2, 0, layoutInfo);
	  if (2 > res.count) {
	    // If aux function couldn't find the common ancester,
	    // then it is the root graph
	    return 0;
	  } else {
	    return res.graph;
	  }
	};
	
	
	/**
	 * @brief          : Auxiliary function used for LCA computation
	 *
	 * @arg node1      : node1's ID
	 * @arg node2      : node2's ID
	 * @arg graphIx    : subgraph index
	 * @arg layoutInfo : layoutInfo object
	 *
	 * @return         : object of the form {count: X, graph: Y}, where:
	 *                   X is the number of ancesters (max: 2) found in
	 *                   graphIx (and it's subgraphs),
	 *                   Y is the graph index of the lowest graph containing
	 *                   all X nodes
	 */
	var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
	  var graph = layoutInfo.graphSet[graphIx];
	  // If both nodes belongs to graphIx
	  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
	    return {count:2, graph:graphIx};
	  }
	
	  // Make recursive calls for all subgraphs
	  var c = 0;
	  for (var i = 0; i < graph.length; i++) {
	    var nodeId   = graph[i];
	    var nodeIx   = layoutInfo.idToIndex[nodeId];
	    var children = layoutInfo.layoutNodes[nodeIx].children;
	
	    // If the node has no child, skip it
	    if (0 === children.length) {
	    continue;
	    }
	
	    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
	    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
	    if (0 === result.count) {
	    // Neither node1 nor node2 are present in this subgraph
	    continue;
	    } else if (1 === result.count) {
	    // One of (node1, node2) is present in this subgraph
	    c++;
	    if (2 === c) {
	      // We've already found both nodes, no need to keep searching
	      break;
	    }
	    } else {
	    // Both nodes are present in this subgraph
	    return result;
	    }
	  }
	
	  return {count:c, graph:graphIx};
	};
	
	
	/**
	 * @brief: printsLayoutInfo into js console
	 *         Only used for debbuging
	 */
	var printLayoutInfo = function(layoutInfo) {
	  /* jshint ignore:start */
	
	  if (!DEBUG) {
	    return;
	  }
	  console.debug("layoutNodes:");
	  for (var i = 0; i < layoutInfo.nodeSize; i++) {
	    var n = layoutInfo.layoutNodes[i];
	    var s =
	    "\nindex: "     + i +
	    "\nId: "        + n.id +
	    "\nChildren: "  + n.children.toString() +
	    "\nparentId: "  + n.parentId  +
	    "\npositionX: " + n.positionX +
	    "\npositionY: " + n.positionY +
	    "\nOffsetX: " + n.offsetX +
	    "\nOffsetY: " + n.offsetY +
	    "\npadLeft: " + n.padLeft +
	    "\npadRight: " + n.padRight +
	    "\npadTop: " + n.padTop +
	    "\npadBottom: " + n.padBottom;
	
	    console.debug(s);
	  }
	
	  console.debug('idToIndex');
	  for (var i in layoutInfo.idToIndex) {
	    console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
	  }
	
	  console.debug('Graph Set');
	  var set = layoutInfo.graphSet;
	  for (var i = 0; i < set.length; i ++) {
	    console.debug("Set : " + i + ": " + set[i].toString());
	  }
	
	  var s = 'IndexToGraph';
	  for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
	    s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
	  }
	  console.debug(s);
	
	  s = 'Layout Edges';
	  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
	    var e = layoutInfo.layoutEdges[i];
	    s += "\nEdge Index: " + i + " ID: " + e.id +
	    " SouceID: " + e.sourceId + " TargetId: " + e.targetId +
	    " Ideal Length: " + e.idealLength;
	  }
	  console.debug(s);
	
	  s =  "nodeSize: " + layoutInfo.nodeSize;
	  s += "\nedgeSize: " + layoutInfo.edgeSize;
	  s += "\ntemperature: " + layoutInfo.temperature;
	  console.debug(s);
	
	  return;
	  /* jshint ignore:end */
	};
	
	
	/**
	 * @brief : Randomizes the position of all nodes
	 */
	var randomizePositions = function(layoutInfo, cy) {
	  var width     = layoutInfo.clientWidth;
	  var height    = layoutInfo.clientHeight;
	
	  for (var i = 0; i < layoutInfo.nodeSize; i++) {
	    var n = layoutInfo.layoutNodes[i];
	
	    // No need to randomize compound nodes or locked nodes
	    if ( 0 === n.children.length && !n.isLocked ) {
	      n.positionX = Math.random() * width;
	      n.positionY = Math.random() * height;
	    }
	  }
	};
	
	
	/**
	 * @brief          : Updates the positions of nodes in the network
	 * @arg layoutInfo : LayoutInfo object
	 * @arg cy         : Cytoscape object
	 * @arg options    : Layout options
	 */
	var refreshPositions = function(layoutInfo, cy, options) {
	  // var s = 'Refreshing positions';
	  // logDebug(s);
	
	  var layout = options.layout;
	  var nodes = options.eles.nodes();
	  var bb = layoutInfo.boundingBox;
	  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
	
	  if( options.boundingBox ){
	    nodes.forEach(function( node ){
	      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
	
	      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
	      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );
	
	      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
	      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
	    });
	
	    coseBB.w = coseBB.x2 - coseBB.x1;
	    coseBB.h = coseBB.y2 - coseBB.y1;
	  }
	
	  nodes.positions(function(i, ele) {
	    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
	    // s = "Node: " + lnode.id + ". Refreshed position: (" +
	    // lnode.positionX + ", " + lnode.positionY + ").";
	    // logDebug(s);
	
	    if( options.boundingBox ){ // then add extra bounding box constraint
	      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
	      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
	
	      return {
	        x: bb.x1 + pctX * bb.w,
	        y: bb.y1 + pctY * bb.h
	      };
	    } else {
	      return {
	        x: lnode.positionX,
	        y: lnode.positionY
	      };
	    }
	  });
	
	  // Trigger layoutReady only on first call
	  if (true !== layoutInfo.ready) {
	    // s = 'Triggering layoutready';
	    // logDebug(s);
	    layoutInfo.ready = true;
	    layout.one('layoutready', options.ready);
	    layout.trigger({ type: 'layoutready', layout: this });
	  }
	};
	
	/**
	 * @brief : Logs a debug message in JS console, if DEBUG is ON
	 */
	// var logDebug = function(text) {
	//   if (DEBUG) {
	//     console.debug(text);
	//   }
	// };
	
	module.exports = CoseLayout;
	
	},{"../../is":77,"../../math":79,"../../thread":92,"../../util":94}],49:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	
	var defaults = {
	  fit: true, // whether to fit the viewport to the graph
	  padding: 30, // padding used on fit
	  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
	  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
	  condense: false, // uses all available space on false, uses minimal space on true
	  rows: undefined, // force num of rows in the grid
	  cols: undefined, // force num of columns in the grid
	  position: function( node ){}, // returns { row, col } for element
	  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function GridLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	GridLayout.prototype.run = function(){
	  var params = this.options;
	  var options = params;
	
	  var cy = params.cy;
	  var eles = options.eles;
	  var nodes = eles.nodes().not(':parent');
	
	  if( options.sort ){
	    nodes = nodes.sort( options.sort );
	  }
	
	  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	    x1: 0, y1: 0, w: cy.width(), h: cy.height()
	  } );
	
	  if( bb.h === 0 || bb.w === 0){
	    nodes.layoutPositions(this, options, function(){
	      return { x: bb.x1, y: bb.y1 };
	    });
	
	  } else {
	
	    // width/height * splits^2 = cells where splits is number of times to split width
	    var cells = nodes.size();
	    var splits = Math.sqrt( cells * bb.h/bb.w );
	    var rows = Math.round( splits );
	    var cols = Math.round( bb.w/bb.h * splits );
	
	    var small = function(val){
	      if( val == null ){
	        return Math.min(rows, cols);
	      } else {
	        var min = Math.min(rows, cols);
	        if( min == rows ){
	          rows = val;
	        } else {
	          cols = val;
	        }
	      }
	    };
	
	    var large = function(val){
	      if( val == null ){
	        return Math.max(rows, cols);
	      } else {
	        var max = Math.max(rows, cols);
	        if( max == rows ){
	          rows = val;
	        } else {
	          cols = val;
	        }
	      }
	    };
	
	    var oRows = options.rows;
	    var oCols = options.cols != null ? options.cols : options.columns;
	
	    // if rows or columns were set in options, use those values
	    if( oRows != null && oCols != null ){
	      rows = oRows;
	      cols = oCols;
	    } else if( oRows != null && oCols == null ){
	      rows = oRows;
	      cols = Math.ceil( cells / rows );
	    } else if( oRows == null && oCols != null ){
	      cols = oCols;
	      rows = Math.ceil( cells / cols );
	    }
	
	    // otherwise use the automatic values and adjust accordingly
	
	    // if rounding was up, see if we can reduce rows or columns
	    else if( cols * rows > cells ){
	      var sm = small();
	      var lg = large();
	
	      // reducing the small side takes away the most cells, so try it first
	      if( (sm - 1) * lg >= cells ){
	        small(sm - 1);
	      } else if( (lg - 1) * sm >= cells ){
	        large(lg - 1);
	      }
	    } else {
	
	      // if rounding was too low, add rows or columns
	      while( cols * rows < cells ){
	        var sm = small();
	        var lg = large();
	
	        // try to add to larger side first (adds less in multiplication)
	        if( (lg + 1) * sm >= cells ){
	          large(lg + 1);
	        } else {
	          small(sm + 1);
	        }
	      }
	    }
	
	    var cellWidth = bb.w / cols;
	    var cellHeight = bb.h / rows;
	
	    if( options.condense ){
	      cellWidth = 0;
	      cellHeight = 0;
	    }
	
	    if( options.avoidOverlap ){
	      for( var i = 0; i < nodes.length; i++ ){
	        var node = nodes[i];
	        var pos = node._private.position;
	
	        if( pos.x == null || pos.y == null ){ // for bb
	          pos.x = 0;
	          pos.y = 0;
	        }
	
	        var nbb = node.boundingBox();
	        var p = options.avoidOverlapPadding;
	
	        var w = nbb.w + p;
	        var h = nbb.h + p;
	
	        cellWidth = Math.max( cellWidth, w );
	        cellHeight = Math.max( cellHeight, h );
	      }
	    }
	
	    var cellUsed = {}; // e.g. 'c-0-2' => true
	
	    var used = function(row, col){
	      return cellUsed['c-' + row + '-' + col] ? true : false;
	    };
	
	    var use = function(row, col){
	      cellUsed['c-' + row + '-' + col] = true;
	    };
	
	    // to keep track of current cell position
	    var row = 0;
	    var col = 0;
	    var moveToNextCell = function(){
	      col++;
	      if( col >= cols ){
	        col = 0;
	        row++;
	      }
	    };
	
	    // get a cache of all the manual positions
	    var id2manPos = {};
	    for( var i = 0; i < nodes.length; i++ ){
	      var node = nodes[i];
	      var rcPos = options.position( node );
	
	      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
	        var pos = {
	          row: rcPos.row,
	          col: rcPos.col
	        };
	
	        if( pos.col === undefined ){ // find unused col
	          pos.col = 0;
	
	          while( used(pos.row, pos.col) ){
	            pos.col++;
	          }
	        } else if( pos.row === undefined ){ // find unused row
	          pos.row = 0;
	
	          while( used(pos.row, pos.col) ){
	            pos.row++;
	          }
	        }
	
	        id2manPos[ node.id() ] = pos;
	        use( pos.row, pos.col );
	      }
	    }
	
	    var getPos = function(i, element){
	      var x, y;
	
	      if( element.locked() || element.isFullAutoParent() ){
	        return false;
	      }
	
	      // see if we have a manual position set
	      var rcPos = id2manPos[ element.id() ];
	      if( rcPos ){
	        x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
	        y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
	
	      } else { // otherwise set automatically
	
	        while( used(row, col) ){
	          moveToNextCell();
	        }
	
	        x = col * cellWidth + cellWidth/2 + bb.x1;
	        y = row * cellHeight + cellHeight/2 + bb.y1;
	        use( row, col );
	
	        moveToNextCell();
	      }
	
	      return { x: x, y: y };
	
	    };
	
	    nodes.layoutPositions( this, options, getPos );
	  }
	
	  return this; // chaining
	
	};
	
	module.exports = GridLayout;
	
	},{"../../math":79,"../../util":94}],50:[function(_dereq_,module,exports){
	'use strict';
	
	module.exports = [
	  { name: 'breadthfirst', impl: _dereq_('./breadthfirst') },
	  { name: 'circle', impl: _dereq_('./circle') },
	  { name: 'concentric',impl: _dereq_('./concentric') },
	  { name: 'cose', impl: _dereq_('./cose') },
	  { name: 'grid', impl: _dereq_('./grid') },
	  { name: 'null', impl: _dereq_('./null') },
	  { name: 'preset', impl: _dereq_('./preset') },
	  { name: 'random', impl: _dereq_('./random') }
	];
	
	},{"./breadthfirst":45,"./circle":46,"./concentric":47,"./cose":48,"./grid":49,"./null":51,"./preset":52,"./random":53}],51:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	
	// default layout options
	var defaults = {
	  ready: function(){}, // on layoutready
	  stop: function(){} // on layoutstop
	};
	
	// constructor
	// options : object containing layout options
	function NullLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	// runs the layout
	NullLayout.prototype.run = function(){
	  var options = this.options;
	  var eles = options.eles; // elements to consider in the layout
	  var layout = this;
	
	  // cy is automatically populated for us in the constructor
	  var cy = options.cy; // jshint ignore:line
	
	  layout.trigger('layoutstart');
	
	  // puts all nodes at (0, 0)
	  eles.nodes().positions(function(){
	    return {
	      x: 0,
	      y: 0
	    };
	  });
	
	  // trigger layoutready when each node has had its position set at least once
	  layout.one('layoutready', options.ready);
	  layout.trigger('layoutready');
	
	  // trigger layoutstop when the layout stops (e.g. finishes)
	  layout.one('layoutstop', options.stop);
	  layout.trigger('layoutstop');
	
	  return this; // chaining
	};
	
	// called on continuous layouts to stop them before they finish
	NullLayout.prototype.stop = function(){
	  return this; // chaining
	};
	
	module.exports = NullLayout;
	
	},{"../../util":94}],52:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var is = _dereq_('../../is');
	
	var defaults = {
	  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
	  zoom: undefined, // the zoom level to set (prob want fit = false if set)
	  pan: undefined, // the pan level to set (prob want fit = false if set)
	  fit: true, // whether to fit to viewport
	  padding: 30, // padding on fit
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function PresetLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	PresetLayout.prototype.run = function(){
	  var options = this.options;
	  var eles = options.eles;
	
	  var nodes = eles.nodes();
	  var posIsFn = is.fn( options.positions );
	
	  function getPosition(node){
	    if( options.positions == null ){
	      return null;
	    }
	
	    if( posIsFn ){
	      return options.positions.apply( node, [ node ] );
	    }
	
	    var pos = options.positions[node._private.data.id];
	
	    if( pos == null ){
	      return null;
	    }
	
	    return pos;
	  }
	
	  nodes.layoutPositions(this, options, function(i, node){
	    var position = getPosition(node);
	
	    if( node.locked() || position == null ){
	      return false;
	    }
	
	    return position;
	  });
	
	  return this; // chaining
	};
	
	module.exports = PresetLayout;
	
	},{"../../is":77,"../../util":94}],53:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../util');
	var math = _dereq_('../../math');
	
	var defaults = {
	  fit: true, // whether to fit to viewport
	  padding: 30, // fit padding
	  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
	  animate: false, // whether to transition the node positions
	  animationDuration: 500, // duration of animation in ms if enabled
	  animationEasing: undefined, // easing of animation if enabled
	  ready: undefined, // callback on layoutready
	  stop: undefined // callback on layoutstop
	};
	
	function RandomLayout( options ){
	  this.options = util.extend({}, defaults, options);
	}
	
	RandomLayout.prototype.run = function(){
	  var options = this.options;
	  var cy = options.cy;
	  var eles = options.eles;
	  var nodes = eles.nodes().not(':parent');
	
	  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
	    x1: 0, y1: 0, w: cy.width(), h: cy.height()
	  } );
	
	  var getPos = function( i, node ){
	    return {
	      x: bb.x1 + Math.round( Math.random() * bb.w ),
	      y: bb.y1 + Math.round( Math.random() * bb.h )
	    };
	  };
	
	  nodes.layoutPositions( this, options, getPos );
	
	  return this; // chaining
	};
	
	module.exports = RandomLayout;
	
	},{"../../math":79,"../../util":94}],54:[function(_dereq_,module,exports){
	'use strict';
	
	var math = _dereq_('../../../math');
	var is = _dereq_('../../../is');
	var util = _dereq_('../../../util');
	
	var BRp = {};
	
	BRp.arrowShapeHeight = 0.3;
	
	BRp.registerArrowShapes = function(){
	  var arrowShapes = this.arrowShapes = {};
	  var renderer = this;
	
	  // Contract for arrow shapes:
	  // 0, 0 is arrow tip
	  // (0, 1) is direction towards node
	  // (1, 0) is right
	  //
	  // functional api:
	  // collide: check x, y in shape
	  // roughCollide: called before collide, no false negatives
	  // draw: draw
	  // spacing: dist(arrowTip, nodeBoundary)
	  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip
	
	  var bbCollide = function( x, y, size, angle, translation, padding ){
	    var x1 = translation.x - size/2 - padding;
	    var x2 = translation.x + size/2 + padding;
	    var y1 = translation.y - size/2 - padding;
	    var y2 = translation.y + size/2 + padding;
	
	    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
	
	    return inside;
	  };
	
	  var transform = function( x, y, size, angle, translation ){
	    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
	    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
	
	    var xScaled = xRotated * size;
	    var yScaled = yRotated * size;
	
	    var xTranslated = xScaled + translation.x;
	    var yTranslated = yScaled + translation.y;
	
	    return {
	      x: xTranslated,
	      y: yTranslated
	    };
	  };
	
	  var transformPoints = function( pts, size, angle, translation ){
	    var retPts = [];
	
	    for( var i = 0; i < pts.length; i += 2 ){
	      var x = pts[i];
	      var y = pts[i + 1];
	
	      retPts.push( transform(x, y, size, angle, translation) );
	    }
	
	    return retPts;
	  };
	
	  var pointsToArr = function( pts ){
	    var ret = [];
	
	    for( var i = 0; i < pts.length; i++ ){
	      var p = pts[i];
	
	      ret.push( p.x, p.y );
	    }
	
	    return ret;
	  };
	
	  var defineArrowShape = function( name, defn ){
	    if( is.string(defn) ){
	      defn = arrowShapes[ defn ];
	    }
	
	    arrowShapes[ name ] = util.extend( {
	      name: name,
	
	      points: [
	        -0.15, -0.3,
	        0.15, -0.3,
	        0.15, 0.3,
	        -0.15, 0.3
	      ],
	
	      collide: function( x, y, size, angle, translation, padding ){
	        var points = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
	        var inside = math.pointInsidePolygonPoints( x, y, points );
	
	        return inside;
	      },
	
	      roughCollide: bbCollide,
	
	      draw: function( context, size, angle, translation ){
	        var points = transformPoints( this.points, size, angle, translation );
	
	        renderer.arrowShapeImpl('polygon')( context, points );
	      },
	
	      spacing: function( edge ){
	        return 0;
	      },
	
	      gap: function( edge ){
	        return edge._private.style['width'].pfValue * 2;
	      }
	    }, defn );
	  };
	
	  defineArrowShape( 'none', {
	    collide: util.falsify,
	
	    roughCollide: util.falsify,
	
	    draw: util.noop,
	
	    spacing: util.zeroify,
	
	    gap: util.zeroify
	  } );
	
	  defineArrowShape( 'triangle', {
	    points: [
	      -0.15, -0.3,
	      0, 0,
	      0.15, -0.3
	    ]
	  } );
	
	  defineArrowShape( 'arrow', 'triangle' );
	
	  defineArrowShape( 'triangle-backcurve', {
	    points: arrowShapes['triangle'].points,
	
	    controlPoint: [ 0, -0.15 ],
	
	    roughCollide: bbCollide,
	
	    draw: function( context, size, angle, translation ){
	      var ptsTrans = transformPoints( this.points, size, angle, translation );
	      var ctrlPt = this.controlPoint;
	      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );
	
	      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
	    },
	
	    gap: function( edge ){
	      return edge._private.style['width'].pfValue;
	    }
	  } );
	
	
	  defineArrowShape( 'triangle-tee', {
	    points: [
	      -0.15, -0.3,
	      0, 0,
	      0.15, -0.3,
	      -0.15, -0.3
	    ],
	
	    pointsTee: [
	      -0.15, -0.4,
	      -0.15, -0.5,
	      0.15, -0.5,
	      0.15, -0.4
	    ],
	
	    collide: function( x, y, size, angle, translation, padding ){
	      var triPts = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
	      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2*padding, angle, translation ) );
	
	      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );
	
	      return inside;
	    },
	
	    draw: function( context, size, angle, translation ){
	      var triPts = transformPoints( this.points, size, angle, translation );
	      var teePts = transformPoints( this.pointsTee, size, angle, translation );
	
	      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
	    }
	  } );
	
	  defineArrowShape( 'vee', {
	    points: [
	      -0.15, -0.3,
	      0, 0,
	      0.15, -0.3,
	      0, -0.15
	    ],
	
	    gap: function( edge ){
	      return edge._private.style['width'].pfValue;
	    }
	  } );
	
	  defineArrowShape( 'half-triangle-overshot', {
	    points: [
	      0, -0.25,
	      -0.5, -0.25,
	      0.5, 0.25
	    ],
	
	    leavePathOpen: true,
	
	    matchEdgeWidth: true
	  } );
	
	  defineArrowShape( 'circle', {
	    radius: 0.15,
	
	    collide: function( x, y, size, angle, translation, padding ){
	      var t = translation;
	      var inside = ( Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2*padding) * this.radius, 2) );
	
	      return inside;
	    },
	
	    draw: function( context, size, angle, translation ){
	      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
	    },
	
	    spacing: function( edge ){
	      return renderer.getArrowWidth(edge._private.style['width'].pfValue)
	        * this.radius;
	    }
	  } );
	
	  defineArrowShape( 'inhibitor', {
	    points: [
	      -0.25, 0,
	      -0.25, -0.1,
	      0.25, -0.1,
	      0.25, 0
	    ],
	
	    spacing: function( edge ){
	      return 1;
	    },
	
	    gap: function( edge ){
	      return 1;
	    }
	  } );
	
	  defineArrowShape( 'tee', 'inhibitor' );
	
	  defineArrowShape( 'square', {
	    points: [
	      -0.15, 0.00,
	      0.15, 0.00,
	      0.15, -0.3,
	      -0.15, -0.3
	    ]
	  } );
	
	  defineArrowShape( 'diamond', {
	    points: [
	      -0.15, -0.15,
	      0, -0.3,
	      0.15, -0.15,
	      0, 0
	    ],
	
	    gap: function( edge ){
	      return edge._private.style['width'].pfValue;
	    }
	  } );
	
	};
	
	module.exports = BRp;
	
	},{"../../../is":77,"../../../math":79,"../../../util":94}],55:[function(_dereq_,module,exports){
	'use strict';
	
	var BRp = {};
	
	var delEleCache = function( r ){
	  r.eleEache = null;
	};
	
	var getEleCache = function( r ){
	  if( !r.eleEache ){
	    r.eleEache = {
	      nodes: r.cy.nodes(),
	      edges: r.cy.edges()
	    };
	  }
	
	  return r.eleEache;
	};
	
	BRp.getCachedElements = function(){
	  return getEleCache( this );
	};
	
	BRp.getCachedNodes = function(){
	  return getEleCache( this ).nodes;
	};
	
	BRp.getCachedEdges = function(){
	  return getEleCache( this ).edges;
	};
	
	BRp.updateElementsCache = function(){
	  var r = this;
	
	  delEleCache( r );
	
	  return getEleCache( r );
	};
	
	module.exports = BRp;
	
	},{}],56:[function(_dereq_,module,exports){
	'use strict';
	
	var math = _dereq_('../../../math');
	var is = _dereq_('../../../is');
	var zIndexSort = _dereq_('../../../collection/zsort');
	
	var BRp = {};
	
	// Project mouse
	BRp.projectIntoViewport = function(clientX, clientY) {
	  var offsets = this.findContainerClientCoords();
	  var offsetLeft = offsets[0];
	  var offsetTop = offsets[1];
	
	  var x = clientX - offsetLeft;
	  var y = clientY - offsetTop;
	
	  x -= this.cy.pan().x; y -= this.cy.pan().y; x /= this.cy.zoom(); y /= this.cy.zoom();
	  return [x, y];
	};
	
	BRp.findContainerClientCoords = function() {
	  var container = this.container;
	
	  var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();
	
	  return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
	};
	
	BRp.invalidateContainerClientCoordsCache = function(){
	  this.containerBB = null;
	};
	
	// Find nearest element
	BRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
	  var self = this;
	  var r = this;
	  var eles = r.getCachedZSortedEles();
	  var near = [];
	  var zoom = r.cy.zoom();
	  var hasCompounds = r.cy.hasCompoundNodes();
	  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
	  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
	  var labelThreshold = (isTouch ? 8 : 2) / zoom;
	
	  function checkNode(node){
	    var _p = node._private;
	
	    if( _p.style['events'].strValue === 'no' ){ return; }
	
	    var width = node.outerWidth() + 2*nodeThreshold;
	    var height = node.outerHeight() + 2*nodeThreshold;
	    var hw = width/2;
	    var hh = height/2;
	    var pos = _p.position;
	
	    if(
	      pos.x - hw <= x && x <= pos.x + hw // bb check x
	        &&
	      pos.y - hh <= y && y <= pos.y + hh // bb check y
	    ){
	      var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );
	
	      // exit early if invisible edge and must be visible
	      if( visibleElementsOnly && !visible ){
	        return;
	      }
	
	      var shape = r.nodeShapes[ self.getNodeShape(node) ];
	
	      if(
	        shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
	      ){
	        near.push( node );
	      }
	
	    }
	  }
	
	  function checkEdge(edge){
	    var _p = edge._private;
	
	    if( _p.style['events'].strValue === 'no' ){ return; }
	
	    var rs = _p.rscratch;
	    var style = _p.style;
	    var width = style['width'].pfValue/2 + edgeThreshold; // more like a distance radius from centre
	    var widthSq = width * width;
	    var width2 = width * 2;
	    var src = _p.source;
	    var tgt = _p.target;
	    var inEdgeBB = false;
	    var sqDist;
	
	    // exit early if invisible edge and must be visible
	    var passedVisibilityCheck;
	    var passesVisibilityCheck = function(){
	      if( passedVisibilityCheck !== undefined ){
	        return passedVisibilityCheck;
	      }
	
	      if( !visibleElementsOnly ){
	        passedVisibilityCheck = true;
	        return true;
	      }
	
	      var visible = edge.visible() && !edge.transparent();
	      if( visible ){
	        passedVisibilityCheck = true;
	        return true;
	      }
	
	      passedVisibilityCheck = false;
	      return false;
	    };
	
	    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
	      var pts = rs.allpts;
	
	      for( var i = 0; i + 3 < pts.length; i += 2 ){
	        if(
	          (inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], width2))
	            && passesVisibilityCheck() &&
	          widthSq > ( sqDist = math.sqDistanceToFiniteLine(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3]) )
	        ){
	          near.push( edge );
	        }
	      }
	
	    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
	      var pts = rs.allpts;
	      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
	        if(
	          (inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5], width2))
	            && passesVisibilityCheck() &&
	          (widthSq > (sqDist = math.sqDistanceToQuadraticBezier(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5])) )
	        ){
	          near.push( edge );
	        }
	      }
	    }
	
	    // if we're close to the edge but didn't hit it, maybe we hit its arrows
	    if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
	      var src = src || _p.source;
	      var tgt = tgt || _p.target;
	
	      var eWidth = style['width'].pfValue;
	      var arSize = self.getArrowWidth( eWidth );
	
	      var arrows = [
	        { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
	        { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
	        { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
	        { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
	      ];
	
	      for( var i = 0; i < arrows.length; i++ ){
	        var ar = arrows[i];
	        var shape = r.arrowShapes[ style[ar.name+'-arrow-shape'].value ];
	
	        if(
	          shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
	           &&
	          shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
	        ){
	          near.push( edge );
	          break;
	        }
	      }
	    }
	
	    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
	    if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
	      checkNode( src );
	      checkNode( tgt );
	    }
	  }
	
	  function checkLabel(ele){
	    var _p = ele._private;
	    var th = labelThreshold;
	
	    if( _p.style['text-events'].strValue === 'no' ){ return; }
	
	    // adjust bb w/ angle
	    if( _p.group === 'edges' && _p.style['edge-text-rotation'].strValue === 'autorotate' ){
	
	      var rstyle = _p.rstyle;
	      var lw = rstyle.labelWidth + 2*th;
	      var lh = rstyle.labelHeight + 2*th;
	      var lx = rstyle.labelX;
	      var ly = rstyle.labelY;
	
	      var theta = _p.rscratch.labelAngle;
	      var cos = Math.cos( theta );
	      var sin = Math.sin( theta );
	
	      var rotate = function( x, y ){
	        x = x - lx;
	        y = y - ly;
	
	        return {
	          x: x*cos - y*sin + lx,
	          y: x*sin + y*cos + ly
	        };
	      };
	
	      var lx1 = lx - lw/2;
	      var lx2 = lx + lw/2;
	      var ly1 = ly - lh/2;
	      var ly2 = ly + lh/2;
	
	      var px1y1 = rotate( lx1, ly1 );
	      var px1y2 = rotate( lx1, ly2 );
	      var px2y1 = rotate( lx2, ly1 );
	      var px2y2 = rotate( lx2, ly2 );
	
	      var points = [
	        px1y1.x, px1y1.y,
	        px2y1.x, px2y1.y,
	        px2y2.x, px2y2.y,
	        px1y2.x, px1y2.y
	      ];
	
	      if( math.pointInsidePolygonPoints( x, y, points ) ){
	        near.push( ele );
	      }
	
	    } else {
	      var bb = ele.boundingBox({
	        includeLabels: true,
	        includeNodes: false,
	        includeEdges: false
	      });
	
	      // adjust bb w/ threshold
	      bb.x1 -= th;
	      bb.y1 -= th;
	      bb.x2 += th;
	      bb.y2 += th;
	      bb.w = bb.x2 - bb.x1;
	      bb.h = bb.y2 - bb.y1;
	
	      if( math.inBoundingBox( bb, x, y ) ){
	        near.push( ele );
	      }
	    }
	
	  }
	
	  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
	    var ele = eles[i];
	    var _p = ele._private;
	
	    if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early
	
	    if( _p.group === 'nodes' ){
	      checkNode( ele );
	
	    } else  { // then edge
	      checkEdge( ele );
	    }
	
	    checkLabel( ele );
	
	  }
	
	
	  if( near.length > 0 ){
	    return near[ near.length - 1 ];
	  } else {
	    return null;
	  }
	};
	
	// 'Give me everything from this box'
	BRp.getAllInBox = function(x1, y1, x2, y2) {
	  var nodes = this.getCachedNodes();
	  var edges = this.getCachedEdges();
	  var box = [];
	
	  var x1c = Math.min(x1, x2);
	  var x2c = Math.max(x1, x2);
	  var y1c = Math.min(y1, y2);
	  var y2c = Math.max(y1, y2);
	
	  x1 = x1c;
	  x2 = x2c;
	  y1 = y1c;
	  y2 = y2c;
	
	  var boxBb = math.makeBoundingBox({
	    x1: x1, y1: y1,
	    x2: x2, y2: y2
	  });
	
	  for ( var i = 0; i < nodes.length; i++ ){
	    var node = nodes[i];
	    var nodeBb = node.boundingBox({
	      includeNodes: true,
	      includeEdges: false,
	      includeLabels: false
	    });
	
	    if( math.boundingBoxesIntersect(boxBb, nodeBb) ){
	      box.push(nodes[i]);
	    }
	  }
	
	  for( var e = 0; e < edges.length; e++ ){
	    var edge = edges[e];
	    var _p = edge._private;
	    var rs = _p.rscratch;
	
	    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
	    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }
	
	    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){
	
	      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
	      var allInside = true;
	
	      for( var i = 0; i < pts.length; i++ ){
	        if( !math.pointInBoundingBox( boxBb, pts[i] ) ){
	          allInside = false;
	          break;
	        }
	      }
	
	      if( allInside ){
	        box.push( edge );
	      }
	
	    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
	      box.push( edge );
	    }
	
	  }
	
	  return box;
	};
	
	
	/**
	 * Returns the shape of the given node. If the height or width of the given node
	 * is set to auto, the node is considered to be a compound.
	 *
	 * @param node          a node
	 * @return {String}     shape of the node
	 */
	BRp.getNodeShape = function( node ){
	  var r = this;
	  var style = node._private.style;
	  var shape = style['shape'].value;
	
	  if( node.isParent() ){
	    if( shape === 'rectangle' || shape === 'roundrectangle' ){
	      return shape;
	    } else {
	      return 'rectangle';
	    }
	  }
	
	  if( shape === 'polygon' ){
	    var points = style['shape-polygon-points'].value;
	
	    return r.nodeShapes.makePolygon( points ).name;
	  }
	
	  return shape;
	};
	
	BRp.updateCachedZSortedEles = function(){
	  this.getCachedZSortedEles( true );
	};
	
	BRp.getCachedZSortedEles = function( forceRecalc ){
	  var lastNodes = this.lastZOrderCachedNodes;
	  var lastEdges = this.lastZOrderCachedEdges;
	  var nodes = this.getCachedNodes();
	  var edges = this.getCachedEdges();
	  var eles = [];
	
	  if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){
	    //console.time('cachezorder')
	
	    for( var i = 0; i < nodes.length; i++ ){
	      var n = nodes[i];
	
	      if( n.animated() || (n.visible() && !n.transparent()) ){
	        eles.push( n );
	      }
	    }
	
	    for( var i = 0; i < edges.length; i++ ){
	      var e = edges[i];
	
	      if( e.animated() || (e.visible() && !e.transparent()) ){
	        eles.push( e );
	      }
	    }
	
	    eles.sort( zIndexSort );
	    this.cachedZSortedEles = eles;
	    //console.log('make cache')
	
	    //console.timeEnd('cachezorder')
	  } else {
	    eles = this.cachedZSortedEles;
	    //console.log('read cache')
	  }
	
	  this.lastZOrderCachedNodes = nodes;
	  this.lastZOrderCachedEdges = edges;
	
	  return eles;
	};
	
	function pushBezierPts(edge, pts){
	  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt(p1, p2, p3, t); };
	  var _p = edge._private;
	  var bpts = _p.rstyle.bezierPts;
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
	  });
	
	  bpts.push({
	    x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
	    y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
	  });
	}
	
	BRp.projectLines = function( edge ){
	  var _p = edge._private;
	  var rs = _p.rscratch;
	  var et = rs.edgeType;
	
	  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
	    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line
	
	    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
	      pushBezierPts( edge, rs.allpts.slice(i, i+6) );
	    }
	  } else if(  et === 'segments' ){
	    var lpts = _p.rstyle.linePts = [];
	
	    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
	      lpts.push({
	        x: rs.allpts[i],
	        y: rs.allpts[i+1]
	      });
	    }
	  } else if( et === 'haystack' ){
	    var hpts = rs.haystackPts;
	
	    _p.rstyle.haystackPts = [
	      { x: hpts[0], y: hpts[1] },
	      { x: hpts[2], y: hpts[3] }
	    ];
	  }
	};
	
	BRp.projectBezier = BRp.projectLines;
	
	BRp.recalculateNodeLabelProjection = function( node ){
	  var content = node._private.style['label'].strValue;
	  if( !content || content.match(/^\s+$/) ){ return; }
	
	  var textX, textY;
	  var nodeWidth = node.outerWidth();
	  var nodeHeight = node.outerHeight();
	  var nodePos = node._private.position;
	  var textHalign = node._private.style['text-halign'].strValue;
	  var textValign = node._private.style['text-valign'].strValue;
	  var rs = node._private.rscratch;
	  var rstyle = node._private.rstyle;
	
	  switch( textHalign ){
	    case 'left':
	      textX = nodePos.x - nodeWidth / 2;
	      break;
	
	    case 'right':
	      textX = nodePos.x + nodeWidth / 2;
	      break;
	
	    default: // e.g. center
	      textX = nodePos.x;
	  }
	
	  switch( textValign ){
	    case 'top':
	      textY = nodePos.y - nodeHeight / 2;
	      break;
	
	    case 'bottom':
	      textY = nodePos.y + nodeHeight / 2;
	      break;
	
	    default: // e.g. middle
	      textY = nodePos.y;
	  }
	
	  rs.labelX = textX;
	  rs.labelY = textY;
	  rstyle.labelX = textX;
	  rstyle.labelY = textY;
	
	  this.applyLabelDimensions( node );
	};
	
	BRp.recalculateEdgeLabelProjection = function( edge ){
	  var content = edge._private.style['label'].strValue;
	  if( !content || content.match(/^\s+$/) ){ return; }
	
	  var textX, textY;
	  var _p = edge._private;
	  var rs = _p.rscratch;
	  //var style = _p.style;
	  var rstyle = _p.rstyle;
	
	  textX = rs.midX;
	  textY = rs.midY;
	
	  // add center point to style so bounding box calculations can use it
	  rs.labelX = textX;
	  rs.labelY = textY;
	  rstyle.labelX = textX;
	  rstyle.labelY = textY;
	
	  this.applyLabelDimensions( edge );
	};
	
	BRp.applyLabelDimensions = function( ele ){
	  var rs = ele._private.rscratch;
	  var rstyle = ele._private.rstyle;
	
	  var text = this.getLabelText( ele );
	  var labelDims = this.calculateLabelDimensions( ele, text );
	
	  rstyle.labelWidth = labelDims.width;
	  rs.labelWidth = labelDims.width;
	
	  rstyle.labelHeight = labelDims.height;
	  rs.labelHeight = labelDims.height;
	};
	
	BRp.getLabelText = function( ele ){
	  var style = ele._private.style;
	  var text = ele._private.style['label'].strValue;
	  var textTransform = style['text-transform'].value;
	  var rscratch = ele._private.rscratch;
	
	  if (textTransform == 'none') {
	  } else if (textTransform == 'uppercase') {
	    text = text.toUpperCase();
	  } else if (textTransform == 'lowercase') {
	    text = text.toLowerCase();
	  }
	
	  if( style['text-wrap'].value === 'wrap' ){
	    //console.log('wrap');
	
	    // save recalc if the label is the same as before
	    if( rscratch.labelWrapKey === rscratch.labelKey ){
	      // console.log('wrap cache hit');
	      return rscratch.labelWrapCachedText;
	    }
	    // console.log('wrap cache miss');
	
	    var lines = text.split('\n');
	    var maxW = style['text-max-width'].pfValue;
	    var wrappedLines = [];
	
	    for( var l = 0; l < lines.length; l++ ){
	      var line = lines[l];
	      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
	      var lineW = lineDims.width;
	
	      if( lineW > maxW ){ // line is too long
	        var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
	        var subline = '';
	
	        for( var w = 0; w < words.length; w++ ){
	          var word = words[w];
	          var testLine = subline.length === 0 ? word : subline + ' ' + word;
	          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
	          var testW = testDims.width;
	
	          if( testW <= maxW ){ // word fits on current line
	            subline += word + ' ';
	          } else { // word starts new line
	            wrappedLines.push( subline );
	            subline = word + ' ';
	          }
	        }
	
	        // if there's remaining text, put it in a wrapped line
	        if( !subline.match(/^\s+$/) ){
	          wrappedLines.push( subline );
	        }
	      } else { // line is already short enough
	        wrappedLines.push( line );
	      }
	    } // for
	
	    rscratch.labelWrapCachedLines = wrappedLines;
	    rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
	    rscratch.labelWrapKey = rscratch.labelKey;
	
	    // console.log(text)
	  } // if wrap
	
	  return text;
	};
	
	BRp.calculateLabelDimensions = function( ele, text, extraKey ){
	  var r = this;
	  var style = ele._private.style;
	  var fStyle = style['font-style'].strValue;
	  var size = style['font-size'].pfValue + 'px';
	  var family = style['font-family'].strValue;
	  // var variant = style['font-variant'].strValue;
	  var weight = style['font-weight'].strValue;
	
	  var cacheKey = ele._private.labelKey;
	
	  if( extraKey ){
	    cacheKey += '$@$' + extraKey;
	  }
	
	  var cache = r.labelDimCache || (r.labelDimCache = {});
	
	  if( cache[cacheKey] ){
	    return cache[cacheKey];
	  }
	
	  var div = this.labelCalcDiv;
	
	  if( !div ){
	    div = this.labelCalcDiv = document.createElement('div');
	    document.body.appendChild( div );
	  }
	
	  var ds = div.style;
	
	  // from ele style
	  ds.fontFamily = family;
	  ds.fontStyle = fStyle;
	  ds.fontSize = size;
	  // ds.fontVariant = variant;
	  ds.fontWeight = weight;
	
	  // forced style
	  ds.position = 'absolute';
	  ds.left = '-9999px';
	  ds.top = '-9999px';
	  ds.zIndex = '-1';
	  ds.visibility = 'hidden';
	  ds.pointerEvents = 'none';
	  ds.padding = '0';
	  ds.lineHeight = '1';
	
	  if( style['text-wrap'].value === 'wrap' ){
	    ds.whiteSpace = 'pre'; // so newlines are taken into account
	  } else {
	    ds.whiteSpace = 'normal';
	  }
	
	  // put label content in div
	  div.textContent = text;
	
	  cache[cacheKey] = {
	    width: div.clientWidth,
	    height: div.clientHeight
	  };
	
	  return cache[cacheKey];
	};
	
	BRp.recalculateRenderedStyle = function( eles ){
	  var edges = [];
	  var nodes = [];
	  var handledEdge = {};
	
	  for( var i = 0; i < eles.length; i++ ){
	    var ele = eles[i];
	    var _p = ele._private;
	    var style = _p.style;
	    var rs = _p.rscratch;
	    var rstyle = _p.rstyle;
	    var id = _p.data.id;
	    var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
	    var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
	    var styleSame = bbStyleSame && labelStyleSame;
	
	    if( _p.group === 'nodes' ){
	      var pos = _p.position;
	      var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
	      var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pfValue;
	      var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pfValue;
	
	      if( !posSame || !styleSame || !wSame || !hSame ){
	        nodes.push( ele );
	      }
	
	      rstyle.nodeX = pos.x;
	      rstyle.nodeY = pos.y;
	      rstyle.nodeW = style['width'].pfValue;
	      rstyle.nodeH = style['height'].pfValue;
	    } else { // edges
	
	      var srcPos = _p.source._private.position;
	      var tgtPos = _p.target._private.position;
	      var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
	      var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
	      var positionsSame = srcSame && tgtSame;
	
	      if( !positionsSame || !styleSame ){
	        if( rs.edgeType === 'bezier' || rs.edgeType === 'straight' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
	          if( !handledEdge[ id ] ){
	            edges.push( ele );
	            handledEdge[ id ] = true;
	
	            var parallelEdges = ele.parallelEdges();
	            for( var i = 0; i < parallelEdges.length; i++ ){
	              var pEdge = parallelEdges[i];
	              var pId = pEdge._private.data.id;
	
	              if( !handledEdge[ pId ] ){
	                edges.push( pEdge );
	                handledEdge[ pId ] = true;
	              }
	
	            }
	          }
	        } else {
	          edges.push( ele );
	        }
	      } // if positions diff
	
	      // update rstyle positions
	      rstyle.srcX = srcPos.x;
	      rstyle.srcY = srcPos.y;
	      rstyle.tgtX = tgtPos.x;
	      rstyle.tgtY = tgtPos.y;
	
	    } // if edges
	
	    rs.boundingBoxKey = _p.boundingBoxKey;
	    rs.labelKey = _p.labelKey;
	  }
	
	  this.recalculateEdgeProjections( edges );
	  this.recalculateLabelProjections( nodes, edges );
	};
	
	BRp.recalculateLabelProjections = function( nodes, edges ){
	  for( var i = 0; i < nodes.length; i++ ){
	    this.recalculateNodeLabelProjection( nodes[i] );
	  }
	
	  for( var i = 0; i < edges.length; i++ ){
	    this.recalculateEdgeLabelProjection( edges[i] );
	  }
	};
	
	BRp.recalculateEdgeProjections = function( edges ){
	  this.findEdgeControlPoints( edges );
	};
	
	
	// Find edge control points
	BRp.findEdgeControlPoints = function(edges) {
	  if( !edges || edges.length === 0 ){ return; }
	
	  var r = this;
	  var cy = r.cy;
	  var hasCompounds = cy.hasCompoundNodes();
	  var hashTable = {};
	  var pairIds = [];
	  var haystackEdges = [];
	  var autorotateEdges = [];
	
	  // create a table of edge (src, tgt) => list of edges between them
	  var pairId;
	  for (var i = 0; i < edges.length; i++){
	    var edge = edges[i];
	    var _p = edge._private;
	    var data = _p.data;
	    var style = _p.style;
	    var curveStyle = style['curve-style'].value;
	    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
	
	    // ignore edges who are not to be displayed
	    // they shouldn't take up space
	    if( style.display.value === 'none' ){
	      continue;
	    }
	
	    if( style['edge-text-rotation'].strValue === 'autorotate' ){
	      autorotateEdges.push( edge );
	    }
	
	    if( curveStyle === 'haystack' ){
	      haystackEdges.push( edge );
	      continue;
	    }
	
	    var srcId = data.source;
	    var tgtId = data.target;
	
	    pairId = srcId > tgtId ?
	      tgtId + '$-$' + srcId :
	      srcId + '$-$' + tgtId ;
	
	    if( edgeIsUnbundled ){
	      pairId = 'unbundled' + '$-$' + data.id;
	    }
	
	    if( hashTable[pairId] == null ){
	      hashTable[pairId] = [];
	      pairIds.push( pairId );
	    }
	
	    hashTable[pairId].push( edge );
	
	    if( edgeIsUnbundled ){
	      hashTable[pairId].hasUnbundled = true;
	    }
	  }
	
	  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
	  var vectorNormInverse;
	  var badBezier;
	
	  // for each pair (src, tgt), create the ctrl pts
	  // Nested for loop is OK; total number of iterations for both loops = edgeCount
	  for (var p = 0; p < pairIds.length; p++) {
	    pairId = pairIds[p];
	    var pairEdges = hashTable[pairId];
	
	    // for each pair id, the edges should be sorted by index
	    pairEdges.sort(function(edge1, edge2){
	      return edge1._private.index - edge2._private.index;
	    });
	
	    src = pairEdges[0]._private.source;
	    tgt = pairEdges[0]._private.target;
	
	    src_p = src._private;
	    tgt_p = tgt._private;
	
	    // make sure src/tgt distinction is consistent
	    // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
	    if( src_p.data.id > tgt_p.data.id ){
	      var temp = src;
	      src = tgt;
	      tgt = temp;
	    }
	
	    srcPos = src_p.position;
	    tgtPos = tgt_p.position;
	
	    srcW = src.outerWidth();
	    srcH = src.outerHeight();
	
	    tgtW = tgt.outerWidth();
	    tgtH = tgt.outerHeight();
	
	    srcShape = r.nodeShapes[ this.getNodeShape(src) ];
	    tgtShape = r.nodeShapes[ this.getNodeShape(tgt) ];
	
	    badBezier = false;
	
	
	    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){
	
	      // pt outside src shape to calc distance/displacement from src to tgt
	      var srcOutside = srcShape.intersectLine(
	        srcPos.x,
	        srcPos.y,
	        srcW,
	        srcH,
	        tgtPos.x,
	        tgtPos.y,
	        0
	      );
	
	      // pt outside tgt shape to calc distance/displacement from src to tgt
	      var tgtOutside = tgtShape.intersectLine(
	        tgtPos.x,
	        tgtPos.y,
	        tgtW,
	        tgtH,
	        srcPos.x,
	        srcPos.y,
	        0
	      );
	
	      var midptSrcPts = {
	        x1: srcOutside[0],
	        x2: tgtOutside[0],
	        y1: srcOutside[1],
	        y2: tgtOutside[1]
	      };
	
	      var dy = ( tgtOutside[1] - srcOutside[1] );
	      var dx = ( tgtOutside[0] - srcOutside[0] );
	      var l = Math.sqrt( dx*dx + dy*dy );
	
	      var vector = {
	        x: dx,
	        y: dy
	      };
	
	      var vectorNorm = {
	        x: vector.x/l,
	        y: vector.y/l
	      };
	      vectorNormInverse = {
	        x: -vectorNorm.y,
	        y: vectorNorm.x
	      };
	
	
	      // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
	      if(
	        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
	        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
	      ){
	        vectorNormInverse = {};
	        badBezier = true;
	      }
	
	    }
	
	    var edge;
	    var edge_p;
	    var rs;
	
	    for (var i = 0; i < pairEdges.length; i++) {
	      edge = pairEdges[i];
	      edge_p = edge._private;
	      rs = edge_p.rscratch;
	
	      var edgeIndex1 = rs.lastEdgeIndex;
	      var edgeIndex2 = i;
	
	      var numEdges1 = rs.lastNumEdges;
	      var numEdges2 = pairEdges.length;
	
	      var eStyle = edge_p.style;
	      var style = eStyle;
	      var curveStyle = eStyle['curve-style'].value;
	      var ctrlptDists = eStyle['control-point-distances'];
	      var ctrlptWs = eStyle['control-point-weights'];
	      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
	      var stepSize = eStyle['control-point-step-size'].pfValue;
	      var ctrlptDist = ctrlptDists !== undefined ? ctrlptDists.pfValue[0] : undefined;
	      var ctrlptWeight = ctrlptWs.value[0];
	      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';
	
	      var swappedDirection = edge_p.source !== src;
	
	      if( swappedDirection && edgeIsUnbundled ){
	        ctrlptDist *= -1;
	      }
	
	      var srcX1 = rs.lastSrcCtlPtX;
	      var srcX2 = srcPos.x;
	      var srcY1 = rs.lastSrcCtlPtY;
	      var srcY2 = srcPos.y;
	      var srcW1 = rs.lastSrcCtlPtW;
	      var srcW2 = src.outerWidth();
	      var srcH1 = rs.lastSrcCtlPtH;
	      var srcH2 = src.outerHeight();
	
	      var tgtX1 = rs.lastTgtCtlPtX;
	      var tgtX2 = tgtPos.x;
	      var tgtY1 = rs.lastTgtCtlPtY;
	      var tgtY2 = tgtPos.y;
	      var tgtW1 = rs.lastTgtCtlPtW;
	      var tgtW2 = tgt.outerWidth();
	      var tgtH1 = rs.lastTgtCtlPtH;
	      var tgtH2 = tgt.outerHeight();
	
	      var width1 = rs.lastW;
	      var width2 = eStyle['control-point-step-size'].pfValue;
	
	      if( badBezier ){
	        rs.badBezier = true;
	      } else {
	        rs.badBezier = false;
	      }
	
	      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
	      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
	      &&  width1 === width2
	      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
	        // console.log('edge ctrl pt cache HIT')
	        continue; // then the control points haven't changed and we can skip calculating them
	      } else {
	        rs.lastSrcCtlPtX = srcX2;
	        rs.lastSrcCtlPtY = srcY2;
	        rs.lastSrcCtlPtW = srcW2;
	        rs.lastSrcCtlPtH = srcH2;
	        rs.lastTgtCtlPtX = tgtX2;
	        rs.lastTgtCtlPtY = tgtY2;
	        rs.lastTgtCtlPtW = tgtW2;
	        rs.lastTgtCtlPtH = tgtH2;
	        rs.lastEdgeIndex = edgeIndex2;
	        rs.lastNumEdges = numEdges2;
	        rs.lastWidth = width2;
	        // console.log('edge ctrl pt cache MISS')
	      }
	
	      if( src === tgt ){
	        // Self-edge
	
	        rs.edgeType = 'self';
	
	        var j = i;
	        var loopDist = stepSize;
	
	        if( edgeIsUnbundled ){
	          j = 0;
	          loopDist = ctrlptDist;
	        }
	
	        rs.ctrlpts = [
	          srcPos.x,
	          srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1),
	
	          srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1),
	          srcPos.y
	        ];
	
	      } else if(
	        hasCompounds &&
	        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
	        ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
	      ){
	        // Compound edge
	
	        rs.edgeType = 'compound';
	
	        // because the line approximation doesn't apply for compound beziers
	        // (loop/self edges are already elided b/c of cheap src==tgt check)
	        rs.badBezier = false;
	
	        var j = i;
	        var loopDist = stepSize;
	
	        if( edgeIsUnbundled ){
	          j = 0;
	          loopDist = ctrlptDist;
	        }
	
	        var loopW = 50;
	
	        var loopaPos = {
	          x: srcPos.x - srcW/2,
	          y: srcPos.y - srcH/2
	        };
	
	        var loopbPos = {
	          x: tgtPos.x - tgtW/2,
	          y: tgtPos.y - tgtH/2
	        };
	
	        var loopPos = {
	          x: Math.min( loopaPos.x, loopbPos.x ),
	          y: Math.min( loopaPos.y, loopbPos.y )
	        };
	
	        // avoids cases with impossible beziers
	        var minCompoundStretch = 0.5;
	        var compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) );
	        var compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) );
	
	        rs.ctrlpts = [
	          loopPos.x,
	          loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,
	
	          loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
	          loopPos.y
	        ];
	
	      } else if( curveStyle === 'segments' ){
	        // Segments (multiple straight lines)
	
	        rs.edgeType = 'segments';
	        rs.segpts = [];
	
	        var segmentWs = eStyle['segment-weights'].pfValue;
	        var segmentDs = eStyle['segment-distances'].pfValue;
	        var segmentsN = Math.min( segmentWs.length, segmentDs.length );
	
	        for( var s = 0; s < segmentsN; s++ ){
	          var w = segmentWs[s];
	          var d = segmentDs[s];
	
	          // d = swappedDirection ? -d : d;
	          //
	          // d = Math.abs(d);
	
	          // var w1 = !swappedDirection ? (1 - w) : w;
	          // var w2 = !swappedDirection ? w : (1 - w);
	
	          var w1 = (1 - w);
	          var w2 = w;
	
	          var adjustedMidpt = {
	            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
	            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
	          };
	
	          rs.segpts.push(
	            adjustedMidpt.x + vectorNormInverse.x * d,
	            adjustedMidpt.y + vectorNormInverse.y * d
	          );
	        }
	
	      // Straight edge
	      } else if (
	        pairEdges.length % 2 === 1
	        && i === Math.floor(pairEdges.length / 2)
	        && !edgeIsUnbundled
	      ){
	
	        rs.edgeType = 'straight';
	
	      } else {
	        // (Multi)bezier
	
	        var multi = edgeIsUnbundled;
	
	        rs.edgeType = multi ? 'multibezier' : 'bezier';
	        rs.ctrlpts = [];
	
	        for( var b = 0; b < bezierN; b++ ){
	          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
	          var manctrlptDist;
	          var sign = math.signum( normctrlptDist );
	
	          if( multi ){
	            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
	            ctrlptWeight = ctrlptWs.value[b];
	          }
	
	          if( edgeIsUnbundled ){ // multi or single unbundled
	            manctrlptDist = ctrlptDist;
	          } else {
	            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
	          }
	
	          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
	
	          var w1 = !swappedDirection || edgeIsUnbundled ? (1 - ctrlptWeight) : ctrlptWeight;
	          var w2 = !swappedDirection || edgeIsUnbundled ? ctrlptWeight : (1 - ctrlptWeight);
	
	          var adjustedMidpt = {
	            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
	            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
	          };
	
	          rs.ctrlpts.push(
	            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
	            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
	          );
	        }
	
	      }
	
	      // find endpts for edge
	      this.findEndpoints( edge );
	
	      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
	      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
	      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
	      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );
	
	      var minCpADistFactor = 3;
	      var arrowW = this.getArrowWidth( eStyle['width'].pfValue ) * this.arrowShapeHeight;
	      var minCpADist = minCpADistFactor * arrowW;
	
	      if( rs.edgeType === 'bezier' ){
	        var startACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
	        var closeStartACp = startACpDist < minCpADist;
	        var endACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
	        var closeEndACp = endACpDist < minCpADist;
	
	        var overlapping = false;
	
	        if( badStart || badAStart || closeStartACp ){
	          overlapping = true;
	
	          // project control point along line from src centre to outside the src shape
	          // (otherwise intersection will yield nothing)
	          var cpD = { // delta
	            x: rs.ctrlpts[0] - srcPos.x,
	            y: rs.ctrlpts[1] - srcPos.y
	          };
	          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
	          var cpM = { // normalised delta
	            x: cpD.x / cpL,
	            y: cpD.y / cpL
	          };
	          var radius = Math.max(srcW, srcH);
	          var cpProj = { // *2 radius guarantees outside shape
	            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
	            y: rs.ctrlpts[1] + cpM.y * 2 * radius
	          };
	
	          var srcCtrlPtIntn = srcShape.intersectLine(
	            srcPos.x,
	            srcPos.y,
	            srcW,
	            srcH,
	            cpProj.x,
	            cpProj.y,
	            0
	          );
	
	          if( closeStartACp ){
	            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
	            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
	          } else {
	            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
	            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
	          }
	        }
	
	        if( badEnd || badAEnd || closeEndACp ){
	          overlapping = true;
	
	          // project control point along line from tgt centre to outside the tgt shape
	          // (otherwise intersection will yield nothing)
	          var cpD = { // delta
	            x: rs.ctrlpts[0] - tgtPos.x,
	            y: rs.ctrlpts[1] - tgtPos.y
	          };
	          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
	          var cpM = { // normalised delta
	            x: cpD.x / cpL,
	            y: cpD.y / cpL
	          };
	          var radius = Math.max(srcW, srcH);
	          var cpProj = { // *2 radius guarantees outside shape
	            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
	            y: rs.ctrlpts[1] + cpM.y * 2 * radius
	          };
	
	          var tgtCtrlPtIntn = tgtShape.intersectLine(
	            tgtPos.x,
	            tgtPos.y,
	            tgtW,
	            tgtH,
	            cpProj.x,
	            cpProj.y,
	            0
	          );
	
	          if( closeEndACp ){
	            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
	            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
	          } else {
	            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
	            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
	          }
	
	        }
	
	        if( overlapping ){
	          // recalc endpts
	          this.findEndpoints( edge );
	        }
	
	      }
	
	      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
	        rs.allpts = [];
	
	        rs.allpts.push( rs.startX, rs.startY );
	
	        for( var b = 0; b+1 < rs.ctrlpts.length; b += 2 ){
	          // ctrl pt itself
	          rs.allpts.push( rs.ctrlpts[b], rs.ctrlpts[b+1] );
	
	          // the midpt between ctrlpts as intermediate destination pts
	          if( b + 3 < rs.ctrlpts.length ){
	            rs.allpts.push( (rs.ctrlpts[b] + rs.ctrlpts[b+2])/2, (rs.ctrlpts[b+1] + rs.ctrlpts[b+3])/2 );
	          }
	        }
	
	        rs.allpts.push( rs.endX, rs.endY );
	
	        var m, mt;
	        if( rs.edgeType === 'bezier' ){
	          rs.midX = math.qbezierAt( rs.arrowStartX, rs.ctrlpts[0], rs.arrowEndX, 0.5 );
	          rs.midY = math.qbezierAt( rs.arrowStartY, rs.ctrlpts[1], rs.arrowEndY, 0.5 );
	        } else if( rs.ctrlpts.length/2 % 2 === 0 ){
	          m = rs.allpts.length/2 - 1;
	
	          rs.midX = rs.allpts[m];
	          rs.midY = rs.allpts[m+1];
	        } else {
	          m = rs.allpts.length/2 - 3;
	          mt = 0.5;
	
	          rs.midX = math.qbezierAt( rs.allpts[m], rs.allpts[m+2], rs.allpts[m+4], mt );
	          rs.midY = math.qbezierAt( rs.allpts[m+1], rs.allpts[m+3], rs.allpts[m+5], mt );
	        }
	
	      } else if( rs.edgeType === 'straight' ){
	        // need to calc these after endpts
	        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];
	
	        // default midpt for labels etc
	        rs.midX = ( rs.arrowStartX + rs.arrowEndX )/2;
	        rs.midY = ( rs.arrowStartY + rs.arrowEndY )/2;
	
	      } else if( rs.edgeType === 'segments' ){
	        rs.allpts = [];
	        rs.allpts.push( rs.startX, rs.startY );
	        rs.allpts.push.apply( rs.allpts, rs.segpts );
	        rs.allpts.push( rs.endX, rs.endY );
	
	        if( rs.segpts.length % 4 === 0 ){
	          var i2 = rs.segpts.length / 2;
	          var i1 = i2 - 2;
	
	          rs.midX = ( rs.segpts[i1] + rs.segpts[i2] ) / 2;
	          rs.midY = ( rs.segpts[i1+1] + rs.segpts[i2+1] ) / 2;
	        } else {
	          var i1 = rs.segpts.length / 2 - 1;
	
	          rs.midX = rs.segpts[i1];
	          rs.midY = rs.segpts[i1+1];
	        }
	
	
	      }
	
	      this.projectLines( edge );
	      this.calculateArrowAngles( edge );
	      this.recalculateEdgeLabelProjection( edge );
	
	    }
	  }
	
	  for( var i = 0; i < haystackEdges.length; i++ ){
	    var edge = haystackEdges[i];
	    var _p = edge._private;
	    var style = _p.style;
	    var rscratch = _p.rscratch;
	    var rs = rscratch;
	
	    if( !rscratch.haystack ){
	      var angle = Math.random() * 2 * Math.PI;
	
	      rscratch.source = {
	        x: Math.cos(angle),
	        y: Math.sin(angle)
	      };
	
	      var angle = Math.random() * 2 * Math.PI;
	
	      rscratch.target = {
	        x: Math.cos(angle),
	        y: Math.sin(angle)
	      };
	
	    }
	
	    var src = _p.source;
	    var tgt = _p.target;
	    var srcPos = src._private.position;
	    var tgtPos = tgt._private.position;
	    var srcW = src.width();
	    var tgtW = tgt.width();
	    var srcH = src.height();
	    var tgtH = tgt.height();
	    var radius = style['haystack-radius'].value;
	    var halfRadius = radius/2; // b/c have to half width/height
	
	    rs.haystackPts = rs.allpts = [
	      rs.source.x * srcW * halfRadius + srcPos.x,
	      rs.source.y * srcH * halfRadius + srcPos.y,
	      rs.target.x * tgtW * halfRadius + tgtPos.x,
	      rs.target.y * tgtH * halfRadius + tgtPos.y
	    ];
	
	    rs.midX = (rs.allpts[0] + rs.allpts[2])/2;
	    rs.midY = (rs.allpts[1] + rs.allpts[3])/2;
	
	    // always override as haystack in case set to different type previously
	    rscratch.edgeType = 'haystack';
	    rscratch.haystack = true;
	
	    this.projectLines( edge );
	    this.calculateArrowAngles( edge );
	    this.recalculateEdgeLabelProjection( edge );
	  }
	
	  for( var i = 0 ; i < autorotateEdges.length; i++ ){
	    var edge = autorotateEdges[i];
	    var rs = edge._private.rscratch;
	
	    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
	  }
	
	  return hashTable;
	};
	
	var getAngleFromDisp = function( dispX, dispY ){
	  return Math.atan2( dispY, dispX ) - Math.PI/2;
	};
	
	BRp.calculateArrowAngles = function( edge ){
	  var rs = edge._private.rscratch;
	  var isHaystack = rs.edgeType === 'haystack';
	  var isMultibezier = rs.edgeType === 'multibezier';
	  var isSegments = rs.edgeType === 'segments';
	  var isCompound = rs.edgeType === 'compound';
	  var isSelf = rs.edgeType === 'self';
	
	  // Displacement gives direction for arrowhead orientation
	  var dispX, dispY;
	  var startX, startY, endX, endY;
	
	  var srcPos = edge.source().position();
	  var tgtPos = edge.target().position();
	
	  if( isHaystack ){
	    startX = rs.haystackPts[0];
	    startY = rs.haystackPts[1];
	    endX = rs.haystackPts[2];
	    endY = rs.haystackPts[3];
	  } else {
	    startX = rs.arrowStartX;
	    startY = rs.arrowStartY;
	    endX = rs.arrowEndX;
	    endY = rs.arrowEndY;
	  }
	
	  // source
	  //
	
	  dispX = srcPos.x - startX;
	  dispY = srcPos.y - startY;
	
	  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );
	
	  // mid target
	  //
	
	  var midX = rs.midX;
	  var midY = rs.midY;
	
	  if( isHaystack ){
	    midX = ( startX + endX )/2;
	    midY = ( startY + endY )/2;
	  }
	
	  dispX = endX - startX;
	  dispY = endY - startY;
	
	  if( isSelf ){
	    dispX = -1;
	    dispY = 1;
	  } else if( isSegments ){
	    var pts = rs.allpts;
	
	    if( pts.length / 2 % 2 === 0 ){
	      var i2 = pts.length / 2;
	      var i1 = i2 - 2;
	
	      dispX = ( pts[i2] - pts[i1] );
	      dispY = ( pts[i2+1] - pts[i1+1] );
	    } else {
	      var i2 = pts.length / 2 - 1;
	      var i1 = i2 - 2;
	      var i3 = i2 + 2;
	
	      dispX = ( pts[i2] - pts[i1] );
	      dispY = ( pts[i2+1] - pts[i1+1] );
	    }
	  } else if( isMultibezier || isCompound ){
	    var pts = rs.allpts;
	    var cpts = rs.ctrlpts;
	    var bp0x, bp0y;
	    var bp1x, bp1y;
	
	    if( cpts.length / 2 % 2 === 0 ){
	      var p0 = pts.length / 2 - 1; // startpt
	      var ic = p0 + 2;
	      var p1 = ic + 2;
	
	      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0 );
	      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0 );
	
	      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0001 );
	      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0001 );
	    } else {
	      var ic = pts.length / 2 - 1; // ctrpt
	      var p0 = ic - 2; // startpt
	      var p1 = ic + 2; // endpt
	
	      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.4999 );
	      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.4999 );
	
	      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.5 );
	      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.5 );
	    }
	
	    dispX = ( bp1x - bp0x );
	    dispY = ( bp1y - bp0y );
	  }
	
	  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );
	
	  rs.midDispX = dispX;
	  rs.midDispY = dispY;
	
	  // mid source
	  //
	
	  dispX *= -1;
	  dispY *= -1;
	
	  if( isSegments ){
	    var pts = rs.allpts;
	
	    if( pts.length / 2 % 2 === 0 ){
	      // already ok
	    } else {
	      var i2 = pts.length / 2 - 1;
	      var i3 = i2 + 2;
	
	      dispX = -( pts[i3] - pts[i2] );
	      dispY = -( pts[i3+1] - pts[i2+1] );
	    }
	  }
	
	  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );
	
	  // target
	  //
	
	  dispX = tgtPos.x - endX;
	  dispY = tgtPos.y - endY;
	
	  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
	};
	
	
	BRp.findEndpoints = function( edge ){
	  var r = this;
	  var intersect;
	
	  var source = edge.source()[0];
	  var target = edge.target()[0];
	
	  var src_p = source._private;
	  var tgt_p = target._private;
	
	  var srcPos = src_p.position;
	  var tgtPos = tgt_p.position;
	
	  var tgtArShape = edge._private.style['target-arrow-shape'].value;
	  var srcArShape = edge._private.style['source-arrow-shape'].value;
	
	  var rs = edge._private.rscratch;
	
	  var et = rs.edgeType;
	  var bezier = et === 'bezier' || et === 'multibezier' || et === 'self' || et === 'compound';
	  var multi = et !== 'bezier';
	  var lines = et === 'straight' || et === 'segments';
	  var segments = et === 'segments';
	
	  var p1, p2;
	
	  if( bezier ){
	    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
	    var cpEnd = multi ? [ rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1] ] : cpStart;
	
	    p1 = cpEnd;
	    p2 = cpStart;
	  } else if( lines ){
	    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
	    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );
	
	    p1 = tgtArrowFromPt;
	    p2 = srcArrowFromPt;
	  }
	
	  intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(
	    tgtPos.x,
	    tgtPos.y,
	    target.outerWidth(),
	    target.outerHeight(),
	    p1[0],
	    p1[1],
	    0
	  );
	
	  var arrowEnd = math.shortenIntersection(intersect, p1,
	    r.arrowShapes[tgtArShape].spacing(edge));
	  var edgeEnd = math.shortenIntersection(intersect, p1,
	    r.arrowShapes[tgtArShape].gap(edge));
	
	  rs.endX = edgeEnd[0];
	  rs.endY = edgeEnd[1];
	
	  rs.arrowEndX = arrowEnd[0];
	  rs.arrowEndY = arrowEnd[1];
	
	  intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(
	    srcPos.x,
	    srcPos.y,
	    source.outerWidth(),
	    source.outerHeight(),
	    p2[0],
	    p2[1],
	    0
	  );
	
	  var arrowStart = math.shortenIntersection(
	    intersect, p2,
	    r.arrowShapes[srcArShape].spacing(edge)
	  );
	  var edgeStart = math.shortenIntersection(
	    intersect, p2,
	    r.arrowShapes[srcArShape].gap(edge)
	  );
	
	  rs.startX = edgeStart[0];
	  rs.startY = edgeStart[1];
	
	  rs.arrowStartX = arrowStart[0];
	  rs.arrowStartY = arrowStart[1];
	
	  if( lines ){
	    if( !is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY) ){
	      rs.badLine = true;
	    } else {
	      rs.badLine = false;
	    }
	  }
	};
	
	BRp.getArrowWidth = BRp.getArrowHeight = function(edgeWidth) {
	  var cache = this.arrowWidthCache = this.arrowWidthCache || {};
	
	  var cachedVal = cache[edgeWidth];
	  if( cachedVal ){
	    return cachedVal;
	  }
	
	  cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
	  cache[edgeWidth] = cachedVal;
	
	  return cachedVal;
	};
	
	module.exports = BRp;
	
	},{"../../../collection/zsort":29,"../../../is":77,"../../../math":79}],57:[function(_dereq_,module,exports){
	'use strict';
	
	var BRp = {};
	
	BRp.getCachedImage = function(url, onLoad) {
	  var r = this;
	  var imageCache = r.imageCache = r.imageCache || {};
	
	  if( imageCache[url] && imageCache[url].image ){
	    return imageCache[url].image;
	  }
	
	  var cache = imageCache[url] = imageCache[url] || {};
	
	  var image = cache.image = new Image();
	  image.addEventListener('load', onLoad);
	  image.src = url;
	
	  return image;
	};
	
	module.exports = BRp;
	
	},{}],58:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../../is');
	var util = _dereq_('../../../util');
	
	var BaseRenderer = function(){};
	var BR = BaseRenderer;
	var BRp = BR.prototype;
	
	BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];
	
	BRp.init = function( options ){
	  var r = this;
	
	  r.options = options;
	
	  r.cy = options.cy;
	
	  r.container = options.cy.container();
	
	  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag
	
	  //--Pointer-related data
	  r.hoverData = {down: null, last: null,
	      downTime: null, triggerMode: null,
	      dragging: false,
	      initialPan: [null, null], capture: false};
	
	  r.dragData = {possibleDragElements: []};
	
	  r.touchData = {
	      start: null, capture: false,
	
	      // These 3 fields related to tap, taphold events
	      startPosition: [null, null, null, null, null, null],
	      singleTouchStartTime: null,
	      singleTouchMoved: true,
	
	      now: [null, null, null, null, null, null],
	      earlier: [null, null, null, null, null, null]
	  };
	
	  r.redraws = 0;
	  r.showFps = options.showFps;
	
	  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
	  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
	  r.textureOnViewport = options.textureOnViewport;
	  r.wheelSensitivity = options.wheelSensitivity;
	  r.motionBlurEnabled = options.motionBlur; // on by default
	  r.forcedPixelRatio = options.pixelRatio;
	  r.motionBlur = true; // for initial kick off
	  r.motionBlurOpacity = options.motionBlurOpacity;
	  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
	  r.motionBlurPxRatio = 1;
	  r.mbPxRBlurry = 1; //0.8;
	  r.minMbLowQualFrames = 4;
	  r.fullQualityMb = false;
	  r.clearedForMotionBlur = [];
	  r.desktopTapThreshold = options.desktopTapThreshold;
	  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
	  r.touchTapThreshold = options.touchTapThreshold;
	  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
	  r.tapholdDuration = 500;
	
	  r.bindings = [];
	
	  r.registerNodeShapes();
	  r.registerArrowShapes();
	  r.load();
	};
	
	BRp.notify = function(params) {
	  var types;
	  var r = this;
	
	  if( is.array( params.type ) ){
	    types = params.type;
	
	  } else {
	    types = [ params.type ];
	  }
	
	  for( var i = 0; i < types.length; i++ ){
	    var type = types[i];
	
	    switch( type ){
	      case 'destroy':
	        r.destroy();
	        return;
	
	      case 'add':
	      case 'remove':
	      case 'load':
	        r.updateElementsCache();
	        break;
	
	      case 'viewport':
	        r.redrawHint('select', true);
	        break;
	
	      case 'style':
	        r.updateCachedZSortedEles();
	        break;
	    }
	
	    if( type === 'load' || type === 'resize' ){
	      r.invalidateContainerClientCoordsCache();
	      r.matchCanvasSize(r.container);
	    }
	  } // for
	
	  r.redrawHint('eles', true);
	  r.redrawHint('drag', true);
	
	  this.startRenderLoop();
	
	  this.redraw();
	};
	
	BRp.destroy = function(){
	  this.destroyed = true;
	
	  this.cy.stopAnimationLoop();
	
	  for( var i = 0; i < this.bindings.length; i++ ){
	    var binding = this.bindings[i];
	    var b = binding;
	
	    b.target.removeEventListener(b.event, b.handler, b.useCapture);
	  }
	
	  if( this.removeObserver ){
	    this.removeObserver.disconnect();
	  }
	
	  if( this.labelCalcDiv ){
	    try{
	      document.body.removeChild(this.labelCalcDiv);
	    } catch(e){
	      // ie10 issue #1014
	    }
	  }
	};
	
	[
	  _dereq_('./arrow-shapes'),
	  _dereq_('./cached-eles'),
	  _dereq_('./coord-ele-math'),
	  _dereq_('./images'),
	  _dereq_('./load-listeners'),
	  _dereq_('./node-shapes'),
	  _dereq_('./redraw')
	].forEach(function( props ){
	  util.extend( BRp, props );
	});
	
	module.exports = BR;
	
	},{"../../../is":77,"../../../util":94,"./arrow-shapes":54,"./cached-eles":55,"./coord-ele-math":56,"./images":57,"./load-listeners":59,"./node-shapes":60,"./redraw":61}],59:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../../is');
	var util = _dereq_('../../../util');
	var Event = _dereq_('../../../event');
	var Collection = _dereq_('../../../collection');
	
	var BRp = {};
	
	BRp.registerBinding = function(target, event, handler, useCapture){
	  this.bindings.push({
	    target: target,
	    event: event,
	    handler: handler,
	    useCapture: useCapture
	  });
	
	  target.addEventListener(event, handler, useCapture);
	};
	
	BRp.nodeIsDraggable = function(node) {
	  if (node._private.style['opacity'].value !== 0
	    && node._private.style['visibility'].value == 'visible'
	    && node._private.style['display'].value == 'element'
	    && !node.locked()
	    && node.grabbable() ) {
	
	    return true;
	  }
	
	  return false;
	};
	
	BRp.load = function() {
	  var r = this;
	
	  var triggerEvents = function( target, names, e, props ){
	    if( target == null ){
	      target = r.cy;
	    }
	
	    for( var i = 0; i < names.length; i++ ){
	      var name = names[i];
	
	      var event = Event( e, util.extend({ type: name }, props) );
	      target.trigger( event );
	    }
	  };
	
	  var isMultSelKeyDown = function( e ){
	    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
	  };
	
	  var getDragListIds = function(opts){
	    var listHasId;
	
	    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
	      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
	        opts.addToList.hasId = {};
	
	        for( var i = 0; i < opts.addToList.length; i++ ){
	          var ele = opts.addToList[i];
	
	          opts.addToList.hasId[ ele.id() ] = true;
	        }
	      }
	
	      listHasId = opts.addToList.hasId;
	    }
	
	    return listHasId || {};
	  };
	
	  // helper function to determine which child nodes and inner edges
	  // of a compound node to be dragged as well as the grabbed and selected nodes
	  var addDescendantsToDrag = function(node, opts){
	    if( !node._private.cy.hasCompoundNodes() ){
	      return;
	    }
	
	    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do
	
	    var listHasId = getDragListIds( opts );
	
	    var innerNodes = node.descendants();
	
	    for( var i = 0; i < innerNodes.size(); i++ ){
	      var iNode = innerNodes[i];
	      var _p = iNode._private;
	
	      if( opts.inDragLayer ){
	        _p.rscratch.inDragLayer = true;
	      }
	
	      if( opts.addToList && !listHasId[ iNode.id() ] ){
	        opts.addToList.push( iNode );
	        listHasId[ iNode.id() ] = true;
	
	        _p.grabbed = true;
	      }
	
	      var edges = _p.edges;
	      for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
	        edges[j]._private.rscratch.inDragLayer = true;
	      }
	    }
	  };
	
	  // adds the given nodes, and its edges to the drag layer
	  var addNodeToDrag = function(node, opts){
	
	    var _p = node._private;
	    var listHasId = getDragListIds( opts );
	
	    if( opts.inDragLayer ){
	      _p.rscratch.inDragLayer = true;
	    }
	
	    if( opts.addToList && !listHasId[ node.id() ] ){
	      opts.addToList.push( node );
	      listHasId[ node.id() ] = true;
	
	      _p.grabbed = true;
	    }
	
	    var edges = _p.edges;
	    for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
	      edges[i]._private.rscratch.inDragLayer = true;
	    }
	
	    addDescendantsToDrag( node, opts ); // always add to drag
	
	    // also add nodes and edges related to the topmost ancestor
	    updateAncestorsInDragLayer( node, {
	      inDragLayer: opts.inDragLayer
	    } );
	  };
	
	  var freeDraggedElements = function( draggedElements ){
	    if( !draggedElements ){ return; }
	
	    for (var i=0; i < draggedElements.length; i++) {
	
	      var dEi_p = draggedElements[i]._private;
	
	      if(dEi_p.group === 'nodes') {
	        dEi_p.rscratch.inDragLayer = false;
	        dEi_p.grabbed = false;
	
	        var sEdges = dEi_p.edges;
	        for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }
	
	        // for compound nodes, also remove related nodes and edges from the drag layer
	        updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });
	
	      } else if( dEi_p.group === 'edges' ){
	        dEi_p.rscratch.inDragLayer = false;
	      }
	
	    }
	  };
	
	  // helper function to determine which ancestor nodes and edges should go
	  // to the drag layer (or should be removed from drag layer).
	  var updateAncestorsInDragLayer = function(node, opts) {
	
	    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do
	
	    // find top-level parent
	    var parent = node;
	
	    if( !node._private.cy.hasCompoundNodes() ){
	      return;
	    }
	
	    while( parent.parent().nonempty() ){
	      parent = parent.parent()[0];
	    }
	
	    // no parent node: no nodes to add to the drag layer
	    if( parent == node ){
	      return;
	    }
	
	    var nodes = parent.descendants()
	      .merge( parent )
	      .unmerge( node )
	      .unmerge( node.descendants() )
	    ;
	
	    var edges = nodes.connectedEdges();
	
	    var listHasId = getDragListIds( opts );
	
	    for( var i = 0; i < nodes.size(); i++ ){
	      if( opts.inDragLayer !== undefined ){
	        nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
	      }
	
	      if( opts.addToList && !listHasId[ nodes[i].id() ] ){
	        opts.addToList.push( nodes[i] );
	        listHasId[ nodes[i].id() ] = true;
	
	        nodes[i]._private.grabbed = true;
	      }
	    }
	
	    for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
	      edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
	    }
	  };
	
	  if( typeof MutationObserver !== 'undefined' ){
	    r.removeObserver = new MutationObserver(function( mutns ){
	      for( var i = 0; i < mutns.length; i++ ){
	        var mutn = mutns[i];
	        var rNodes = mutn.removedNodes;
	
	        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
	          var rNode = rNodes[j];
	
	          if( rNode === r.container ){
	            r.destroy();
	            break;
	          }
	        } }
	      }
	    });
	
	    if( r.container.parentNode ){
	      r.removeObserver.observe( r.container.parentNode, { childList: true } );
	    }
	  } else {
	    r.registerBinding(r.container, 'DOMNodeRemoved', function(e){
	      r.destroy();
	    });
	  }
	
	
	
	  // auto resize
	  r.registerBinding(window, 'resize', util.debounce( function(e) {
	    r.invalidateContainerClientCoordsCache();
	
	    r.matchCanvasSize(r.container);
	    r.redrawHint('eles', true);
	    r.redraw();
	  }, 100 ) );
	
	  var invalCtnrBBOnScroll = function(domEle){
	    r.registerBinding(domEle, 'scroll', function(e){
	      r.invalidateContainerClientCoordsCache();
	    } );
	  };
	
	  var bbCtnr = r.cy.container();
	
	  for( ;; ){
	
	    invalCtnrBBOnScroll( bbCtnr );
	
	    if( bbCtnr.parentNode ){
	      bbCtnr = bbCtnr.parentNode;
	    } else {
	      break;
	    }
	
	  }
	
	  // stop right click menu from appearing on cy
	  r.registerBinding(r.container, 'contextmenu', function(e){
	    e.preventDefault();
	  });
	
	  var inBoxSelection = function(){
	    return r.selection[4] !== 0;
	  };
	
	  // Primary key
	  r.registerBinding(r.container, 'mousedown', function(e) {
	    e.preventDefault();
	    r.hoverData.capture = true;
	    r.hoverData.which = e.which;
	
	    var cy = r.cy;
	    var pos = r.projectIntoViewport(e.clientX, e.clientY);
	    var select = r.selection;
	    var near = r.findNearestElement(pos[0], pos[1], true, false);
	    var draggedElements = r.dragData.possibleDragElements;
	
	    r.hoverData.mdownPos = pos;
	
	    var checkForTaphold = function(){
	      r.hoverData.tapholdCancelled = false;
	
	      clearTimeout( r.hoverData.tapholdTimeout );
	
	      r.hoverData.tapholdTimeout = setTimeout(function(){
	
	        if( r.hoverData.tapholdCancelled ){
	          return;
	        } else {
	          var ele = r.hoverData.down;
	
	          if( ele ){
	            ele.trigger( Event(e, {
	              type: 'taphold',
	              cyPosition: { x: pos[0], y: pos[1] }
	            }) );
	          } else {
	            cy.trigger( Event(e, {
	              type: 'taphold',
	              cyPosition: { x: pos[0], y: pos[1] }
	            }) );
	          }
	        }
	
	      }, r.tapholdDuration);
	    };
	
	    // Right click button
	    if( e.which == 3 ){
	
	      r.hoverData.cxtStarted = true;
	
	      var cxtEvt = Event(e, {
	        type: 'cxttapstart',
	        cyPosition: { x: pos[0], y: pos[1] }
	      });
	
	      if( near ){
	        near.activate();
	        near.trigger( cxtEvt );
	
	        r.hoverData.down = near;
	      } else {
	        cy.trigger( cxtEvt );
	      }
	
	      r.hoverData.downTime = (new Date()).getTime();
	      r.hoverData.cxtDragged = false;
	
	    // Primary button
	    } else if (e.which == 1) {
	
	      if( near ){
	        near.activate();
	      }
	
	      // Element dragging
	      {
	        // If something is under the cursor and it is draggable, prepare to grab it
	        if (near != null) {
	
	          if( r.nodeIsDraggable(near) ){
	
	            var grabEvent = Event(e, {
	              type: 'grab',
	              cyPosition: { x: pos[0], y: pos[1] }
	            });
	
	            if ( near.isNode() && !near.selected() ){
	
	              draggedElements = r.dragData.possibleDragElements = [];
	              addNodeToDrag( near, { addToList: draggedElements } );
	
	              near.trigger(grabEvent);
	
	            } else if ( near.isNode() && near.selected() ){
	              draggedElements = r.dragData.possibleDragElements = [  ];
	
	              var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });
	
	              for( var i = 0; i < selectedNodes.length; i++ ){
	
	                // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
	                if( r.nodeIsDraggable( selectedNodes[i] ) ){
	                  addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
	                }
	              }
	
	              near.trigger( grabEvent );
	            }
	
	            r.redrawHint('eles', true);
	            r.redrawHint('drag', true);
	
	          }
	
	        }
	
	        r.hoverData.down = near;
	        r.hoverData.downTime = (new Date()).getTime();
	      }
	
	      triggerEvents( near, ['mousedown', 'tapstart', 'vmousedown'], e, {
	        cyPosition: { x: pos[0], y: pos[1] }
	      } );
	
	      if ( near == null ) {
	        select[4] = 1;
	
	        r.data.bgActivePosistion = {
	          x: pos[0],
	          y: pos[1]
	        };
	
	        r.redrawHint('select', true);
	
	        r.redraw();
	      } else if( near.isEdge() ){
	        select[4] = 1; // for future pan
	      }
	
	      checkForTaphold();
	
	    }
	
	    // Initialize selection box coordinates
	    select[0] = select[2] = pos[0];
	    select[1] = select[3] = pos[1];
	
	  }, false);
	
	  r.registerBinding(window, 'mousemove', function(e) {
	    var preventDefault = false;
	    var capture = r.hoverData.capture;
	
	    // save cycles if mouse events aren't to be captured
	    if ( !capture ){
	      var containerPageCoords = r.findContainerClientCoords();
	
	      if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
	        && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
	      ) {
	        // inside container bounds so OK
	      } else {
	        return;
	      }
	
	      var cyContainer = r.container;
	      var target = e.target;
	      var tParent = target.parentNode;
	      var containerIsTarget = false;
	
	      while( tParent ){
	        if( tParent === cyContainer ){
	          containerIsTarget = true;
	          break;
	        }
	
	        tParent = tParent.parentNode;
	      }
	
	      if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
	    }
	
	    var cy = r.cy;
	    var zoom = cy.zoom();
	    var pos = r.projectIntoViewport(e.clientX, e.clientY);
	    var select = r.selection;
	
	    var near = null;
	    if( !r.hoverData.draggingEles ){
	      near = r.findNearestElement(pos[0], pos[1], true, false);
	    }
	    var last = r.hoverData.last;
	    var down = r.hoverData.down;
	
	    var disp = [pos[0] - select[2], pos[1] - select[3]];
	
	    var draggedElements = r.dragData.possibleDragElements;
	
	    var dx = select[2] - select[0];
	    var dx2 = dx * dx;
	    var dy = select[3] - select[1];
	    var dy2 = dy * dy;
	    var dist2 = dx2 + dy2;
	    var rdist2 = dist2 * zoom * zoom;
	
	    var multSelKeyDown = isMultSelKeyDown( e );
	
	    r.hoverData.tapholdCancelled = true;
	
	    var updateDragDelta = function(){
	      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];
	
	      if( dragDelta.length === 0 ){
	        dragDelta.push( disp[0] );
	        dragDelta.push( disp[1] );
	      } else {
	        dragDelta[0] += disp[0];
	        dragDelta[1] += disp[1];
	      }
	    };
	
	
	    preventDefault = true;
	
	    triggerEvents( near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
	      cyPosition: { x: pos[0], y: pos[1] }
	    } );
	
	    // trigger context drag if rmouse down
	    if( r.hoverData.which === 3 ){
	      var cxtEvt = Event(e, {
	        type: 'cxtdrag',
	        cyPosition: { x: pos[0], y: pos[1] }
	      });
	
	      if( down ){
	        down.trigger( cxtEvt );
	      } else {
	        cy.trigger( cxtEvt );
	      }
	
	      r.hoverData.cxtDragged = true;
	
	      if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){
	
	        if( r.hoverData.cxtOver ){
	          r.hoverData.cxtOver.trigger( Event(e, {
	            type: 'cxtdragout',
	            cyPosition: { x: pos[0], y: pos[1] }
	          }) );
	        }
	
	        r.hoverData.cxtOver = near;
	
	        if( near ){
	          near.trigger( Event(e, {
	            type: 'cxtdragover',
	            cyPosition: { x: pos[0], y: pos[1] }
	          }) );
	        }
	
	      }
	
	    // Check if we are drag panning the entire graph
	    } else if (r.hoverData.dragging) {
	      preventDefault = true;
	
	      if( cy.panningEnabled() && cy.userPanningEnabled() ){
	        var deltaP;
	
	        if( r.hoverData.justStartedPan ){
	          var mdPos = r.hoverData.mdownPos;
	
	          deltaP = {
	            x: ( pos[0] - mdPos[0] ) * zoom,
	            y: ( pos[1] - mdPos[1] ) * zoom
	          };
	
	          r.hoverData.justStartedPan = false;
	
	        } else {
	          deltaP = {
	            x: disp[0] * zoom,
	            y: disp[1] * zoom
	          };
	
	        }
	
	        cy.panBy( deltaP );
	
	        r.hoverData.dragged = true;
	      }
	
	      // Needs reproject due to pan changing viewport
	      pos = r.projectIntoViewport(e.clientX, e.clientY);
	
	    // Checks primary button down & out of time & mouse not moved much
	    } else if(
	        select[4] == 1 && (down == null || down.isEdge())
	    ){
	
	      if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
	        r.data.bgActivePosistion = undefined;
	        r.hoverData.selecting = true;
	
	        r.redrawHint('select', true);
	        r.redraw();
	
	      } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
	        r.hoverData.dragging = true;
	        r.hoverData.justStartedPan = true;
	        select[4] = 0;
	
	        r.data.bgActivePosistion = {
	          x: pos[0],
	          y: pos[1]
	        };
	
	        r.redrawHint('select', true);
	        r.redraw();
	      }
	
	      if( down && down.isEdge() && down.active() ){ down.unactivate(); }
	
	    } else {
	      if( down && down.isEdge() && down.active() ){ down.unactivate(); }
	
	      if (near != last) {
	
	        if (last) {
	          triggerEvents( last, ['mouseout', 'tapdragout'], e, {
	            cyPosition: { x: pos[0], y: pos[1] }
	          } );
	        }
	
	        if (near) {
	          triggerEvents( near, ['mouseover', 'tapdragover'], e, {
	            cyPosition: { x: pos[0], y: pos[1] }
	          } );
	        }
	
	        r.hoverData.last = near;
	      }
	
	      if( down && down.isNode() && r.nodeIsDraggable(down) ){
	
	        if( rdist2 >= r.desktopTapThreshold2 ){ // then drag
	
	          var justStartedDrag = !r.dragData.didDrag;
	
	          if( justStartedDrag ) {
	            r.redrawHint('eles', true);
	          }
	
	          r.dragData.didDrag = true; // indicate that we actually did drag the node
	
	          var toTrigger = [];
	
	          for( var i = 0; i < draggedElements.length; i++ ){
	            var dEle = draggedElements[i];
	
	            // now, add the elements to the drag layer if not done already
	            if( !r.hoverData.draggingEles ){
	              addNodeToDrag( dEle, { inDragLayer: true } );
	            }
	
	            // Locked nodes not draggable, as well as non-visible nodes
	            if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
	              var dPos = dEle._private.position;
	
	              toTrigger.push( dEle );
	
	              if( is.number(disp[0]) && is.number(disp[1]) ){
	                var updatePos = !dEle.isParent();
	
	                if( updatePos ){
	                  dPos.x += disp[0];
	                  dPos.y += disp[1];
	                }
	
	                if( justStartedDrag ){
	                  var dragDelta = r.hoverData.dragDelta;
	
	                  if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
	                    dPos.x += dragDelta[0];
	                    dPos.y += dragDelta[1];
	                  }
	                }
	              }
	
	            }
	          }
	
	          r.hoverData.draggingEles = true;
	
	          var tcol = (Collection(cy, toTrigger));
	
	          tcol.updateCompoundBounds();
	          tcol.trigger('position drag');
	
	          r.redrawHint('drag', true);
	          r.redraw();
	
	        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
	          updateDragDelta();
	        }
	      }
	
	      // prevent the dragging from triggering text selection on the page
	      preventDefault = true;
	    }
	
	    select[2] = pos[0]; select[3] = pos[1];
	
	    if( preventDefault ){
	      if(e.stopPropagation) e.stopPropagation();
	        if(e.preventDefault) e.preventDefault();
	        return false;
	      }
	  }, false);
	
	  r.registerBinding(window, 'mouseup', function(e) {
	    var capture = r.hoverData.capture;
	    if (!capture) { return; }
	    r.hoverData.capture = false;
	
	    var cy = r.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.selection;
	    var near = r.findNearestElement(pos[0], pos[1], true, false);
	    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
	    var multSelKeyDown = isMultSelKeyDown( e );
	
	    if( r.data.bgActivePosistion ){
	      r.redrawHint('select', true);
	      r.redraw();
	    }
	
	    r.hoverData.tapholdCancelled = true;
	
	    r.data.bgActivePosistion = undefined; // not active bg now
	
	    if( down ){
	      down.unactivate();
	    }
	
	    if( r.hoverData.which === 3 ){
	      var cxtEvt = Event(e, {
	        type: 'cxttapend',
	        cyPosition: { x: pos[0], y: pos[1] }
	      });
	
	      if( down ){
	        down.trigger( cxtEvt );
	      } else {
	        cy.trigger( cxtEvt );
	      }
	
	      if( !r.hoverData.cxtDragged ){
	        var cxtTap = Event(e, {
	          type: 'cxttap',
	          cyPosition: { x: pos[0], y: pos[1] }
	        });
	
	        if( down ){
	          down.trigger( cxtTap );
	        } else {
	          cy.trigger( cxtTap );
	        }
	      }
	
	      r.hoverData.cxtDragged = false;
	      r.hoverData.which = null;
	
	    } else if( r.hoverData.which === 1 ) {
	
	      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
	      if ( (down == null) // not mousedown on node
	        && !r.dragData.didDrag // didn't move the node around
	        && !r.hoverData.selecting // not box selection
	        && !r.hoverData.dragged // didn't pan
	        && !isMultSelKeyDown( e )
	      ) {
	
	        cy.$(function(){
	          return this.selected();
	        }).unselect();
	
	        if (draggedElements.length > 0) {
	          r.redrawHint('eles', true);
	        }
	
	        r.dragData.possibleDragElements = draggedElements = [];
	      }
	
	      triggerEvents( near, ['mouseup', 'tapend', 'vmouseup'], e, {
	        cyPosition: { x: pos[0], y: pos[1] }
	      } );
	
	      if(
	        !r.dragData.didDrag // didn't move a node around
	        && !r.hoverData.dragged // didn't pan
	      ){
	        triggerEvents( near, ['click', 'tap', 'vclick'], e, {
	          cyPosition: { x: pos[0], y: pos[1] }
	        } );
	      }
	
	      // Single selection
	      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
	        if( near != null && near._private.selectable ){
	
	          if( r.hoverData.dragging ){
	            // if panning, don't change selection state
	          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
	            if( near.selected() ){
	              near.unselect();
	            } else {
	              near.select();
	            }
	          } else {
	            if( !multSelKeyDown ){
	              cy.$(':selected').unmerge( near ).unselect();
	              near.select();
	            }
	          }
	
	          r.redrawHint('eles', true);
	        }
	      }
	
	      if ( r.hoverData.selecting ) {
	        var newlySelected = [];
	        var box = r.getAllInBox( select[0], select[1], select[2], select[3] );
	
	        r.redrawHint('select', true);
	
	        if( box.length > 0 ) {
	          r.redrawHint('eles', true);
	        }
	
	        for( var i = 0; i < box.length; i++ ){
	          if( box[i]._private.selectable ){
	            newlySelected.push( box[i] );
	          }
	        }
	
	        var newlySelCol = Collection( cy, newlySelected );
	
	        if( cy.selectionType() === 'additive' ){
	          newlySelCol.select();
	        } else {
	          if( !multSelKeyDown ){
	            cy.$(':selected').unmerge( newlySelCol ).unselect();
	          }
	
	          newlySelCol.select();
	        }
	
	        // always need redraw in case eles unselectable
	        r.redraw();
	
	      }
	
	      // Cancel drag pan
	      if( r.hoverData.dragging ){
	        r.hoverData.dragging = false;
	
	        r.redrawHint('select', true);
	        r.redrawHint('eles', true);
	
	        r.redraw();
	      }
	
	      if (!select[4]) {
	
	
	        r.redrawHint('drag', true);
	        r.redrawHint('eles', true);
	
	        freeDraggedElements( draggedElements );
	
	        if( down ){ down.trigger('free'); }
	      }
	
	    } // else not right mouse
	
	    select[4] = 0; r.hoverData.down = null;
	
	    r.hoverData.cxtStarted = false;
	    r.hoverData.draggingEles = false;
	    r.hoverData.selecting = false;
	    r.dragData.didDrag = false;
	    r.hoverData.dragged = false;
	    r.hoverData.dragDelta = [];
	
	  }, false);
	
	  var wheelHandler = function(e) {
	
	
	    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom
	
	    var cy = r.cy;
	    var pos = r.projectIntoViewport(e.clientX, e.clientY);
	    var rpos = [pos[0] * cy.zoom() + cy.pan().x,
	                  pos[1] * cy.zoom() + cy.pan().y];
	
	    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
	      e.preventDefault();
	      return;
	    }
	
	    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
	      e.preventDefault();
	
	      r.data.wheelZooming = true;
	      clearTimeout( r.data.wheelTimeout );
	      r.data.wheelTimeout = setTimeout(function(){
	        r.data.wheelZooming = false;
	
	        r.redrawHint('eles', true);
	        r.redraw();
	      }, 150);
	
	      var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
	      diff = diff * r.wheelSensitivity;
	
	      var needsWheelFix = e.deltaMode === 1;
	      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
	        diff *= 33;
	      }
	
	      cy.zoom({
	        level: cy.zoom() * Math.pow(10, diff),
	        renderedPosition: { x: rpos[0], y: rpos[1] }
	      });
	    }
	
	  };
	
	  // Functions to help with whether mouse wheel should trigger zooming
	  // --
	  r.registerBinding(r.container, 'wheel', wheelHandler, true);
	
	  // disable nonstandard wheel events
	  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
	  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
	  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox
	
	  r.registerBinding(window, 'scroll', function(e){
	    r.scrollingPage = true;
	
	    clearTimeout( r.scrollingPageTimeout );
	    r.scrollingPageTimeout = setTimeout(function(){
	      r.scrollingPage = false;
	    }, 250);
	  }, true);
	
	  // Functions to help with handling mouseout/mouseover on the Cytoscape container
	        // Handle mouseout on Cytoscape container
	  r.registerBinding(r.container, 'mouseout', function(e) {
	    var pos = r.projectIntoViewport(e.clientX, e.clientY);
	
	    r.cy.trigger(Event(e, {
	      type: 'mouseout',
	      cyPosition: { x: pos[0], y: pos[1] }
	    }));
	  }, false);
	
	  r.registerBinding(r.container, 'mouseover', function(e) {
	    var pos = r.projectIntoViewport(e.clientX, e.clientY);
	
	    r.cy.trigger(Event(e, {
	      type: 'mouseover',
	      cyPosition: { x: pos[0], y: pos[1] }
	    }));
	  }, false);
	
	  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
	  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
	  var center1, modelCenter1; // center point on start pinch to zoom
	  var offsetLeft, offsetTop;
	  var containerWidth, containerHeight;
	  var twoFingersStartInside;
	
	  var distance = function(x1, y1, x2, y2){
	    return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
	  };
	
	  var distanceSq = function(x1, y1, x2, y2){
	    return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
	  };
	
	  var touchstartHandler;
	  r.registerBinding(r.container, 'touchstart', touchstartHandler = function(e) {
	    r.touchData.capture = true;
	    r.data.bgActivePosistion = undefined;
	
	    var cy = r.cy;
	    var nodes = r.getCachedNodes();
	    var edges = r.getCachedEdges();
	    var now = r.touchData.now;
	    var earlier = r.touchData.earlier;
	
	    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
	    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
	    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
	
	
	    // record starting points for pinch-to-zoom
	    if( e.touches[1] ){
	
	      // anything in the set of dragged eles should be released
	      var release = function( eles ){
	        for( var i = 0; i < eles.length; i++ ){
	          eles[i]._private.grabbed = false;
	          eles[i]._private.rscratch.inDragLayer = false;
	          if( eles[i].active() ){ eles[i].unactivate(); }
	        }
	      };
	      release(nodes);
	      release(edges);
	
	      var offsets = r.findContainerClientCoords();
	      offsetLeft = offsets[0];
	      offsetTop = offsets[1];
	      containerWidth = offsets[2];
	      containerHeight = offsets[3];
	
	      f1x1 = e.touches[0].clientX - offsetLeft;
	      f1y1 = e.touches[0].clientY - offsetTop;
	
	      f2x1 = e.touches[1].clientX - offsetLeft;
	      f2y1 = e.touches[1].clientY - offsetTop;
	
	      twoFingersStartInside =
	           0 <= f1x1 && f1x1 <= containerWidth
	        && 0 <= f2x1 && f2x1 <= containerWidth
	        && 0 <= f1y1 && f1y1 <= containerHeight
	        && 0 <= f2y1 && f2y1 <= containerHeight
	      ;
	
	      var pan = cy.pan();
	      var zoom = cy.zoom();
	
	      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
	      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
	      center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
	      modelCenter1 = [
	        (center1[0] - pan.x) / zoom,
	        (center1[1] - pan.y) / zoom
	      ];
	
	      // consider context tap
	      var cxtDistThreshold = 200;
	      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
	      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){
	
	        var near1 = r.findNearestElement(now[0], now[1], true, true);
	        var near2 = r.findNearestElement(now[2], now[3], true, true);
	
	        if( near1 && near1.isNode() ){
	          near1.activate().trigger( Event(e, {
	            type: 'cxttapstart',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	          r.touchData.start = near1;
	
	        } else if( near2 && near2.isNode() ){
	          near2.activate().trigger( Event(e, {
	            type: 'cxttapstart',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	          r.touchData.start = near2;
	
	        } else {
	          cy.trigger( Event(e, {
	            type: 'cxttapstart',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	          r.touchData.start = null;
	        }
	
	        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
	        r.touchData.cxt = true;
	        r.touchData.cxtDragged = false;
	        r.data.bgActivePosistion = undefined;
	
	        r.redraw();
	        return;
	
	      }
	
	    }
	
	    if (e.touches[2]) {
	
	    } else if (e.touches[1]) {
	
	    } else if (e.touches[0]) {
	      var near = r.findNearestElement(now[0], now[1], true, true);
	
	      if (near != null) {
	        near.activate();
	
	        r.touchData.start = near;
	
	        if( near.isNode() && r.nodeIsDraggable(near) ){
	
	          var draggedEles = r.dragData.touchDragEles = [];
	
	          r.redrawHint('eles', true);
	          r.redrawHint('drag', true);
	
	          if( near.selected() ){
	            // reset drag elements, since near will be added again
	
	            var selectedNodes = cy.$(function(){
	              return this.isNode() && this.selected();
	            });
	
	            for( var k = 0; k < selectedNodes.length; k++ ){
	              var selectedNode = selectedNodes[k];
	
	              if( r.nodeIsDraggable(selectedNode) ){
	                addNodeToDrag( selectedNode, { addToList: draggedEles } );
	              }
	            }
	          } else {
	            addNodeToDrag( near, { addToList: draggedEles } );
	          }
	
	          near.trigger( Event(e, {
	            type: 'grab',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	        }
	      }
	
	      triggerEvents( near, ['touchstart', 'tapstart', 'vmousedown'], e, {
	        cyPosition: { x: now[0], y: now[1] }
	      } );
	
	      if (near == null) {
	        r.data.bgActivePosistion = {
	          x: pos[0],
	          y: pos[1]
	        };
	
	        r.redrawHint('select', true);
	        r.redraw();
	      }
	
	
	      // Tap, taphold
	      // -----
	
	      for (var i=0; i<now.length; i++) {
	        earlier[i] = now[i];
	        r.touchData.startPosition[i] = now[i];
	      }
	
	      r.touchData.singleTouchMoved = false;
	      r.touchData.singleTouchStartTime = +new Date();
	
	      clearTimeout( r.touchData.tapholdTimeout );
	      r.touchData.tapholdTimeout = setTimeout(function() {
	        if(
	            r.touchData.singleTouchMoved === false
	            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
	            && !r.touchData.selecting // box selection shouldn't allow taphold through
	        ){
	          triggerEvents( r.touchData.start, ['taphold'], e, {
	            cyPosition: { x: now[0], y: now[1] }
	          } );
	
	          if (!r.touchData.start) {
	            cy.$(':selected').unselect();
	          }
	
	        }
	      }, r.tapholdDuration);
	    }
	
	  }, false);
	
	  var touchmoveHandler;
	  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) {
	
	    var select = r.selection;
	    var capture = r.touchData.capture;
	    var cy = r.cy;
	    var now = r.touchData.now; var earlier = r.touchData.earlier;
	    var zoom = cy.zoom();
	
	    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
	    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
	    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
	
	    var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
	    var startPos = r.touchData.startPosition;
	    var dx = now[0] - startPos[0];
	    var dx2 = dx * dx;
	    var dy = now[1] - startPos[1];
	    var dy2 = dy * dy;
	    var dist2 = dx2 + dy2;
	    var rdist2 = dist2 * zoom * zoom;
	
	    // context swipe cancelling
	    if( capture && r.touchData.cxt ){
	      e.preventDefault();
	
	      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
	      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
	      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
	      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
	      var factorSq = distance2Sq / distance1Sq;
	
	      var distThreshold = 150;
	      var distThresholdSq = distThreshold * distThreshold;
	      var factorThreshold = 1.5;
	      var factorThresholdSq = factorThreshold * factorThreshold;
	
	      // cancel ctx gestures if the distance b/t the fingers increases
	      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
	        r.touchData.cxt = false;
	        if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
	        r.data.bgActivePosistion = undefined;
	        r.redrawHint('select', true);
	
	        var cxtEvt = Event(e, {
	          type: 'cxttapend',
	          cyPosition: { x: now[0], y: now[1] }
	        });
	        if( r.touchData.start ){
	          r.touchData.start.trigger( cxtEvt );
	        } else {
	          cy.trigger( cxtEvt );
	        }
	      }
	
	    }
	
	    // context swipe
	    if( capture && r.touchData.cxt ){
	      var cxtEvt = Event(e, {
	        type: 'cxtdrag',
	        cyPosition: { x: now[0], y: now[1] }
	      });
	      r.data.bgActivePosistion = undefined;
	      r.redrawHint('select', true);
	
	      if( r.touchData.start ){
	        r.touchData.start.trigger( cxtEvt );
	      } else {
	        cy.trigger( cxtEvt );
	      }
	
	      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
	      r.touchData.cxtDragged = true;
	
	      var near = r.findNearestElement(now[0], now[1], true, true);
	
	      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){
	
	        if( r.touchData.cxtOver ){
	          r.touchData.cxtOver.trigger( Event(e, {
	            type: 'cxtdragout',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	        }
	
	        r.touchData.cxtOver = near;
	
	        if( near ){
	          near.trigger( Event(e, {
	            type: 'cxtdragover',
	            cyPosition: { x: now[0], y: now[1] }
	          }) );
	
	        }
	
	      }
	
	    // box selection
	    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
	      e.preventDefault();
	
	      r.data.bgActivePosistion = undefined;
	
	      this.lastThreeTouch = +new Date();
	      r.touchData.selecting = true;
	
	      r.redrawHint('select', true);
	
	      if( !select || select.length === 0 || select[0] === undefined ){
	        select[0] = (now[0] + now[2] + now[4])/3;
	        select[1] = (now[1] + now[3] + now[5])/3;
	        select[2] = (now[0] + now[2] + now[4])/3 + 1;
	        select[3] = (now[1] + now[3] + now[5])/3 + 1;
	      } else {
	        select[2] = (now[0] + now[2] + now[4])/3;
	        select[3] = (now[1] + now[3] + now[5])/3;
	      }
	
	      select[4] = 1;
	      r.touchData.selecting = true;
	
	      r.redraw();
	
	    // pinch to zoom
	    } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
	      e.preventDefault();
	
	      r.data.bgActivePosistion = undefined;
	      r.redrawHint('select', true);
	
	      var draggedEles = r.dragData.touchDragEles;
	      if( draggedEles ){
	        r.redrawHint('drag', true);
	
	        for( var i = 0; i < draggedEles.length; i++ ){
	          draggedEles[i]._private.grabbed = false;
	          draggedEles[i]._private.rscratch.inDragLayer = false;
	        }
	      }
	
	      // (x2, y2) for fingers 1 and 2
	      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
	      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
	
	
	      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
	      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
	      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
	      var factor = distance2 / distance1;
	
	      if( factor != 1 && twoFingersStartInside){
	        // delta finger1
	        var df1x = f1x2 - f1x1;
	        var df1y = f1y2 - f1y1;
	
	        // delta finger 2
	        var df2x = f2x2 - f2x1;
	        var df2y = f2y2 - f2y1;
	
	        // translation is the normalised vector of the two fingers movement
	        // i.e. so pinching cancels out and moving together pans
	        var tx = (df1x + df2x)/2;
	        var ty = (df1y + df2y)/2;
	
	        // adjust factor by the speed multiplier
	        // var speed = 1.5;
	        // if( factor > 1 ){
	        //   factor = (factor - 1) * speed + 1;
	        // } else {
	        //   factor = 1 - (1 - factor) * speed;
	        // }
	
	        // now calculate the zoom
	        var zoom1 = cy.zoom();
	        var zoom2 = zoom1 * factor;
	        var pan1 = cy.pan();
	
	        // the model center point converted to the current rendered pos
	        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
	        var ctry = modelCenter1[1] * zoom1 + pan1.y;
	
	        var pan2 = {
	          x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
	          y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
	        };
	
	        // remove dragged eles
	        if( r.touchData.start ){
	          var draggedEles = r.dragData.touchDragEles;
	
	          if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
	            var dEi_p = draggedEles[i]._private;
	
	            dEi_p.grabbed = false;
	            dEi_p.rscratch.inDragLayer = false;
	          } }
	
	          var start_p = r.touchData.start._private;
	          start_p.active = false;
	          start_p.grabbed = false;
	          start_p.rscratch.inDragLayer = false;
	
	          r.redrawHint('drag', true);
	
	          r.touchData.start
	            .trigger('free')
	            .trigger('unactivate')
	          ;
	        }
	
	        cy.viewport({
	          zoom: zoom2,
	          pan: pan2,
	          cancelOnFailedZoom: true
	        });
	
	        distance1 = distance2;
	        f1x1 = f1x2;
	        f1y1 = f1y2;
	        f2x1 = f2x2;
	        f2y1 = f2y2;
	
	        r.pinching = true;
	      }
	
	      // Re-project
	      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
	      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
	      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
	
	    } else if (e.touches[0]) {
	      var start = r.touchData.start;
	      var last = r.touchData.last;
	      var near = near || r.findNearestElement(now[0], now[1], true, true);
	
	      if( start != null ){
	        e.preventDefault();
	      }
	
	      // dragging nodes
	      if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){
	
	        if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
	          var draggedEles = r.dragData.touchDragEles;
	          var justStartedDrag = !r.dragData.didDrag;
	
	          for( var k = 0; k < draggedEles.length; k++ ){
	            var draggedEle = draggedEles[k];
	
	            if( justStartedDrag ){
	              addNodeToDrag( draggedEle, { inDragLayer: true } );
	            }
	
	            if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
	              r.dragData.didDrag = true;
	              var dPos = draggedEle._private.position;
	              var updatePos = !draggedEle.isParent();
	
	              if( updatePos && is.number(disp[0]) && is.number(disp[1]) ){
	                dPos.x += disp[0];
	                dPos.y += disp[1];
	              }
	
	              if( justStartedDrag ){
	                r.redrawHint('eles', true);
	
	                var dragDelta = r.touchData.dragDelta;
	
	                if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
	                  dPos.x += dragDelta[0];
	                  dPos.y += dragDelta[1];
	                }
	
	              }
	            }
	          }
	
	          var tcol = Collection(cy, draggedEles);
	
	          tcol.updateCompoundBounds();
	          tcol.trigger('position drag');
	
	          r.hoverData.draggingEles = true;
	
	          r.redrawHint('drag', true);
	
	          if(
	               r.touchData.startPosition[0] == earlier[0]
	            && r.touchData.startPosition[1] == earlier[1]
	          ){
	
	            r.redrawHint('eles', true);
	          }
	
	          r.redraw();
	        } else { // otherise keep track of drag delta for later
	          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];
	
	          if( dragDelta.length === 0 ){
	            dragDelta.push( disp[0] );
	            dragDelta.push( disp[1] );
	          } else {
	            dragDelta[0] += disp[0];
	            dragDelta[1] += disp[1];
	          }
	        }
	      }
	
	      // touchmove
	      {
	        triggerEvents( (start || near), ['touchmove', 'tapdrag', 'vmousemove'], e, {
	          cyPosition: { x: now[0], y: now[1] }
	        } );
	
	        if (near != last) {
	          if (last) { last.trigger(Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
	          if (near) { near.trigger(Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
	        }
	
	        r.touchData.last = near;
	      }
	
	      // check to cancel taphold
	      for (var i=0;i<now.length;i++) {
	        if( now[i]
	          && r.touchData.startPosition[i]
	          && rdist2 > r.touchTapThreshold2 ){
	
	          r.touchData.singleTouchMoved = true;
	        }
	      }
	
	      // panning
	      if(
	          capture
	          && ( start == null || start.isEdge() )
	          && cy.panningEnabled() && cy.userPanningEnabled()
	      ){
	
	        e.preventDefault();
	
	        if( r.swipePanning ){
	          cy.panBy({
	            x: disp[0] * zoom,
	            y: disp[1] * zoom
	          });
	
	        } else if( rdist2 >= r.touchTapThreshold2 ){
	          r.swipePanning = true;
	
	          cy.panBy({
	            x: dx * zoom,
	            y: dy * zoom
	          });
	
	          if( start ){
	            start.unactivate();
	
	            if( !r.data.bgActivePosistion ){
	              r.data.bgActivePosistion = {
	                x: now[0],
	                y: now[1]
	              };
	            }
	
	            r.redrawHint('select', true);
	
	            r.touchData.start = null;
	          }
	        }
	
	        // Re-project
	        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
	        now[0] = pos[0]; now[1] = pos[1];
	      }
	    }
	
	    for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
	    //r.redraw();
	
	  }, false);
	
	  var touchcancelHandler;
	  r.registerBinding(window, 'touchcancel', touchcancelHandler = function(e) {
	    var start = r.touchData.start;
	
	    r.touchData.capture = false;
	
	    if( start ){
	      start.unactivate();
	    }
	  });
	
	  var touchendHandler;
	  r.registerBinding(window, 'touchend', touchendHandler = function(e) {
	    var start = r.touchData.start;
	
	    var capture = r.touchData.capture;
	
	    if( capture ){
	      r.touchData.capture = false;
	
	      e.preventDefault();
	    } else {
	      return;
	    }
	
	    var select = r.selection;
	
	    r.swipePanning = false;
	    r.hoverData.draggingEles = false;
	
	    var cy = r.cy;
	    var zoom = cy.zoom();
	    var now = r.touchData.now;
	    var earlier = r.touchData.earlier;
	
	    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
	    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
	    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
	
	    if( start ){
	      start.unactivate();
	    }
	
	    var ctxTapend;
	    if( r.touchData.cxt ){
	      ctxTapend = Event(e, {
	        type: 'cxttapend',
	        cyPosition: { x: now[0], y: now[1] }
	      });
	
	      if( start ){
	        start.trigger( ctxTapend );
	      } else {
	        cy.trigger( ctxTapend );
	      }
	
	      if( !r.touchData.cxtDragged ){
	        var ctxTap = Event(e, {
	          type: 'cxttap',
	          cyPosition: { x: now[0], y: now[1] }
	        });
	
	        if( start ){
	          start.trigger( ctxTap );
	        } else {
	          cy.trigger( ctxTap );
	        }
	
	      }
	
	      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
	      r.touchData.cxt = false;
	      r.touchData.start = null;
	
	      r.redraw();
	      return;
	    }
	
	    // no more box selection if we don't have three fingers
	    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
	      r.touchData.selecting = false;
	
	      var newlySelected = [];
	      var box = r.getAllInBox( select[0], select[1], select[2], select[3] );
	
	      select[0] = undefined;
	      select[1] = undefined;
	      select[2] = undefined;
	      select[3] = undefined;
	      select[4] = 0;
	
	      r.redrawHint('select', true);
	
	      for( var i = 0; i< box.length; i++ ) {
	        if( box[i]._private.selectable ){
	          newlySelected.push( box[i] );
	        }
	      }
	
	      var newlySelCol = Collection( cy, newlySelected );
	
	      newlySelCol.select();
	
	      if( newlySelCol.length > 0 ) {
	        r.redrawHint('eles', true);
	      } else {
	        r.redraw();
	      }
	    }
	
	    var updateStartStyle = false;
	
	    if( start != null ){
	      start._private.active = false;
	      updateStartStyle = true;
	      start.unactivate();
	    }
	
	    if (e.touches[2]) {
	      r.data.bgActivePosistion = undefined;
	      r.redrawHint('select', true);
	    } else if (e.touches[1]) {
	
	    } else if (e.touches[0]) {
	
	    // Last touch released
	    } else if (!e.touches[0]) {
	
	      r.data.bgActivePosistion = undefined;
	      r.redrawHint('select', true);
	
	      var draggedEles = r.dragData.touchDragEles;
	
	      if (start != null ) {
	
	        var startWasGrabbed = start._private.grabbed;
	
	        freeDraggedElements( draggedEles );
	
	        r.redrawHint('drag', true);
	        r.redrawHint('eles', true);
	
	        if( startWasGrabbed ){
	          start.trigger('free');
	        }
	
	        triggerEvents( start, ['touchend', 'tapend', 'vmouseup'], e, {
	          cyPosition: { x: now[0], y: now[1] }
	        } );
	
	        start.unactivate();
	
	        r.touchData.start = null;
	
	      } else {
	        var near = r.findNearestElement(now[0], now[1], true, true);
	
	        triggerEvents( near, ['touchend', 'tapend', 'vmouseup'], e, {
	          cyPosition: { x: now[0], y: now[1] }
	        } );
	
	      }
	
	      var dx = r.touchData.startPosition[0] - now[0];
	      var dx2 = dx * dx;
	      var dy = r.touchData.startPosition[1] - now[1];
	      var dy2 = dy * dy;
	      var dist2 = dx2 + dy2;
	      var rdist2 = dist2 * zoom * zoom;
	
	      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
	      if (start != null
	          && !r.dragData.didDrag // didn't drag nodes around
	          && start._private.selectable
	          && rdist2 < r.touchTapThreshold2
	          && !r.pinching // pinch to zoom should not affect selection
	      ) {
	
	        if( cy.selectionType() === 'single' ){
	          cy.$(':selected').unmerge( start ).unselect();
	          start.select();
	        } else {
	          if( start.selected() ){
	            start.unselect();
	          } else {
	            start.select();
	          }
	        }
	
	        updateStartStyle = true;
	
	
	        r.redrawHint('eles', true);
	      }
	
	      // Tap event, roughly same as mouse click event for touch
	      if( !r.touchData.singleTouchMoved ){
	        triggerEvents( start, ['tap', 'vclick'], e, {
	          cyPosition: { x: now[0], y: now[1] }
	        } );
	      }
	
	      r.touchData.singleTouchMoved = true;
	    }
	
	    for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }
	
	    r.dragData.didDrag = false; // reset for next mousedown
	
	    if( e.touches.length === 0 ){
	      r.touchData.dragDelta = [];
	    }
	
	    if( updateStartStyle && start ){
	      start.updateStyle(false);
	    }
	
	    if( e.touches.length < 2 ){
	      r.pinching = false;
	      r.redrawHint('eles', true);
	      r.redraw();
	    }
	
	    //r.redraw();
	
	  }, false);
	
	  // fallback compatibility layer for ms pointer events
	  if( typeof TouchEvent === 'undefined' ){
	
	    var pointers = [];
	
	    var makeTouch = function( e ){
	      return {
	        clientX: e.clientX,
	        clientY: e.clientY,
	        force: 1,
	        identifier: e.pointerId,
	        pageX: e.pageX,
	        pageY: e.pageY,
	        radiusX: e.width/2,
	        radiusY: e.height/2,
	        screenX: e.screenX,
	        screenY: e.screenY,
	        target: e.target
	      };
	    };
	
	    var makePointer = function( e ){
	      return {
	        event: e,
	        touch: makeTouch(e)
	      };
	    };
	
	    var addPointer = function( e ){
	      pointers.push( makePointer(e) );
	    };
	
	    var removePointer = function( e ){
	      for( var i = 0; i < pointers.length; i++ ){
	        var p = pointers[i];
	
	        if( p.event.pointerId === e.pointerId ){
	          pointers.splice( i, 1 );
	          return;
	        }
	      }
	    };
	
	    var updatePointer = function( e ){
	      var p = pointers.filter(function( p ){
	        return p.event.pointerId === e.pointerId;
	      })[0];
	
	      p.event = e;
	      p.touch = makeTouch(e);
	    };
	
	    var addTouchesToEvent = function( e ){
	      e.touches = pointers.map(function( p ){
	        return p.touch;
	      });
	    };
	
	    var pointerIsMouse = function( e ){
	      return e.pointerType === 'mouse' || e.pointerType === 4;
	    };
	
	    r.registerBinding(r.container, 'pointerdown', function(e){
	      if( pointerIsMouse(e) ){ return; } // mouse already handled
	
	      e.preventDefault();
	
	      addPointer( e );
	
	      addTouchesToEvent( e );
	      touchstartHandler( e );
	    });
	
	    r.registerBinding(r.container, 'pointerup', function(e){
	      if( pointerIsMouse(e) ){ return; } // mouse already handled
	
	      removePointer( e );
	
	      addTouchesToEvent( e );
	      touchendHandler( e );
	    });
	
	    r.registerBinding(r.container, 'pointercancel', function(e){
	      if( pointerIsMouse(e) ){ return; } // mouse already handled
	
	      removePointer( e );
	
	      addTouchesToEvent( e );
	      touchcancelHandler( e );
	    });
	
	    r.registerBinding(r.container, 'pointermove', function(e){
	      if( pointerIsMouse(e) ){ return; } // mouse already handled
	
	      e.preventDefault();
	
	      updatePointer( e );
	
	      addTouchesToEvent( e );
	      touchmoveHandler( e );
	    });
	
	  }
	};
	
	module.exports = BRp;
	
	},{"../../../collection":23,"../../../event":42,"../../../is":77,"../../../util":94}],60:[function(_dereq_,module,exports){
	'use strict';
	
	var math = _dereq_('../../../math');
	
	var BRp = {};
	
	BRp.registerNodeShapes = function(){
	  var nodeShapes = this.nodeShapes = {};
	  var renderer = this;
	
	  nodeShapes['ellipse'] = {
	    name: 'ellipse',
	
	    draw: function( context, centerX, centerY, width, height ){
	      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
	    },
	
	    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
	      return math.intersectLineEllipse(
	        x, y,
	        nodeX,
	        nodeY,
	        width / 2 + padding,
	        height / 2 + padding)
	      ;
	    },
	
	    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
	      x -= centerX;
	      y -= centerY;
	
	      x /= (width / 2 + padding);
	      y /= (height / 2 + padding);
	
	      return x*x + y*y <= 1;
	    }
	  };
	
	  function generatePolygon( name, points ){
	    return ( nodeShapes[name] = {
	      name: name,
	
	      points: points,
	
	      draw: function( context, centerX, centerY, width, height ){
	        renderer.nodeShapeImpl('polygon')( context, centerX, centerY, width, height, this.points );
	      },
	
	      intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
	        return math.polygonIntersectLine(
	            x, y,
	            this.points,
	            nodeX,
	            nodeY,
	            width / 2, height / 2,
	            padding)
	          ;
	      },
	
	      checkPoint: function( x, y, padding, width, height, centerX, centerY ){
	        return math.pointInsidePolygon(x, y, nodeShapes[name].points,
	          centerX, centerY, width, height, [0, -1], padding)
	        ;
	      }
	    } );
	  }
	
	  generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare(3, 0) );
	
	  generatePolygon( 'square', math.generateUnitNgonPointsFitToSquare(4, 0) );
	  nodeShapes['rectangle'] = nodeShapes['square'];
	
	  nodeShapes['roundrectangle'] = {
	    name: 'roundrectangle',
	
	    points: math.generateUnitNgonPointsFitToSquare(4, 0),
	
	    draw: function( context, centerX, centerY, width, height ){
	      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
	    },
	
	    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
	      return math.roundRectangleIntersectLine(
	        x, y,
	        nodeX,
	        nodeY,
	        width, height,
	        padding)
	      ;
	    },
	
	    // Looks like the width passed into this function is actually the total width / 2
	    checkPoint: function(
	      x, y, padding, width, height, centerX, centerY ){
	
	      var cornerRadius = math.getRoundRectangleRadius(width, height);
	
	      // Check hBox
	      if (math.pointInsidePolygon(x, y, this.points,
	        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding) ){
	        return true;
	      }
	
	      // Check vBox
	      if (math.pointInsidePolygon(x, y, this.points,
	        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding) ){
	        return true;
	      }
	
	      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
	        x -= centerX;
	        y -= centerY;
	
	        x /= (width / 2 + padding);
	        y /= (height / 2 + padding);
	
	        return (x*x + y*y <= 1);
	      };
	
	
	      // Check top left quarter circle
	      if (checkInEllipse(x, y,
	        centerX - width / 2 + cornerRadius,
	        centerY - height / 2 + cornerRadius,
	        cornerRadius * 2, cornerRadius * 2, padding) ){
	
	        return true;
	      }
	
	      // Check top right quarter circle
	      if (checkInEllipse(x, y,
	        centerX + width / 2 - cornerRadius,
	        centerY - height / 2 + cornerRadius,
	        cornerRadius * 2, cornerRadius * 2, padding) ){
	
	        return true;
	      }
	
	      // Check bottom right quarter circle
	      if (checkInEllipse(x, y,
	        centerX + width / 2 - cornerRadius,
	        centerY + height / 2 - cornerRadius,
	        cornerRadius * 2, cornerRadius * 2, padding) ){
	
	        return true;
	      }
	
	      // Check bottom left quarter circle
	      if (checkInEllipse(x, y,
	        centerX - width / 2 + cornerRadius,
	        centerY + height / 2 - cornerRadius,
	        cornerRadius * 2, cornerRadius * 2, padding) ){
	
	        return true;
	      }
	
	      return false;
	    }
	  };
	
	  generatePolygon( 'diamond', [
	    0, 1,
	    1, 0,
	    0, -1,
	    -1, 0
	  ] );
	
	  generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare(5, 0) );
	
	  generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare(6, 0) );
	
	  generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare(7, 0) );
	
	  generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare(8, 0) );
	
	  var star5Points = new Array(20);
	  {
	    var outerPoints = math.generateUnitNgonPoints(5, 0);
	    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);
	
	    // Outer radius is 1; inner radius of star is smaller
	    var innerRadius = 0.5 * (3 - Math.sqrt(5));
	    innerRadius *= 1.57;
	
	    for (var i=0;i<innerPoints.length/2;i++ ){
	      innerPoints[i*2] *= innerRadius;
	      innerPoints[i*2+1] *= innerRadius;
	    }
	
	    for (var i=0;i<20/4;i++ ){
	      star5Points[i*4] = outerPoints[i*2];
	      star5Points[i*4+1] = outerPoints[i*2+1];
	
	      star5Points[i*4+2] = innerPoints[i*2];
	      star5Points[i*4+3] = innerPoints[i*2+1];
	    }
	  }
	
	  star5Points = math.fitPolygonToSquare( star5Points );
	
	  generatePolygon( 'star', star5Points );
	
	  generatePolygon( 'vee', [
	    -1, -1,
	    0, -0.333,
	    1, -1,
	    0, 1
	  ] );
	
	  generatePolygon( 'rhomboid', [
	    -1, -1,
	    0.333, -1,
	    1, 1,
	    -0.333, 1
	  ] );
	
	  nodeShapes.makePolygon = function( points ){
	
	    // use caching on user-specified polygons so they are as fast as native shapes
	
	    var key = points.join('$');
	    var name = 'polygon-' + key;
	    var shape;
	
	    if( (shape = nodeShapes[name]) ){ // got cached shape
	      return shape;
	    }
	
	    // create and cache new shape
	    return generatePolygon( name, points );
	  };
	
	};
	
	module.exports = BRp;
	
	},{"../../../math":79}],61:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../../../util');
	
	var BRp = {};
	
	BRp.timeToRender = function(){
	  return this.redrawTotalTime / this.redrawCount;
	};
	
	var minRedrawLimit = 1000/60; // people can't see much better than 60fps
	var maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
	
	BRp.redraw = function( options ){
	  options = options || util.staticEmptyObject();
	
	  var r = this;
	  var forcedContext = options.forcedContext;
	
	  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
	  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }
	
	  var redrawLimit = r.lastRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
	  redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
	  redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;
	
	  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }
	
	  var nowTime = Date.now();
	  var timeElapsed = nowTime - r.lastDrawTime;
	  var callAfterLimit = timeElapsed >= redrawLimit;
	
	  if( !forcedContext ){
	    if( !callAfterLimit ){
	      r.skipFrame = true;
	      return;
	    }
	  }
	
	  r.requestedFrame = true;
	  r.renderOptions = options;
	};
	
	BRp.startRenderLoop = function(){
	  var r = this;
	
	  if( r.renderLoopStarted ){
	    return;
	  } else {
	    r.renderLoopStarted = true;
	  }
	
	  var renderFn = function(){
	    if( r.destroyed ){ return; }
	
	    if( r.requestedFrame && !r.skipFrame ){
	      var startTime = util.performanceNow();
	
	      r.render( r.renderOptions );
	
	      var endTime = r.lastRedrawTime = util.performanceNow();
	
	      if( r.averageRedrawTime === undefined ){
	        r.averageRedrawTime = endTime - startTime;
	      }
	
	      if( r.redrawCount === undefined ){
	        r.redrawCount = 0;
	      }
	
	      r.redrawCount++;
	
	      if( r.redrawTotalTime === undefined ){
	        r.redrawTotalTime = 0;
	      }
	
	      var duration = endTime - startTime;
	
	      r.redrawTotalTime += duration;
	      r.lastRedrawTime = duration;
	
	      // use a weighted average with a bias from the previous average so we don't spike so easily
	      r.averageRedrawTime = r.averageRedrawTime/2 + duration/2;
	
	      r.requestedFrame = false;
	    }
	
	    r.skipFrame = false;
	
	    util.requestAnimationFrame( renderFn );
	  };
	
	  util.requestAnimationFrame( renderFn );
	
	};
	
	module.exports = BRp;
	
	},{"../../../util":94}],62:[function(_dereq_,module,exports){
	'use strict';
	
	var CRp = {};
	
	var impl;
	
	CRp.arrowShapeImpl = function( name ){
	  return ( impl || (impl = {
	    'polygon': function( context, points ){
	      for( var i = 0; i < points.length; i++ ){
	        var pt = points[i];
	
	        context.lineTo( pt.x, pt.y );
	      }
	    },
	
	    'triangle-backcurve': function( context, points, controlPoint ){
	      var firstPt;
	
	      for( var i = 0; i < points.length; i++ ){
	        var pt = points[i];
	
	        if( i === 0 ){
	          firstPt = pt;
	        }
	
	        context.lineTo( pt.x, pt.y );
	      }
	
	      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
	    },
	
	    'triangle-tee': function( context, trianglePoints, teePoints ){
	      var triPts = trianglePoints;
	      for( var i = 0; i < triPts.length; i++ ){
	        var pt = triPts[i];
	
	        context.lineTo( pt.x, pt.y );
	      }
	
	      var teePts = teePoints;
	      var firstTeePt = teePoints[0];
	      context.moveTo( firstTeePt.x, firstTeePt.y );
	
	      for( var i = 0; i < teePts.length; i++ ){
	        var pt = teePts[i];
	
	        context.lineTo( pt.x, pt.y );
	      }
	    },
	
	    'circle': function( context, rx, ry, r ){
	      context.arc(rx, ry, r, 0, Math.PI * 2, false);
	    }
	  }) )[ name ];
	};
	
	module.exports = CRp;
	
	},{}],63:[function(_dereq_,module,exports){
	'use strict';
	
	var CRp = {};
	
	CRp.drawEdge = function(context, edge, drawOverlayInstead) {
	  var rs = edge._private.rscratch;
	  var usePaths = this.usePaths();
	
	  // if bezier ctrl pts can not be calculated, then die
	  if( rs.badBezier || rs.badLine || isNaN( rs.allpts[0] ) ){ // iNaN in case edge is impossible and browser bugs (e.g. safari)
	    return;
	  }
	
	  var style = edge._private.style;
	
	  // Edge line width
	  if (style['width'].pfValue <= 0) {
	    return;
	  }
	
	  var overlayPadding = style['overlay-padding'].pfValue;
	  var overlayOpacity = style['overlay-opacity'].value;
	  var overlayColor = style['overlay-color'].value;
	
	  // Edge color & opacity
	  if( drawOverlayInstead ){
	
	    if( overlayOpacity === 0 ){ // exit early if no overlay
	      return;
	    }
	
	    this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
	    context.lineCap = 'round';
	
	    if( rs.edgeType == 'self' && !usePaths ){
	      context.lineCap = 'butt';
	    }
	
	  } else {
	    var lineColor = style['line-color'].value;
	
	    this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
	
	    context.lineCap = 'butt';
	  }
	
	  var edgeWidth = style['width'].pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
	  var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
	  context.lineWidth = edgeWidth;
	
	  var shadowBlur = style['shadow-blur'].pfValue;
	  var shadowOpacity = style['shadow-opacity'].value;
	  var shadowColor = style['shadow-color'].value;
	  var shadowOffsetX = style['shadow-offset-x'].pfValue;
	  var shadowOffsetY = style['shadow-offset-y'].pfValue;
	
	  this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
	
	  this.drawEdgePath(
	    edge,
	    context,
	    rs.allpts,
	    lineStyle,
	    edgeWidth
	  );
	
	  this.drawArrowheads(context, edge, drawOverlayInstead);
	
	  this.shadowStyle(context, 'transparent', 0); // reset for next guy
	
	};
	
	
	CRp.drawEdgePath = function(edge, context, pts, type, width) {
	  var rs = edge._private.rscratch;
	  var canvasCxt = context;
	  var path;
	  var pathCacheHit = false;
	  var usePaths = this.usePaths();
	
	  if( usePaths ){
	    var pathCacheKey = pts.join('$');
	    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;
	
	    if( keyMatches ){
	      path = context = rs.pathCache;
	      pathCacheHit = true;
	    } else {
	      path = context = new Path2D();
	      rs.pathCacheKey = pathCacheKey;
	      rs.pathCache = path;
	    }
	  }
	
	  if( canvasCxt.setLineDash ){ // for very outofdate browsers
	    switch( type ){
	      case 'dotted':
	        canvasCxt.setLineDash([ 1, 1 ]);
	        break;
	
	      case 'dashed':
	        canvasCxt.setLineDash([ 6, 3 ]);
	        break;
	
	      case 'solid':
	        canvasCxt.setLineDash([ ]);
	        break;
	    }
	  }
	
	  if( !pathCacheHit ){
	    if( context.beginPath ){ context.beginPath(); }
	    context.moveTo( pts[0], pts[1] );
	
	    switch( rs.edgeType ){
	      case 'bezier':
	      case 'self':
	      case 'compound':
	      case 'multibezier':
	        if( !rs.badBezier ){
	          for( var i = 2; i + 3 < pts.length; i += 4 ){
	            context.quadraticCurveTo( pts[i], pts[i+1], pts[i+2], pts[i+3] );
	          }
	        }
	        break;
	
	      case 'straight':
	      case 'segments':
	      case 'haystack':
	        if( !rs.badLine ){
	          for( var i = 2; i + 1 < pts.length; i += 2 ){
	            context.lineTo( pts[i], pts[i+1] );
	          }
	        }
	        break;
	    }
	  }
	
	  context = canvasCxt;
	  if( usePaths ){
	    context.stroke( path );
	  } else {
	    context.stroke();
	  }
	
	  // reset any line dashes
	  if( context.setLineDash ){ // for very outofdate browsers
	    context.setLineDash([ ]);
	  }
	
	};
	
	CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
	  if( drawOverlayInstead ){ return; } // don't do anything for overlays
	
	  var rs = edge._private.rscratch;
	  var isHaystack = rs.edgeType === 'haystack';
	
	  if( !isHaystack ){
	    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
	  }
	
	  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );
	
	  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );
	
	  if( !isHaystack ){
	    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
	  }
	};
	
	CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
	  if( isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null ){ return; }
	
	  var self = this;
	  var style = edge._private.style;
	  var arrowShape = style[prefix + '-arrow-shape'].value;
	
	  if( arrowShape === 'none' ){
	    return;
	  }
	
	  var gco = context.globalCompositeOperation;
	
	  var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
	  var arrowFill = style[prefix + '-arrow-fill'].value;
	
	  if( arrowShape === 'half-triangle-overshot' ){
	    arrowFill = 'hollow';
	    arrowClearFill = 'hollow';
	  }
	
	  if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
	    context.globalCompositeOperation = 'destination-out';
	
	    self.fillStyle(context, 255, 255, 255, 1);
	    self.strokeStyle(context, 255, 255, 255, 1);
	
	    self.drawArrowShape( edge, prefix, context,
	      arrowClearFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
	      x, y, angle
	    );
	
	    context.globalCompositeOperation = gco;
	  } // otherwise, the opaque arrow clears it for free :)
	
	  var color = style[prefix + '-arrow-color'].value;
	  self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
	  self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);
	
	  self.drawArrowShape( edge, prefix, context,
	    arrowFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
	    x, y, angle
	  );
	};
	
	CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
	  var r = this;
	  var usePaths = this.usePaths();
	  var rs = edge._private.rscratch;
	  var pathCacheHit = false;
	  var path;
	  var canvasContext = context;
	  var translation = { x: x, y: y };
	  var size = this.getArrowWidth( edgeWidth );
	  var shapeImpl = r.arrowShapes[shape];
	
	  if( usePaths ){
	    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
	    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
	    rs.arrowPathCache = rs.arrowPathCache || {};
	
	    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
	    if( alreadyCached ){
	      path = context = rs.arrowPathCache[arrowType];
	      pathCacheHit = true;
	    } else {
	      path = context = new Path2D();
	      rs.arrowPathCacheKey[arrowType] = pathCacheKey;
	      rs.arrowPathCache[arrowType] = path;
	    }
	  }
	
	  if( context.beginPath ){ context.beginPath(); }
	
	  if( !pathCacheHit ){
	    shapeImpl.draw(context, size, angle, translation);
	  }
	
	  if( !shapeImpl.leavePathOpen && context.closePath ){
	    context.closePath();
	  }
	
	  context = canvasContext;
	
	  if( fill === 'filled' || fill === 'both' ){
	    if( usePaths ){
	      context.fill( path );
	    } else {
	      context.fill();
	    }
	  }
	
	  if( fill === 'hollow' || fill === 'both' ){
	    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
	    context.lineJoin = 'miter';
	
	    if( usePaths ){
	      context.stroke( path );
	    } else {
	      context.stroke();
	    }
	
	  }
	};
	
	module.exports = CRp;
	
	},{}],64:[function(_dereq_,module,exports){
	'use strict';
	
	var CRp = {};
	
	CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
	  var r = this;
	
	  try {
	    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
	  } catch(e){
	    r.data.canvasNeedsRedraw[r.NODE] = true;
	    r.data.canvasNeedsRedraw[r.DRAG] = true;
	
	    r.drawingImage = true;
	
	    r.redraw();
	  }
	};
	
	CRp.drawInscribedImage = function(context, img, node) {
	  var r = this;
	  var nodeX = node._private.position.x;
	  var nodeY = node._private.position.y;
	  var style = node._private.style;
	  var fit = style['background-fit'].value;
	  var xPos = style['background-position-x'];
	  var yPos = style['background-position-y'];
	  var repeat = style['background-repeat'].value;
	  var nodeW = node.width();
	  var nodeH = node.height();
	  var rs = node._private.rscratch;
	  var clip = style['background-clip'].value;
	  var shouldClip = clip === 'node';
	  var imgOpacity = style['background-image-opacity'].value;
	
	  var imgW = img.width || img.cachedW;
	  var imgH = img.height || img.cachedH;
	
	  // workaround for broken browsers like ie
	  if( null == imgW || null == imgH ){
	    document.body.appendChild( img );
	
	    imgW = img.cachedW = img.width || img.offsetWidth;
	    imgH = img.cachedH = img.height || img.offsetHeight;
	
	    document.body.removeChild( img );
	  }
	
	  var w = imgW;
	  var h = imgH;
	
	  var bgW = style['background-width'];
	  if( bgW.value !== 'auto' ){
	    if( bgW.units === '%' ){
	      w = bgW.value/100 * nodeW;
	    } else {
	      w = bgW.pfValue;
	    }
	  }
	
	  var bgH = style['background-height'];
	  if( bgH.value !== 'auto' ){
	    if( bgH.units === '%' ){
	      h = bgH.value/100 * nodeH;
	    } else {
	      h = bgH.pfValue;
	    }
	  }
	
	  if( w === 0 || h === 0 ){
	    return; // no point in drawing empty image (and chrome is broken in this case)
	  }
	
	  if( fit === 'contain' ){
	    var scale = Math.min( nodeW/w, nodeH/h );
	
	    w *= scale;
	    h *= scale;
	
	  } else if( fit === 'cover' ){
	    var scale = Math.max( nodeW/w, nodeH/h );
	
	    w *= scale;
	    h *= scale;
	  }
	
	  var x = (nodeX - nodeW/2); // left
	  if( xPos.units === '%' ){
	    x += (nodeW - w) * xPos.value/100;
	  } else {
	    x += xPos.pfValue;
	  }
	
	  var y = (nodeY - nodeH/2); // top
	  if( yPos.units === '%' ){
	    y += (nodeH - h) * yPos.value/100;
	  } else {
	    y += yPos.pfValue;
	  }
	
	  if( rs.pathCache ){
	    x -= nodeX;
	    y -= nodeY;
	
	    nodeX = 0;
	    nodeY = 0;
	  }
	
	  var gAlpha = context.globalAlpha;
	
	  context.globalAlpha = imgOpacity;
	
	  if( repeat === 'no-repeat' ){
	
	    if( shouldClip ){
	      context.save();
	
	      if( rs.pathCache ){
	        context.clip( rs.pathCache );
	      } else {
	        r.nodeShapes[r.getNodeShape(node)].draw(
	          context,
	          nodeX, nodeY,
	          nodeW, nodeH);
	
	        context.clip();
	      }
	    }
	
	    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );
	
	    if( shouldClip ){
	      context.restore();
	    }
	  } else {
	    var pattern = context.createPattern( img, repeat );
	    context.fillStyle = pattern;
	
	    r.nodeShapes[r.getNodeShape(node)].draw(
	        context,
	        nodeX, nodeY,
	        nodeW, nodeH);
	
	      context.translate(x, y);
	      context.fill();
	      context.translate(-x, -y);
	  }
	
	  context.globalAlpha = gAlpha;
	
	};
	
	module.exports = CRp;
	
	},{}],65:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../../is');
	
	var CRp = {};
	
	// Draw edge text
	CRp.drawEdgeText = function(context, edge) {
	  var text = edge._private.style['label'].strValue;
	
	  if( !text || text.match(/^\s+$/) ){
	    return;
	  }
	
	  if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching
	
	  var computedSize = edge._private.style['font-size'].pfValue * edge.cy().zoom();
	  var minSize = edge._private.style['min-zoomed-font-size'].pfValue;
	
	  if( computedSize < minSize ){
	    return;
	  }
	
	  // Calculate text draw position
	
	  context.textAlign = 'center';
	  context.textBaseline = 'middle';
	
	  var rs = edge._private.rscratch;
	  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered
	
	  var style = edge._private.style;
	  var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
	  var theta;
	
	  if( autorotate ){
	    theta = rs.labelAngle;
	
	    context.translate(rs.labelX, rs.labelY);
	    context.rotate(theta);
	
	    this.drawText(context, edge, 0, 0);
	
	    context.rotate(-theta);
	    context.translate(-rs.labelX, -rs.labelY);
	  } else {
	    this.drawText(context, edge, rs.labelX, rs.labelY);
	  }
	
	};
	
	// Draw node text
	CRp.drawNodeText = function(context, node) {
	  var text = node._private.style['label'].strValue;
	
	  if ( !text || text.match(/^\s+$/) ) {
	    return;
	  }
	
	  var computedSize = node._private.style['font-size'].pfValue * node.cy().zoom();
	  var minSize = node._private.style['min-zoomed-font-size'].pfValue;
	
	  if( computedSize < minSize ){
	    return;
	  }
	
	  // this.recalculateNodeLabelProjection( node );
	
	  var textHalign = node._private.style['text-halign'].strValue;
	  var textValign = node._private.style['text-valign'].strValue;
	  var rs = node._private.rscratch;
	  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered
	
	  switch( textHalign ){
	    case 'left':
	      context.textAlign = 'right';
	      break;
	
	    case 'right':
	      context.textAlign = 'left';
	      break;
	
	    default: // e.g. center
	      context.textAlign = 'center';
	  }
	
	  switch( textValign ){
	    case 'top':
	      context.textBaseline = 'bottom';
	      break;
	
	    case 'bottom':
	      context.textBaseline = 'top';
	      break;
	
	    default: // e.g. center
	      context.textBaseline = 'middle';
	  }
	
	  this.drawText(context, node, rs.labelX, rs.labelY);
	};
	
	CRp.getFontCache = function(context){
	  var cache;
	
	  this.fontCaches = this.fontCaches || [];
	
	  for( var i = 0; i < this.fontCaches.length; i++ ){
	    cache = this.fontCaches[i];
	
	    if( cache.context === context ){
	      return cache;
	    }
	  }
	
	  cache = {
	    context: context
	  };
	  this.fontCaches.push(cache);
	
	  return cache;
	};
	
	// set up canvas context with font
	// returns transformed text string
	CRp.setupTextStyle = function( context, element ){
	  // Font style
	  var parentOpacity = element.effectiveOpacity();
	  var style = element._private.style;
	  var labelStyle = style['font-style'].strValue;
	  var labelSize = style['font-size'].pfValue + 'px';
	  var labelFamily = style['font-family'].strValue;
	  var labelWeight = style['font-weight'].strValue;
	  var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
	  var outlineOpacity = style['text-outline-opacity'].value * opacity;
	  var color = style['color'].value;
	  var outlineColor = style['text-outline-color'].value;
	  var shadowBlur = style['text-shadow-blur'].pfValue;
	  var shadowOpacity = style['text-shadow-opacity'].value;
	  var shadowColor = style['text-shadow-color'].value;
	  var shadowOffsetX = style['text-shadow-offset-x'].pfValue;
	  var shadowOffsetY = style['text-shadow-offset-y'].pfValue;
	
	  var fontCacheKey = element._private.fontKey;
	  var cache = this.getFontCache(context);
	
	  if( cache.key !== fontCacheKey ){
	    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
	
	    cache.key = fontCacheKey;
	  }
	
	  var text = this.getLabelText( element );
	
	  // Calculate text draw position based on text alignment
	
	  // so text outlines aren't jagged
	  context.lineJoin = 'round';
	
	  this.fillStyle(context, color[0], color[1], color[2], opacity);
	
	  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
	
	  this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
	
	  return text;
	};
	
	function roundRect(ctx, x, y, width, height, radius) {
	  var radius = radius || 5;
	  ctx.beginPath();
	  ctx.moveTo(x + radius, y);
	  ctx.lineTo(x + width - radius, y);
	  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	  ctx.lineTo(x + width, y + height - radius);
	  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	  ctx.lineTo(x + radius, y + height);
	  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	  ctx.lineTo(x, y + radius);
	  ctx.quadraticCurveTo(x, y, x + radius, y);
	  ctx.closePath();
	  ctx.fill();
	}
	
	// Draw text
	CRp.drawText = function(context, element, textX, textY) {
	  var _p = element._private;
	  var style = _p.style;
	  var rstyle = _p.rstyle;
	  var rscratch = _p.rscratch;
	  var parentOpacity = element.effectiveOpacity();
	  if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }
	
	  var text = this.setupTextStyle( context, element );
	  var halign = style['text-halign'].value;
	  var valign = style['text-valign'].value;
	
	  if( element.isEdge() ){
	    halign = 'center';
	    valign = 'center';
	  }
	
	  if( element.isNode() ){
	    var pLeft = style['padding-left'].pfValue;
	    var pRight = style['padding-right'].pfValue;
	    var pTop = style['padding-top'].pfValue;
	    var pBottom = style['padding-bottom'].pfValue;
	
	    textX += pLeft/2;
	    textX -= pRight/2;
	
	    textY += pTop/2;
	    textY -= pBottom/2;
	  }
	
	  if ( text != null && !isNaN(textX) && !isNaN(textY)) {
	    var backgroundOpacity = style['text-background-opacity'].value;
	    var borderOpacity = style['text-border-opacity'].value;
	    var textBorderWidth = style['text-border-width'].pfValue;
	
	    if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
	      var margin = 4 + textBorderWidth/2;
	
	      if (element.isNode()) {
	        //Move textX, textY to include the background margins
	        if (valign === 'top') {
	          textY -= margin;
	        } else if (valign === 'bottom') {
	          textY += margin;
	        }
	        if (halign === 'left') {
	          textX -= margin;
	        } else if (halign === 'right') {
	          textX += margin;
	        }
	      }
	
	      var bgWidth = rstyle.labelWidth;
	      var bgHeight = rstyle.labelHeight;
	      var bgX = textX;
	
	      if (halign) {
	        if (halign == 'center') {
	          bgX = bgX - bgWidth / 2;
	        } else if (halign == 'left') {
	          bgX = bgX- bgWidth;
	        }
	      }
	
	      var bgY = textY;
	
	      if (element.isNode()) {
	        if (valign == 'top') {
	           bgY = bgY - bgHeight;
	        } else if (valign == 'center') {
	          bgY = bgY- bgHeight / 2;
	        }
	      } else {
	        bgY = bgY - bgHeight / 2;
	      }
	
	      if (style['edge-text-rotation'].strValue === 'autorotate') {
	        textY = 0;
	        bgWidth += 4;
	        bgX = textX - bgWidth / 2;
	        bgY = textY - bgHeight / 2;
	      } else {
	        // Adjust with border width & margin
	        bgX -= margin;
	        bgY -= margin;
	        bgHeight += margin*2;
	        bgWidth += margin*2;
	      }
	
	      if( backgroundOpacity > 0 ){
	        var textFill = context.fillStyle;
	        var textBackgroundColor = style['text-background-color'].value;
	
	        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
	        var styleShape = style['text-background-shape'].strValue;
	        if (styleShape == 'roundrectangle') {
	          roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
	        } else {
	          context.fillRect(bgX,bgY,bgWidth,bgHeight);
	        }
	        context.fillStyle = textFill;
	      }
	
	      if( textBorderWidth > 0 && borderOpacity > 0 ){
	        var textStroke = context.strokeStyle;
	        var textLineWidth = context.lineWidth;
	        var textBorderColor = style['text-border-color'].value;
	        var textBorderStyle = style['text-border-style'].value;
	
	        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
	        context.lineWidth = textBorderWidth;
	
	        if( context.setLineDash ){ // for very outofdate browsers
	          switch( textBorderStyle ){
	            case 'dotted':
	              context.setLineDash([ 1, 1 ]);
	              break;
	            case 'dashed':
	              context.setLineDash([ 4, 2 ]);
	              break;
	            case 'double':
	              context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
	              context.setLineDash([ ]);
	              break;
	            case 'solid':
	              context.setLineDash([ ]);
	              break;
	          }
	        }
	
	        context.strokeRect(bgX,bgY,bgWidth,bgHeight);
	
	        if( textBorderStyle === 'double' ){
	          var whiteWidth = textBorderWidth/2;
	
	          context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
	        }
	
	        if( context.setLineDash ){ // for very outofdate browsers
	          context.setLineDash([ ]);
	        }
	        context.lineWidth = textLineWidth;
	        context.strokeStyle = textStroke;
	      }
	
	    }
	
	    var lineWidth = 2  * style['text-outline-width'].pfValue; // *2 b/c the stroke is drawn centred on the middle
	
	    if( lineWidth > 0 ){
	      context.lineWidth = lineWidth;
	    }
	
	    if( style['text-wrap'].value === 'wrap' ){
	      var lines = rscratch.labelWrapCachedLines;
	      var lineHeight = rstyle.labelHeight / lines.length;
	
	      switch( valign ){
	        case 'top':
	          textY -= (lines.length - 1) * lineHeight;
	          break;
	
	        case 'bottom':
	          // nothing required
	          break;
	
	        default:
	        case 'center':
	          textY -= (lines.length - 1) * lineHeight / 2;
	      }
	
	      for( var l = 0; l < lines.length; l++ ){
	        if( lineWidth > 0 ){
	          context.strokeText( lines[l], textX, textY );
	        }
	
	        context.fillText( lines[l], textX, textY );
	
	        textY += lineHeight;
	      }
	
	    } else {
	      if( lineWidth > 0 ){
	        context.strokeText( text, textX, textY );
	      }
	
	      context.fillText( text, textX, textY );
	    }
	
	
	    this.shadowStyle(context, 'transparent', 0); // reset for next guy
	  }
	};
	
	
	module.exports = CRp;
	
	},{"../../../is":77}],66:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../../is');
	
	var CRp = {};
	
	// Draw node
	CRp.drawNode = function(context, node, drawOverlayInstead) {
	
	  var r = this;
	  var nodeWidth, nodeHeight;
	  var style = node._private.style;
	  var rs = node._private.rscratch;
	  var _p = node._private;
	  var pos = _p.position;
	
	  if( !is.number(pos.x) || !is.number(pos.y) ){
	    return; // can't draw node with undefined position
	  }
	
	  var usePaths = this.usePaths();
	  var canvasContext = context;
	  var path;
	  var pathCacheHit = false;
	
	  var overlayPadding = style['overlay-padding'].pfValue;
	  var overlayOpacity = style['overlay-opacity'].value;
	  var overlayColor = style['overlay-color'].value;
	
	  if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
	    return;
	  }
	
	  var parentOpacity = node.effectiveOpacity();
	  if( parentOpacity === 0 ){ return; }
	
	  nodeWidth = node.width() + style['padding-left'].pfValue + style['padding-right'].pfValue;
	  nodeHeight = node.height() + style['padding-top'].pfValue + style['padding-bottom'].pfValue;
	
	  context.lineWidth = style['border-width'].pfValue;
	
	  if( drawOverlayInstead === undefined || !drawOverlayInstead ){
	
	    var url = style['background-image'].value[2] ||
	      style['background-image'].value[1];
	    var image;
	
	    if (url !== undefined) {
	
	      // get image, and if not loaded then ask to redraw when later loaded
	      image = this.getCachedImage(url, function(){
	        r.data.canvasNeedsRedraw[r.NODE] = true;
	        r.data.canvasNeedsRedraw[r.DRAG] = true;
	
	        r.drawingImage = true;
	
	        r.redraw();
	      });
	
	      var prevBging = _p.backgrounding;
	      _p.backgrounding = !image.complete;
	
	      if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
	        node.updateStyle( false );
	      }
	    }
	
	    // Node color & opacity
	
	    var bgColor = style['background-color'].value;
	    var borderColor = style['border-color'].value;
	    var borderStyle = style['border-style'].value;
	
	    this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);
	
	    this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);
	
	    var shadowBlur = style['shadow-blur'].pfValue;
	    var shadowOpacity = style['shadow-opacity'].value;
	    var shadowColor = style['shadow-color'].value;
	    var shadowOffsetX = style['shadow-offset-x'].pfValue;
	    var shadowOffsetY = style['shadow-offset-y'].pfValue;
	
	    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
	
	    context.lineJoin = 'miter'; // so borders are square with the node shape
	
	    if( context.setLineDash ){ // for very outofdate browsers
	      switch( borderStyle ){
	        case 'dotted':
	          context.setLineDash([ 1, 1 ]);
	          break;
	
	        case 'dashed':
	          context.setLineDash([ 4, 2 ]);
	          break;
	
	        case 'solid':
	        case 'double':
	          context.setLineDash([ ]);
	          break;
	      }
	    }
	
	
	    var styleShape = style['shape'].strValue;
	
	    if( usePaths ){
	      var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;
	
	      context.translate( pos.x, pos.y );
	
	      if( rs.pathCacheKey === pathCacheKey ){
	        path = context = rs.pathCache;
	        pathCacheHit = true;
	      } else {
	        path = context = new Path2D();
	        rs.pathCacheKey = pathCacheKey;
	        rs.pathCache = path;
	      }
	    }
	
	    if( !pathCacheHit ){
	
	      var npos = pos;
	
	      if( usePaths ){
	        npos = {
	          x: 0,
	          y: 0
	        };
	      }
	
	      r.nodeShapes[this.getNodeShape(node)].draw(
	            context,
	            npos.x,
	            npos.y,
	            nodeWidth,
	            nodeHeight);
	    }
	
	    context = canvasContext;
	
	    if( usePaths ){
	      context.fill( path );
	    } else {
	      context.fill();
	    }
	
	    this.shadowStyle(context, 'transparent', 0); // reset for next guy
	
	    if (url !== undefined) {
	      if( image.complete ){
	        this.drawInscribedImage(context, image, node);
	      }
	    }
	
	    var darkness = style['background-blacken'].value;
	    var borderWidth = style['border-width'].pfValue;
	
	    if( this.hasPie(node) ){
	      this.drawPie( context, node, parentOpacity );
	
	      // redraw path for blacken and border
	      if( darkness !== 0 || borderWidth !== 0 ){
	
	        if( !usePaths ){
	          r.nodeShapes[this.getNodeShape(node)].draw(
	              context,
	              pos.x,
	              pos.y,
	              nodeWidth,
	              nodeHeight);
	        }
	      }
	    }
	
	    if( darkness > 0 ){
	      this.fillStyle(context, 0, 0, 0, darkness);
	
	      if( usePaths ){
	        context.fill( path );
	      } else {
	        context.fill();
	      }
	
	    } else if( darkness < 0 ){
	      this.fillStyle(context, 255, 255, 255, -darkness);
	
	      if( usePaths ){
	        context.fill( path );
	      } else {
	        context.fill();
	      }
	    }
	
	    // Border width, draw border
	    if (borderWidth > 0) {
	
	      if( usePaths ){
	        context.stroke( path );
	      } else {
	        context.stroke();
	      }
	
	      if( borderStyle === 'double' ){
	        context.lineWidth = style['border-width'].pfValue/3;
	
	        var gco = context.globalCompositeOperation;
	        context.globalCompositeOperation = 'destination-out';
	
	        if( usePaths ){
	          context.stroke( path );
	        } else {
	          context.stroke();
	        }
	
	        context.globalCompositeOperation = gco;
	      }
	
	    }
	
	    if( usePaths ){
	      context.translate( -pos.x, -pos.y );
	    }
	
	    // reset in case we changed the border style
	    if( context.setLineDash ){ // for very outofdate browsers
	      context.setLineDash([ ]);
	    }
	
	  // draw the overlay
	  } else {
	
	    if( overlayOpacity > 0 ){
	      this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
	
	      r.nodeShapes['roundrectangle'].draw(
	        context,
	        node._private.position.x,
	        node._private.position.y,
	        nodeWidth + overlayPadding * 2,
	        nodeHeight + overlayPadding * 2
	      );
	
	      context.fill();
	    }
	  }
	
	};
	
	// does the node have at least one pie piece?
	CRp.hasPie = function(node){
	  node = node[0]; // ensure ele ref
	
	  return node._private.hasPie;
	};
	
	CRp.drawPie = function( context, node, nodeOpacity ){
	  node = node[0]; // ensure ele ref
	
	  var _p = node._private;
	  var cyStyle = node.cy().style();
	  var style = _p.style;
	  var pieSize = style['pie-size'];
	  var nodeW = node.width();
	  var nodeH = node.height();
	  var x = _p.position.x;
	  var y = _p.position.y;
	  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
	  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
	  var usePaths = this.usePaths();
	
	  if( usePaths ){
	    x = 0;
	    y = 0;
	  }
	
	  if( pieSize.units === '%' ){
	    radius = radius * pieSize.value / 100;
	  } else if( pieSize.pfValue !== undefined ){
	    radius = pieSize.pfValue / 2;
	  }
	
	  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
	    var size = style['pie-' + i + '-background-size'].value;
	    var color = style['pie-' + i + '-background-color'].value;
	    var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
	    var percent = size / 100; // map integer range [0, 100] to [0, 1]
	
	    // percent can't push beyond 1
	    if( percent + lastPercent > 1 ){
	      percent = 1 - lastPercent;
	    }
	
	    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
	    var angleDelta = 2 * Math.PI * percent;
	    var angleEnd = angleStart + angleDelta;
	
	    // ignore if
	    // - zero size
	    // - we're already beyond the full circle
	    // - adding the current slice would go beyond the full circle
	    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
	      continue;
	    }
	
	    context.beginPath();
	    context.moveTo(x, y);
	    context.arc( x, y, radius, angleStart, angleEnd );
	    context.closePath();
	
	    this.fillStyle(context, color[0], color[1], color[2], opacity);
	
	    context.fill();
	
	    lastPercent += percent;
	  }
	
	};
	
	
	module.exports = CRp;
	
	},{"../../../is":77}],67:[function(_dereq_,module,exports){
	'use strict';
	
	var CRp = {};
	
	var util = _dereq_('../../../util');
	var math = _dereq_('../../../math');
	
	var motionBlurDelay = 100;
	
	// var isFirefox = typeof InstallTrigger !== 'undefined';
	
	CRp.getPixelRatio = function(){
	  var context = this.data.contexts[0];
	
	  if( this.forcedPixelRatio != null ){
	    return this.forcedPixelRatio;
	  }
	
	  var backingStore = context.backingStorePixelRatio ||
	    context.webkitBackingStorePixelRatio ||
	    context.mozBackingStorePixelRatio ||
	    context.msBackingStorePixelRatio ||
	    context.oBackingStorePixelRatio ||
	    context.backingStorePixelRatio || 1;
	
	  return (window.devicePixelRatio || 1) / backingStore;
	};
	
	CRp.paintCache = function(context){
	  var caches = this.paintCaches = this.paintCaches || [];
	  var needToCreateCache = true;
	  var cache;
	
	  for(var i = 0; i < caches.length; i++ ){
	    cache = caches[i];
	
	    if( cache.context === context ){
	      needToCreateCache = false;
	      break;
	    }
	  }
	
	  if( needToCreateCache ){
	    cache = {
	      context: context
	    };
	    caches.push( cache );
	  }
	
	  return cache;
	};
	
	CRp.fillStyle = function(context, r, g, b, a){
	  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	
	  // turn off for now, seems context does its own caching
	
	  // var cache = this.paintCache(context);
	
	  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	
	  // if( cache.fillStyle !== fillStyle ){
	  //   context.fillStyle = cache.fillStyle = fillStyle;
	  // }
	};
	
	CRp.strokeStyle = function(context, r, g, b, a){
	  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	
	  // turn off for now, seems context does its own caching
	
	  // var cache = this.paintCache(context);
	
	  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	
	  // if( cache.strokeStyle !== strokeStyle ){
	  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
	  // }
	};
	
	CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
	  var zoom = this.cy.zoom();
	
	  var cache = this.paintCache(context);
	
	  // don't make expensive changes to the shadow style if it's not used
	  if( cache.shadowOpacity === 0 && opacity === 0 ){
	    return;
	  }
	
	  cache.shadowOpacity = opacity;
	
	  if (opacity > 0) {
	    context.shadowBlur = blur * zoom;
	    context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
	    context.shadowOffsetX = offsetX * zoom;
	    context.shadowOffsetY = offsetY * zoom;
	  } else {
	    context.shadowBlur = 0;
	    context.shadowColor = "transparent";
	  }
	};
	
	// Resize canvas
	CRp.matchCanvasSize = function(container) {
	  var r = this;
	  var data = r.data;
	  var width = container.clientWidth;
	  var height = container.clientHeight;
	  var pixelRatio = r.getPixelRatio();
	  var mbPxRatio = r.motionBlurPxRatio;
	
	  if(
	    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] ||
	    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]
	  ){
	    pixelRatio = mbPxRatio;
	  }
	
	  var canvasWidth = width * pixelRatio;
	  var canvasHeight = height * pixelRatio;
	  var canvas;
	
	  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
	    return; // save cycles if same
	  }
	
	  r.fontCaches = null; // resizing resets the style
	
	  var canvasContainer = data.canvasContainer;
	  canvasContainer.style.width = width + 'px';
	  canvasContainer.style.height = height + 'px';
	
	  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
	
	    canvas = data.canvases[i];
	
	    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
	
	      canvas.width = canvasWidth;
	      canvas.height = canvasHeight;
	
	      canvas.style.width = width + 'px';
	      canvas.style.height = height + 'px';
	    }
	  }
	
	  for (var i = 0; i < r.BUFFER_COUNT; i++) {
	
	    canvas = data.bufferCanvases[i];
	
	    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
	
	      canvas.width = canvasWidth;
	      canvas.height = canvasHeight;
	
	      canvas.style.width = width + 'px';
	      canvas.style.height = height + 'px';
	    }
	  }
	
	  r.textureMult = 1;
	  if( pixelRatio <= 1 ){
	    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];
	
	    r.textureMult = 2;
	    canvas.width = canvasWidth * r.textureMult;
	    canvas.height = canvasHeight * r.textureMult;
	  }
	
	  r.canvasWidth = canvasWidth;
	  r.canvasHeight = canvasHeight;
	
	};
	
	CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
	  this.render({
	    forcedContext: cxt,
	    forcedZoom: zoom,
	    forcedPan: pan,
	    drawAllLayers: true,
	    forcedPxRatio: pxRatio
	  });
	};
	
	CRp.render = function( options ) {
	  options = options || util.staticEmptyObject();
	
	  var forcedContext = options.forcedContext;
	  var drawAllLayers = options.drawAllLayers;
	  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
	  var forcedZoom = options.forcedZoom;
	  var forcedPan = options.forcedPan;
	  var r = this;
	  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
	  var cy = r.cy; var data = r.data;
	  var needDraw = data.canvasNeedsRedraw;
	  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
	  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
	  var mbPxRatio = r.motionBlurPxRatio;
	  var hasCompoundNodes = cy.hasCompoundNodes();
	  var inNodeDragGesture = r.hoverData.draggingEles;
	  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
	  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
	  var motionBlurFadeEffect = motionBlur;
	
	  if( !forcedContext ){
	    if( r.prevPxRatio !== pixelRatio ){
	      r.invalidateContainerClientCoordsCache();
	      r.matchCanvasSize( r.container );
	
	      r.redrawHint('eles', true);
	      r.redrawHint('drag', true);
	    }
	
	    r.prevPxRatio = pixelRatio;
	  }
	
	  if( !forcedContext && r.motionBlurTimeout ){
	    clearTimeout( r.motionBlurTimeout );
	  }
	
	  if( motionBlur ){
	    if( r.mbFrames == null ){
	      r.mbFrames = 0;
	    }
	
	    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
	      r.mbFrames++;
	    }
	
	    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
	      motionBlurFadeEffect = false;
	    }
	
	    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
	    if( r.mbFrames > r.minMbLowQualFrames ){
	      //r.fullQualityMb = false;
	      r.motionBlurPxRatio = r.mbPxRBlurry;
	    }
	  }
	
	  if( r.clearingMotionBlur ){
	    r.motionBlurPxRatio = 1;
	  }
	
	  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
	  // because a rogue async texture frame would clear needDraw
	  if( r.textureDrawLastFrame && !textureDraw ){
	    needDraw[r.NODE] = true;
	    needDraw[r.SELECT_BOX] = true;
	  }
	
	  var edges = r.getCachedEdges();
	  var coreStyle = cy.style()._private.coreStyle;
	
	  var zoom = cy.zoom();
	  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
	  var pan = cy.pan();
	  var effectivePan = {
	    x: pan.x,
	    y: pan.y
	  };
	
	  var vp = {
	    zoom: zoom,
	    pan: {
	      x: pan.x,
	      y: pan.y
	    }
	  };
	  var prevVp = r.prevViewport;
	  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;
	
	  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
	  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
	    r.motionBlurPxRatio = 1;
	  }
	
	  if( forcedPan ){
	    effectivePan = forcedPan;
	  }
	
	  // apply pixel ratio
	
	  effectiveZoom *= pixelRatio;
	  effectivePan.x *= pixelRatio;
	  effectivePan.y *= pixelRatio;
	
	  var eles = {
	    drag: {
	      nodes: [],
	      edges: [],
	      eles: []
	    },
	    nondrag: {
	      nodes: [],
	      edges: [],
	      eles: []
	    }
	  };
	
	  function mbclear( context, x, y, w, h ){
	    var gco = context.globalCompositeOperation;
	
	    context.globalCompositeOperation = 'destination-out';
	    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
	    context.fillRect(x, y, w, h);
	
	    context.globalCompositeOperation = gco;
	  }
	
	  function setContextTransform(context, clear){
	    var ePan, eZoom, w, h;
	
	    if( !r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG]) ){
	      ePan = {
	        x: pan.x * mbPxRatio,
	        y: pan.y * mbPxRatio
	      };
	
	      eZoom = zoom * mbPxRatio;
	
	      w = r.canvasWidth * mbPxRatio;
	      h = r.canvasHeight * mbPxRatio;
	    } else {
	      ePan = effectivePan;
	      eZoom = effectiveZoom;
	
	      w = r.canvasWidth;
	      h = r.canvasHeight;
	    }
	
	    context.setTransform(1, 0, 0, 1, 0, 0);
	
	    if( clear === 'motionBlur' ){
	      mbclear(context, 0, 0, w, h);
	    } else if( !forcedContext && (clear === undefined || clear) ){
	      context.clearRect(0, 0, w, h);
	    }
	
	    if( !drawAllLayers ){
	      context.translate( ePan.x, ePan.y );
	      context.scale( eZoom, eZoom );
	    }
	    if( forcedPan ){
	      context.translate( forcedPan.x, forcedPan.y );
	    }
	    if( forcedZoom ){
	      context.scale( forcedZoom, forcedZoom );
	    }
	  }
	
	  if( !textureDraw ){
	    r.textureDrawLastFrame = false;
	  }
	
	  if( textureDraw ){
	    r.textureDrawLastFrame = true;
	
	    var bb;
	
	    if( !r.textureCache ){
	      r.textureCache = {};
	
	      bb = r.textureCache.bb = cy.elements().boundingBox();
	
	      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];
	
	      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];
	
	      cxt.setTransform(1, 0, 0, 1, 0, 0);
	      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
	
	      r.render({
	        forcedContext: cxt,
	        drawOnlyNodeLayer: true,
	        forcedPxRatio: pixelRatio * r.textureMult
	      });
	
	      var vp = r.textureCache.viewport = {
	        zoom: cy.zoom(),
	        pan: cy.pan(),
	        width: r.canvasWidth,
	        height: r.canvasHeight
	      };
	
	      vp.mpan = {
	        x: (0 - vp.pan.x)/vp.zoom,
	        y: (0 - vp.pan.y)/vp.zoom
	      };
	    }
	
	    needDraw[r.DRAG] = false;
	    needDraw[r.NODE] = false;
	
	    var context = data.contexts[r.NODE];
	
	    var texture = r.textureCache.texture;
	    var vp = r.textureCache.viewport;
	    bb = r.textureCache.bb;
	
	    context.setTransform(1, 0, 0, 1, 0, 0);
	
	    if( motionBlur ){
	      mbclear(context, 0, 0, vp.width, vp.height);
	    } else {
	      context.clearRect(0, 0, vp.width, vp.height);
	    }
	
	    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
	    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
	    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
	    context.fillRect( 0, 0, vp.width, vp.height );
	
	    var zoom = cy.zoom();
	
	    setContextTransform( context, false );
	
	    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
	    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
	
	  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
	    r.textureCache = null;
	  }
	
	  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
	  var hideEdges = r.hideEdgesOnViewport && vpManip;
	  var hideLabels = r.hideLabelsOnViewport && vpManip;
	
	  if (needDraw[r.DRAG] || needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer) {
	    if( hideEdges ){
	    } else {
	      r.findEdgeControlPoints(edges);
	    }
	
	    var zEles = r.getCachedZSortedEles();
	    var extent = cy.extent();
	
	    for (var i = 0; i < zEles.length; i++) {
	      var ele = zEles[i];
	      var list;
	      var bb = forcedContext ? null : ele.boundingBox();
	      var insideExtent = forcedContext ? true : math.boundingBoxesIntersect( extent, bb );
	
	      if( !insideExtent ){ continue; } // no need to render
	
	      if ( ele._private.rscratch.inDragLayer ) {
	        list = eles.drag;
	      } else {
	        list = eles.nondrag;
	      }
	
	      list.eles.push( ele );
	    }
	
	  }
	
	
	  function drawElements( list, context ){
	    var eles = list.eles;
	
	    for( var i = 0; i < eles.length; i++ ){
	      var ele = eles[i];
	
	      if( ele.isNode() ){
	        r.drawNode(context, ele);
	
	        if( !hideLabels ){
	          r.drawNodeText(context, ele);
	        }
	
	        r.drawNode(context, ele, true);
	      } else if( !hideEdges ) {
	        r.drawEdge(context, ele);
	
	        if( !hideLabels ){
	          r.drawEdgeText(context, ele);
	        }
	
	        r.drawEdge(context, ele, true);
	      }
	
	
	    }
	
	  }
	
	  var needMbClear = [];
	
	  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
	  if( needMbClear[r.NODE] ){ r.clearedForMotionBlur[r.NODE] = true; }
	
	  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
	  if( needMbClear[r.DRAG] ){ r.clearedForMotionBlur[r.DRAG] = true; }
	
	  if( needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE] ){
	    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
	    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[r.NODE] );
	    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
	
	    setContextTransform( context, clear );
	    drawElements(eles.nondrag, context);
	
	    if( !drawAllLayers && !motionBlur ){
	      needDraw[r.NODE] = false;
	    }
	  }
	
	  if ( !drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG]) ) {
	    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
	    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[r.DRAG] );
	
	    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
	    drawElements(eles.drag, context);
	
	    if( !drawAllLayers && !motionBlur ){
	      needDraw[r.DRAG] = false;
	    }
	  }
	
	  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[r.SELECT_BOX] && !drawAllLayers)) ) {
	    var context = forcedContext || data.contexts[r.SELECT_BOX];
	
	    setContextTransform( context );
	
	    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
	      var zoom = r.cy.zoom();
	      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
	
	      context.lineWidth = borderWidth;
	      context.fillStyle = "rgba("
	        + coreStyle['selection-box-color'].value[0] + ","
	        + coreStyle['selection-box-color'].value[1] + ","
	        + coreStyle['selection-box-color'].value[2] + ","
	        + coreStyle['selection-box-opacity'].value + ")";
	
	      context.fillRect(
	        r.selection[0],
	        r.selection[1],
	        r.selection[2] - r.selection[0],
	        r.selection[3] - r.selection[1]);
	
	      if (borderWidth > 0) {
	        context.strokeStyle = "rgba("
	          + coreStyle['selection-box-border-color'].value[0] + ","
	          + coreStyle['selection-box-border-color'].value[1] + ","
	          + coreStyle['selection-box-border-color'].value[2] + ","
	          + coreStyle['selection-box-opacity'].value + ")";
	
	        context.strokeRect(
	          r.selection[0],
	          r.selection[1],
	          r.selection[2] - r.selection[0],
	          r.selection[3] - r.selection[1]);
	      }
	    }
	
	    if( data.bgActivePosistion && !r.hoverData.selecting ){
	      var zoom = r.cy.zoom();
	      var pos = data.bgActivePosistion;
	
	      context.fillStyle = "rgba("
	        + coreStyle['active-bg-color'].value[0] + ","
	        + coreStyle['active-bg-color'].value[1] + ","
	        + coreStyle['active-bg-color'].value[2] + ","
	        + coreStyle['active-bg-opacity'].value + ")";
	
	      context.beginPath();
	      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
	      context.fill();
	    }
	
	    var timeToRender = r.lastRedrawTime;
	    if( r.showFps && timeToRender ){
	      timeToRender = Math.round( timeToRender );
	      var fps = Math.round(1000/timeToRender);
	
	      context.setTransform(1, 0, 0, 1, 0, 0);
	
	      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
	      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
	      context.lineWidth = 1;
	      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
	
	      var maxFps = 60;
	      context.strokeRect(0, 30, 250, 20);
	      context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
	    }
	
	    if( !drawAllLayers ){
	      needDraw[r.SELECT_BOX] = false;
	    }
	  }
	
	  // motionblur: blit rendered blurry frames
	  if( motionBlur && mbPxRatio !== 1 ){
	    var cxtNode = data.contexts[r.NODE];
	    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];
	
	    var cxtDrag = data.contexts[r.DRAG];
	    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];
	
	    var drawMotionBlur = function( cxt, txt, needClear ){
	      cxt.setTransform(1, 0, 0, 1, 0, 0);
	
	      if( needClear || !motionBlurFadeEffect ){
	        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
	      } else {
	        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
	      }
	
	      var pxr = mbPxRatio;
	
	      cxt.drawImage(
	        txt, // img
	        0, 0, // sx, sy
	        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
	        0, 0, // x, y
	        r.canvasWidth, r.canvasHeight // w, h
	      );
	    };
	
	    if( needDraw[r.NODE] || needMbClear[r.NODE] ){
	      drawMotionBlur( cxtNode, txtNode, needMbClear[r.NODE] );
	      needDraw[r.NODE] = false;
	    }
	
	    if( needDraw[r.DRAG] || needMbClear[r.DRAG] ){
	      drawMotionBlur( cxtDrag, txtDrag, needMbClear[r.DRAG] );
	      needDraw[r.DRAG] = false;
	    }
	  }
	
	  r.prevViewport = vp;
	
	  if( r.clearingMotionBlur ){
	    r.clearingMotionBlur = false;
	    r.motionBlurCleared = true;
	    r.motionBlur = true;
	  }
	
	  if( motionBlur ){
	    r.motionBlurTimeout = setTimeout(function(){
	      r.motionBlurTimeout = null;
	
	      r.clearedForMotionBlur[r.NODE] = false;
	      r.clearedForMotionBlur[r.DRAG] = false;
	      r.motionBlur = false;
	      r.clearingMotionBlur = !textureDraw;
	      r.mbFrames = 0;
	
	      needDraw[r.NODE] = true;
	      needDraw[r.DRAG] = true;
	
	      r.redraw();
	    }, motionBlurDelay);
	  }
	
	  r.drawingImage = false;
	
	
	  if( !forcedContext && !r.initrender ){
	    r.initrender = true;
	    cy.trigger('initrender');
	  }
	
	  if( !forcedContext ){
	    cy.triggerOnRender();
	  }
	
	};
	
	module.exports = CRp;
	
	},{"../../../math":79,"../../../util":94}],68:[function(_dereq_,module,exports){
	'use strict';
	
	  var math = _dereq_('../../../math');
	
	  var CRp = {};
	
	  // @O Polygon drawing
	  CRp.drawPolygonPath = function(
	    context, x, y, width, height, points) {
	
	    var halfW = width / 2;
	    var halfH = height / 2;
	
	    if( context.beginPath ){ context.beginPath(); }
	
	    context.moveTo( x + halfW * points[0], y + halfH * points[1] );
	
	    for (var i = 1; i < points.length / 2; i++) {
	      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
	    }
	
	    context.closePath();
	  };
	
	  // Round rectangle drawing
	  CRp.drawRoundRectanglePath = function(
	    context, x, y, width, height, radius) {
	
	    var halfWidth = width / 2;
	    var halfHeight = height / 2;
	    var cornerRadius = math.getRoundRectangleRadius(width, height);
	
	    if( context.beginPath ){ context.beginPath(); }
	
	    // Start at top middle
	    context.moveTo(x, y - halfHeight);
	    // Arc from middle top to right side
	    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
	    // Arc from right side to bottom
	    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
	    // Arc from bottom to left side
	    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
	    // Arc from left side to topBorder
	    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
	    // Join line
	    context.lineTo(x, y - halfHeight);
	
	
	    context.closePath();
	  };
	
	  var sin0 = Math.sin(0);
	  var cos0 = Math.cos(0);
	
	  var sin = {};
	  var cos = {};
	
	  var ellipseStepSize = Math.PI / 40;
	
	  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
	    sin[i] = Math.sin(i);
	    cos[i] = Math.cos(i);
	  }
	
	  CRp.drawEllipsePath = function(context, centerX, centerY, width, height){
	    if( context.beginPath ){ context.beginPath(); }
	
	    if( context.ellipse ){
	      context.ellipse( centerX, centerY, width/2, height/2, 0, 0, 2*Math.PI );
	    } else {
	      var xPos, yPos;
	      var rw = width/2;
	      var rh = height/2;
	      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
	        xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
	        yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;
	
	        if (i === 0) {
	          context.moveTo(xPos, yPos);
	        } else {
	          context.lineTo(xPos, yPos);
	        }
	      }
	    }
	
	    context.closePath();
	  };
	
	module.exports = CRp;
	
	},{"../../../math":79}],69:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../../../is');
	
	var CRp = {};
	
	CRp.createBuffer = function(w, h) {
	  var buffer = document.createElement('canvas');
	  buffer.width = w;
	  buffer.height = h;
	
	  return [buffer, buffer.getContext('2d')];
	};
	
	CRp.bufferCanvasImage = function( options ){
	  var cy = this.cy;
	  var bb = cy.elements().boundingBox();
	  var width = options.full ? Math.ceil(bb.w) : this.container.clientWidth;
	  var height = options.full ? Math.ceil(bb.h) : this.container.clientHeight;
	  var scale = 1;
	
	  if( options.scale !== undefined ){
	    width *= options.scale;
	    height *= options.scale;
	
	    scale = options.scale;
	  } else if( is.number(options.maxWidth) || is.number(options.maxHeight) ){
	    var maxScaleW = Infinity;
	    var maxScaleH = Infinity;
	
	    if( is.number(options.maxWidth) ){
	      maxScaleW = scale * options.maxWidth / width;
	    }
	
	    if( is.number(options.maxHeight) ){
	      maxScaleH = scale * options.maxHeight / height;
	    }
	
	    scale = Math.min( maxScaleW, maxScaleH );
	
	    width *= scale;
	    height *= scale;
	  }
	
	  var buffCanvas = document.createElement('canvas');
	
	  buffCanvas.width = width;
	  buffCanvas.height = height;
	
	  buffCanvas.style.width = width + 'px';
	  buffCanvas.style.height = height + 'px';
	
	  var buffCxt = buffCanvas.getContext('2d');
	
	  // Rasterize the layers, but only if container has nonzero size
	  if (width > 0 && height > 0) {
	
	    buffCxt.clearRect( 0, 0, width, height );
	
	    if( options.bg ){
	      buffCxt.fillStyle = options.bg;
	      buffCxt.rect( 0, 0, width, height );
	      buffCxt.fill();
	    }
	
	    buffCxt.globalCompositeOperation = 'source-over';
	
	    if( options.full ){ // draw the full bounds of the graph
	      this.render({
	        forcedContext: buffCxt,
	        drawAllLayers: true,
	        forcedZoom: scale,
	        forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
	        forcedPxRatio: 1
	      });
	    } else { // draw the current view
	      var cyPan = cy.pan();
	      var pan = {
	        x: cyPan.x * scale,
	        y: cyPan.y * scale
	      };
	      var zoom = cy.zoom() * scale;
	
	      this.render({
	        forcedContext: buffCxt,
	        drawAllLayers: true,
	        forcedZoom: zoom,
	        forcedPan: pan,
	        forcedPxRatio: 1
	      });
	    }
	  }
	
	  return buffCanvas;
	};
	
	CRp.png = function( options ){
	  return this.bufferCanvasImage( options ).toDataURL('image/png');
	};
	
	CRp.jpg = function( options ){
	  return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
	};
	
	module.exports = CRp;
	
	},{"../../../is":77}],70:[function(_dereq_,module,exports){
	/*
	The canvas renderer was written by Yue Dong.
	
	Modifications tracked on Github.
	*/
	
	'use strict';
	
	var util = _dereq_('../../../util');
	var is = _dereq_('../../../is');
	
	var CR = CanvasRenderer;
	var CRp = CanvasRenderer.prototype;
	
	CRp.CANVAS_LAYERS = 3;
	//
	CRp.SELECT_BOX = 0;
	CRp.DRAG = 1;
	CRp.NODE = 2;
	
	CRp.BUFFER_COUNT = 3;
	//
	CRp.TEXTURE_BUFFER = 0;
	CRp.MOTIONBLUR_BUFFER_NODE = 1;
	CRp.MOTIONBLUR_BUFFER_DRAG = 2;
	
	function CanvasRenderer(options) {
	  var r = this;
	
	  r.data = {
	    canvases: new Array(CRp.CANVAS_LAYERS),
	    contexts: new Array(CRp.CANVAS_LAYERS),
	    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),
	
	    bufferCanvases: new Array(CRp.BUFFER_COUNT),
	    bufferContexts: new Array(CRp.CANVAS_LAYERS)
	  };
	
	  r.data.canvasContainer = document.createElement('div');
	  var containerStyle = r.data.canvasContainer.style;
	  r.data.canvasContainer.setAttribute('style', '-webkit-tap-highlight-color: rgba(0,0,0,0);');
	  containerStyle.position = 'relative';
	  containerStyle.zIndex = '0';
	  containerStyle.overflow = 'hidden';
	
	  var container = options.cy.container();
	  container.appendChild( r.data.canvasContainer );
	  container.setAttribute('style', ( container.getAttribute('style') || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);');
	
	  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
	    var canvas = r.data.canvases[i] = document.createElement('canvas');
	    r.data.contexts[i] = canvas.getContext('2d');
	    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
	    canvas.style.position = 'absolute';
	    canvas.setAttribute('data-id', 'layer' + i);
	    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
	    r.data.canvasContainer.appendChild(canvas);
	
	    r.data.canvasNeedsRedraw[i] = false;
	  }
	  r.data.topCanvas = r.data.canvases[0];
	
	  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
	  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
	  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');
	
	  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
	    r.data.bufferCanvases[i] = document.createElement('canvas');
	    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
	    r.data.bufferCanvases[i].style.position = 'absolute';
	    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
	    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
	    r.data.bufferCanvases[i].style.visibility = 'hidden';
	    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
	  }
	
	  r.pathsEnabled = true;
	}
	
	CRp.redrawHint = function( group, bool ){
	  var r = this;
	
	  switch( group ){
	    case 'eles':
	      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
	      break;
	    case 'drag':
	      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
	      break;
	    case 'select':
	      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
	      break;
	  }
	};
	
	// whether to use Path2D caching for drawing
	var pathsImpld = typeof Path2D !== 'undefined';
	
	CRp.path2dEnabled = function( on ){
	  if( on === undefined ){
	    return this.pathsEnabled;
	  }
	
	  this.pathsEnabled = on ? true : false;
	};
	
	CRp.usePaths = function(){
	  return pathsImpld && this.pathsEnabled;
	};
	
	[
	  _dereq_('./arrow-shapes'),
	  _dereq_('./drawing-edges'),
	  _dereq_('./drawing-images'),
	  _dereq_('./drawing-label-text'),
	  _dereq_('./drawing-nodes'),
	  _dereq_('./drawing-redraw'),
	  _dereq_('./drawing-shapes'),
	  _dereq_('./export-image'),
	  _dereq_('./node-shapes')
	].forEach(function( props ){
	  util.extend( CRp, props );
	});
	
	module.exports = CR;
	
	},{"../../../is":77,"../../../util":94,"./arrow-shapes":62,"./drawing-edges":63,"./drawing-images":64,"./drawing-label-text":65,"./drawing-nodes":66,"./drawing-redraw":67,"./drawing-shapes":68,"./export-image":69,"./node-shapes":71}],71:[function(_dereq_,module,exports){
	'use strict';
	
	var CRp = {};
	
	var impl;
	
	CRp.nodeShapeImpl = function( name ){
	  var self = this;
	
	  return ( impl || (impl = {
	    'ellipse': function( context, centerX, centerY, width, height ){
	      self.drawEllipsePath( context, centerX, centerY, width, height );
	    },
	
	    'polygon': function( context, centerX, centerY, width, height, points ){
	      self.drawPolygonPath( context, centerX, centerY, width, height, points );
	    },
	
	    'roundrectangle': function( context, centerX, centerY, width, height ){
	      self.drawRoundRectanglePath( context, centerX, centerY, width, height, 10 );
	    }
	  }) )[ name ];
	};
	
	module.exports = CRp;
	
	},{}],72:[function(_dereq_,module,exports){
	'use strict';
	
	module.exports = [
	  { name: 'null', impl: _dereq_('./null') },
	  { name: 'base', impl: _dereq_('./base') },
	  { name: 'canvas', impl: _dereq_('./canvas') }
	];
	
	},{"./base":58,"./canvas":70,"./null":73}],73:[function(_dereq_,module,exports){
	'use strict';
	
	function NullRenderer(options){
	  this.options = options;
	  this.notifications = 0; // for testing
	}
	
	var noop = function(){};
	
	NullRenderer.prototype = {
	  recalculateRenderedStyle: noop,
	  notify: function(){ this.notifications++; },
	  init: noop
	};
	
	module.exports = NullRenderer;
	
	},{}],74:[function(_dereq_,module,exports){
	/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */
	
	'use strict';
	
	var is = _dereq_('./is');
	var util = _dereq_('./util');
	var Thread = _dereq_('./thread');
	var Promise = _dereq_('./promise');
	var define = _dereq_('./define');
	
	var Fabric = function( N ){
	  if( !(this instanceof Fabric) ){
	    return new Fabric( N );
	  }
	
	  this._private = {
	    pass: []
	  };
	
	  var defN = 4;
	
	  if( is.number(N) ){
	    // then use the specified number of threads
	  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
	    N = navigator.hardwareConcurrency;
	  } else {
	    try{
	      N = _dereq_('os').cpus().length;
	    } catch( err ){
	      N = defN;
	    }
	  } // TODO could use an estimation here but would the additional expense be worth it?
	
	  for( var i = 0; i < N; i++ ){
	    this[i] = new Thread();
	  }
	
	  this.length = N;
	};
	
	var fabfn = Fabric.prototype; // short alias
	
	util.extend(fabfn, {
	
	  instanceString: function(){ return 'fabric'; },
	
	  // require fn in all threads
	  require: function( fn, as ){
	    for( var i = 0; i < this.length; i++ ){
	      var thread = this[i];
	
	      thread.require( fn, as );
	    }
	
	    return this;
	  },
	
	  // get a random thread
	  random: function(){
	    var i = Math.round( (this.length - 1) * Math.random() );
	    var thread = this[i];
	
	    return thread;
	  },
	
	  // run on random thread
	  run: function( fn ){
	    var pass = this._private.pass.shift();
	
	    return this.random().pass( pass ).run( fn );
	  },
	
	  // sends a random thread a message
	  message: function( m ){
	    return this.random().message( m );
	  },
	
	  // send all threads a message
	  broadcast: function( m ){
	    for( var i = 0; i < this.length; i++ ){
	      var thread = this[i];
	
	      thread.message( m );
	    }
	
	    return this; // chaining
	  },
	
	  // stop all threads
	  stop: function(){
	    for( var i = 0; i < this.length; i++ ){
	      var thread = this[i];
	
	      thread.stop();
	    }
	
	    return this; // chaining
	  },
	
	  // pass data to be used with .spread() etc.
	  pass: function( data ){
	    var pass = this._private.pass;
	
	    if( is.array(data) ){
	      pass.push( data );
	    } else {
	      throw 'Only arrays may be used with fabric.pass()';
	    }
	
	    return this; // chaining
	  },
	
	  spreadSize: function(){
	    var subsize =  Math.ceil( this._private.pass[0].length / this.length );
	
	    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread
	
	    return subsize;
	  },
	
	  // split the data into slices to spread the data equally among threads
	  spread: function( fn ){
	    var self = this;
	    var _p = self._private;
	    var subsize = self.spreadSize(); // number of pass eles to handle in each thread
	    var pass = _p.pass.shift().concat([]); // keep a copy
	    var runPs = [];
	
	    for( var i = 0; i < this.length; i++ ){
	      var thread = this[i];
	      var slice = pass.splice( 0, subsize );
	
	      var runP = thread.pass( slice ).run( fn );
	
	      runPs.push( runP );
	
	      var doneEarly = pass.length === 0;
	      if( doneEarly ){ break; }
	    }
	
	    return Promise.all( runPs ).then(function( thens ){
	      var postpass = [];
	      var p = 0;
	
	      // fill postpass with the total result joined from all threads
	      for( var i = 0; i < thens.length; i++ ){
	        var then = thens[i]; // array result from thread i
	
	        for( var j = 0; j < then.length; j++ ){
	          var t = then[j]; // array element
	
	          postpass[ p++ ] = t;
	        }
	      }
	
	      return postpass;
	    });
	  },
	
	  // parallel version of array.map()
	  map: function( fn ){
	    var self = this;
	
	    self.require( fn, '_$_$_fabmap' );
	
	    return self.spread(function( split ){
	      var mapped = [];
	      var origResolve = resolve; // jshint ignore:line
	
	      resolve = function( val ){ // jshint ignore:line
	        mapped.push( val );
	      };
	
	      for( var i = 0; i < split.length; i++ ){
	        var oldLen = mapped.length;
	        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line
	        var nothingInsdByResolve = oldLen === mapped.length;
	
	        if( nothingInsdByResolve ){
	          mapped.push( ret );
	        }
	      }
	
	      resolve = origResolve; // jshint ignore:line
	
	      return mapped;
	    });
	
	  },
	
	  // parallel version of array.filter()
	  filter: function( fn ){
	    var _p = this._private;
	    var pass = _p.pass[0];
	
	    return this.map( fn ).then(function( include ){
	      var ret = [];
	
	      for( var i = 0; i < pass.length; i++ ){
	        var datum = pass[i];
	        var incDatum = include[i];
	
	        if( incDatum ){
	          ret.push( datum );
	        }
	      }
	
	      return ret;
	    });
	  },
	
	  // sorts the passed array using a divide and conquer strategy
	  sort: function( cmp ){
	    var self = this;
	    var P = this._private.pass[0].length;
	    var subsize = this.spreadSize();
	
	    cmp = cmp || function( a, b ){ // default comparison function
	      if( a < b ){
	        return -1;
	      } else if( a > b ){
	        return 1;
	      }
	
	      return 0;
	    };
	
	    self.require( cmp, '_$_$_cmp' );
	
	    return self.spread(function( split ){ // sort each split normally
	      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line
	      resolve( sortedSplit ); // jshint ignore:line
	
	    }).then(function( joined ){
	      // do all the merging in the main thread to minimise data transfer
	
	      // TODO could do merging in separate threads but would incur add'l cost of data transfer
	      // for each level of the merge
	
	      var merge = function( i, j, max ){
	        // don't overflow array
	        j = Math.min( j, P );
	        max = Math.min( max, P );
	
	        // left and right sides of merge
	        var l = i;
	        var r = j;
	
	        var sorted = [];
	
	        for( var k = l; k < max; k++ ){
	
	          var eleI = joined[i];
	          var eleJ = joined[j];
	
	          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
	            sorted.push( eleI );
	            i++;
	          } else {
	            sorted.push( eleJ );
	            j++;
	          }
	
	        }
	
	        // in the array proper, put the sorted values
	        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
	          var index = l + k;
	
	          joined[ index ] = sorted[k];
	        }
	      };
	
	      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1
	
	        for( var i = 0; i < P; i += 2*splitL ){
	          merge( i, i + splitL, i + 2*splitL );
	        }
	
	      }
	
	      return joined;
	    });
	  }
	
	
	});
	
	var defineRandomPasser = function( opts ){
	  opts = opts || {};
	
	  return function( fn, arg1 ){
	    var pass = this._private.pass.shift();
	
	    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
	  };
	};
	
	util.extend(fabfn, {
	  randomMap: defineRandomPasser({ threadFn: 'map' }),
	
	  reduce: defineRandomPasser({ threadFn: 'reduce' }),
	
	  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
	});
	
	// aliases
	var fn = fabfn;
	fn.promise = fn.run;
	fn.terminate = fn.halt = fn.stop;
	fn.include = fn.require;
	
	// pull in event apis
	util.extend(fabfn, {
	  on: define.on(),
	  one: define.on({ unbindSelfOnTrigger: true }),
	  off: define.off(),
	  trigger: define.trigger()
	});
	
	define.eventAliasesOn( fabfn );
	
	module.exports = Fabric;
	
	},{"./define":41,"./is":77,"./promise":80,"./thread":92,"./util":94,"os":undefined}],75:[function(_dereq_,module,exports){
	/*!
	Ported by Xueqiao Xu <xueqiaoxu@gmail.com>;
	
	PSF LICENSE AGREEMENT FOR PYTHON 2.7.2
	
	1. This LICENSE AGREEMENT is between the Python Software Foundation (PSF), and the Individual or Organization (Licensee) accessing and otherwise using Python 2.7.2 software in source or binary form and its associated documentation.
	2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 2.7.2 alone or in any derivative version, provided, however, that PSFs License Agreement and PSFs notice of copyright, i.e., Copyright  2001-2012 Python Software Foundation; All Rights Reserved are retained in Python 2.7.2 alone or in any derivative version prepared by Licensee.
	3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.7.2 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 2.7.2.
	4. PSF is making Python 2.7.2 available to Licensee on an AS IS basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.7.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
	5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.7.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.7.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
	6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
	7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
	8. By copying, installing or otherwise using Python 2.7.2, Licensee agrees to be bound by the terms and conditions of this License Agreement.
	*/
	
	'use strict';
	/* jshint ignore:start */
	
	// Generated by CoffeeScript 1.8.0
	(function() {
	  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
	
	  floor = Math.floor, min = Math.min;
	
	
	  /*
	  Default comparison function to be used
	   */
	
	  defaultCmp = function(x, y) {
	    if (x < y) {
	      return -1;
	    }
	    if (x > y) {
	      return 1;
	    }
	    return 0;
	  };
	
	
	  /*
	  Insert item x in list a, and keep it sorted assuming a is sorted.
	
	  If x is already in a, insert it to the right of the rightmost x.
	
	  Optional args lo (default 0) and hi (default a.length) bound the slice
	  of a to be searched.
	   */
	
	  insort = function(a, x, lo, hi, cmp) {
	    var mid;
	    if (lo == null) {
	      lo = 0;
	    }
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    if (lo < 0) {
	      throw new Error('lo must be non-negative');
	    }
	    if (hi == null) {
	      hi = a.length;
	    }
	    while (lo < hi) {
	      mid = floor((lo + hi) / 2);
	      if (cmp(x, a[mid]) < 0) {
	        hi = mid;
	      } else {
	        lo = mid + 1;
	      }
	    }
	    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
	  };
	
	
	  /*
	  Push item onto heap, maintaining the heap invariant.
	   */
	
	  heappush = function(array, item, cmp) {
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    array.push(item);
	    return _siftdown(array, 0, array.length - 1, cmp);
	  };
	
	
	  /*
	  Pop the smallest item off the heap, maintaining the heap invariant.
	   */
	
	  heappop = function(array, cmp) {
	    var lastelt, returnitem;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    lastelt = array.pop();
	    if (array.length) {
	      returnitem = array[0];
	      array[0] = lastelt;
	      _siftup(array, 0, cmp);
	    } else {
	      returnitem = lastelt;
	    }
	    return returnitem;
	  };
	
	
	  /*
	  Pop and return the current smallest value, and add the new item.
	
	  This is more efficient than heappop() followed by heappush(), and can be
	  more appropriate when using a fixed size heap. Note that the value
	  returned may be larger than item! That constrains reasonable use of
	  this routine unless written as part of a conditional replacement:
	      if item > array[0]
	        item = heapreplace(array, item)
	   */
	
	  heapreplace = function(array, item, cmp) {
	    var returnitem;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    returnitem = array[0];
	    array[0] = item;
	    _siftup(array, 0, cmp);
	    return returnitem;
	  };
	
	
	  /*
	  Fast version of a heappush followed by a heappop.
	   */
	
	  heappushpop = function(array, item, cmp) {
	    var _ref;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    if (array.length && cmp(array[0], item) < 0) {
	      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
	      _siftup(array, 0, cmp);
	    }
	    return item;
	  };
	
	
	  /*
	  Transform list into a heap, in-place, in O(array.length) time.
	   */
	
	  heapify = function(array, cmp) {
	    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    _ref1 = (function() {
	      _results1 = [];
	      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
	      return _results1;
	    }).apply(this).reverse();
	    _results = [];
	    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	      i = _ref1[_i];
	      _results.push(_siftup(array, i, cmp));
	    }
	    return _results;
	  };
	
	
	  /*
	  Update the position of the given item in the heap.
	  This function should be called every time the item is being modified.
	   */
	
	  updateItem = function(array, item, cmp) {
	    var pos;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    pos = array.indexOf(item);
	    if (pos === -1) {
	      return;
	    }
	    _siftdown(array, 0, pos, cmp);
	    return _siftup(array, pos, cmp);
	  };
	
	
	  /*
	  Find the n largest elements in a dataset.
	   */
	
	  nlargest = function(array, n, cmp) {
	    var elem, result, _i, _len, _ref;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    result = array.slice(0, n);
	    if (!result.length) {
	      return result;
	    }
	    heapify(result, cmp);
	    _ref = array.slice(n);
	    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	      elem = _ref[_i];
	      heappushpop(result, elem, cmp);
	    }
	    return result.sort(cmp).reverse();
	  };
	
	
	  /*
	  Find the n smallest elements in a dataset.
	   */
	
	  nsmallest = function(array, n, cmp) {
	    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    if (n * 10 <= array.length) {
	      result = array.slice(0, n).sort(cmp);
	      if (!result.length) {
	        return result;
	      }
	      los = result[result.length - 1];
	      _ref = array.slice(n);
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        elem = _ref[_i];
	        if (cmp(elem, los) < 0) {
	          insort(result, elem, 0, null, cmp);
	          result.pop();
	          los = result[result.length - 1];
	        }
	      }
	      return result;
	    }
	    heapify(array, cmp);
	    _results = [];
	    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
	      _results.push(heappop(array, cmp));
	    }
	    return _results;
	  };
	
	  _siftdown = function(array, startpos, pos, cmp) {
	    var newitem, parent, parentpos;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    newitem = array[pos];
	    while (pos > startpos) {
	      parentpos = (pos - 1) >> 1;
	      parent = array[parentpos];
	      if (cmp(newitem, parent) < 0) {
	        array[pos] = parent;
	        pos = parentpos;
	        continue;
	      }
	      break;
	    }
	    return array[pos] = newitem;
	  };
	
	  _siftup = function(array, pos, cmp) {
	    var childpos, endpos, newitem, rightpos, startpos;
	    if (cmp == null) {
	      cmp = defaultCmp;
	    }
	    endpos = array.length;
	    startpos = pos;
	    newitem = array[pos];
	    childpos = 2 * pos + 1;
	    while (childpos < endpos) {
	      rightpos = childpos + 1;
	      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
	        childpos = rightpos;
	      }
	      array[pos] = array[childpos];
	      pos = childpos;
	      childpos = 2 * pos + 1;
	    }
	    array[pos] = newitem;
	    return _siftdown(array, startpos, pos, cmp);
	  };
	
	  Heap = (function() {
	    Heap.push = heappush;
	
	    Heap.pop = heappop;
	
	    Heap.replace = heapreplace;
	
	    Heap.pushpop = heappushpop;
	
	    Heap.heapify = heapify;
	
	    Heap.updateItem = updateItem;
	
	    Heap.nlargest = nlargest;
	
	    Heap.nsmallest = nsmallest;
	
	    function Heap(cmp) {
	      this.cmp = cmp != null ? cmp : defaultCmp;
	      this.nodes = [];
	    }
	
	    Heap.prototype.push = function(x) {
	      return heappush(this.nodes, x, this.cmp);
	    };
	
	    Heap.prototype.pop = function() {
	      return heappop(this.nodes, this.cmp);
	    };
	
	    Heap.prototype.peek = function() {
	      return this.nodes[0];
	    };
	
	    Heap.prototype.contains = function(x) {
	      return this.nodes.indexOf(x) !== -1;
	    };
	
	    Heap.prototype.replace = function(x) {
	      return heapreplace(this.nodes, x, this.cmp);
	    };
	
	    Heap.prototype.pushpop = function(x) {
	      return heappushpop(this.nodes, x, this.cmp);
	    };
	
	    Heap.prototype.heapify = function() {
	      return heapify(this.nodes, this.cmp);
	    };
	
	    Heap.prototype.updateItem = function(x) {
	      return updateItem(this.nodes, x, this.cmp);
	    };
	
	    Heap.prototype.clear = function() {
	      return this.nodes = [];
	    };
	
	    Heap.prototype.empty = function() {
	      return this.nodes.length === 0;
	    };
	
	    Heap.prototype.size = function() {
	      return this.nodes.length;
	    };
	
	    Heap.prototype.clone = function() {
	      var heap;
	      heap = new Heap();
	      heap.nodes = this.nodes.slice(0);
	      return heap;
	    };
	
	    Heap.prototype.toArray = function() {
	      return this.nodes.slice(0);
	    };
	
	    Heap.prototype.insert = Heap.prototype.push;
	
	    Heap.prototype.top = Heap.prototype.peek;
	
	    Heap.prototype.front = Heap.prototype.peek;
	
	    Heap.prototype.has = Heap.prototype.contains;
	
	    Heap.prototype.copy = Heap.prototype.clone;
	
	    return Heap;
	
	  })();
	
	  (function(root, factory) {
	    if (typeof define === 'function' && define.amd) {
	      return define([], factory);
	    } else if (typeof exports === 'object') {
	      return module.exports = factory();
	    } else {
	      return root.Heap = factory();
	    }
	  })(this, function() {
	    return Heap;
	  });
	
	}).call(this);
	
	/* jshint ignore:end */
	
	},{}],76:[function(_dereq_,module,exports){
	'use strict';
	
	var window = _dereq_('./window');
	var is = _dereq_('./is');
	var Core = _dereq_('./core');
	var extension = _dereq_('./extension');
	var registerJquery = _dereq_('./jquery-plugin');
	var Stylesheet = _dereq_('./stylesheet');
	var Thread = _dereq_('./thread');
	var Fabric = _dereq_('./fabric');
	
	var cytoscape = function( options ){ // jshint ignore:line
	  // if no options specified, use default
	  if( options === undefined ){
	    options = {};
	  }
	
	  // create instance
	  if( is.plainObject( options ) ){
	    return new Core( options );
	  }
	
	  // allow for registration of extensions
	  else if( is.string( options ) ) {
	    return extension.apply(extension, arguments);
	  }
	};
	
	// replaced by build system
	cytoscape.version = '2.6.4';
	
	// try to register w/ jquery
	if( window && window.jQuery ){
	  registerJquery( window.jQuery, cytoscape );
	}
	
	// expose register api
	cytoscape.registerJquery = function( jQuery ){
	  registerJquery( jQuery, cytoscape );
	};
	
	// expose public apis (mostly for extensions)
	cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
	cytoscape.thread = cytoscape.Thread = Thread;
	cytoscape.fabric = cytoscape.Fabric = Fabric;
	
	module.exports = cytoscape;
	
	},{"./core":34,"./extension":43,"./fabric":74,"./is":77,"./jquery-plugin":78,"./stylesheet":91,"./thread":92,"./window":100}],77:[function(_dereq_,module,exports){
	'use strict';
	
	var window = _dereq_('./window');
	var navigator = window ? window.navigator : null;
	
	var typeofstr = typeof '';
	var typeofobj = typeof {};
	var typeoffn = typeof function(){};
	var typeofhtmlele = typeof HTMLElement;
	
	var instanceStr = function( obj ){
	  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
	};
	
	var is = {
	  defined: function(obj){
	    return obj != null; // not undefined or null
	  },
	
	  string: function(obj){
	    return obj != null && typeof obj == typeofstr;
	  },
	
	  fn: function(obj){
	    return obj != null && typeof obj === typeoffn;
	  },
	
	  array: function(obj){
	    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
	  },
	
	  plainObject: function(obj){
	    return obj != null && typeof obj === typeofobj && !is.array(obj) && obj.constructor === Object;
	  },
	
	  object: function(obj){
	    return obj != null && typeof obj === typeofobj;
	  },
	
	  number: function(obj){
	    return obj != null && typeof obj === typeof 1 && !isNaN(obj);
	  },
	
	  integer: function( obj ){
	    return is.number(obj) && Math.floor(obj) === obj;
	  },
	
	  bool: function(obj){
	    return obj != null && typeof obj === typeof true;
	  },
	
	  htmlElement: function(obj){
	    if( 'undefined' === typeofhtmlele ){
	      return undefined;
	    } else {
	      return null != obj && obj instanceof HTMLElement;
	    }
	  },
	
	  elementOrCollection: function(obj){
	    return is.element(obj) || is.collection(obj);
	  },
	
	  element: function(obj){
	    return instanceStr(obj) === 'collection' && obj._private.single;
	  },
	
	  collection: function(obj){
	    return instanceStr(obj) === 'collection' && !obj._private.single;
	  },
	
	  core: function(obj){
	    return instanceStr(obj) === 'core';
	  },
	
	  style: function(obj){
	    return instanceStr(obj) === 'style';
	  },
	
	  stylesheet: function(obj){
	    return instanceStr(obj) === 'stylesheet';
	  },
	
	  event: function(obj){
	    return instanceStr(obj) === 'event';
	  },
	
	  thread: function(obj){
	    return instanceStr(obj) === 'thread';
	  },
	
	  fabric: function(obj){
	    return instanceStr(obj) === 'fabric';
	  },
	
	  emptyString: function(obj){
	    if( !obj ){ // null is empty
	      return true;
	    } else if( is.string(obj) ){
	      if( obj === '' || obj.match(/^\s+$/) ){
	        return true; // empty string is empty
	      }
	    }
	
	    return false; // otherwise, we don't know what we've got
	  },
	
	  nonemptyString: function(obj){
	    if( obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
	      return true;
	    }
	
	    return false;
	  },
	
	  domElement: function(obj){
	    if( typeof HTMLElement === 'undefined' ){
	      return false; // we're not in a browser so it doesn't matter
	    } else {
	      return obj instanceof HTMLElement;
	    }
	  },
	
	  boundingBox: function(obj){
	    return is.plainObject(obj) &&
	      is.number(obj.x1) && is.number(obj.x2) &&
	      is.number(obj.y1) && is.number(obj.y2)
	    ;
	  },
	
	  promise: function(obj){
	    return is.object(obj) && is.fn(obj.then);
	  },
	
	  touch: function(){
	    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
	  },
	
	  gecko: function(){
	    return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
	  },
	
	  webkit: function(){
	    return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
	  },
	
	  chromium: function(){
	    return typeof chrome !== 'undefined';
	  },
	
	  khtml: function(){
	    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
	  },
	
	  khtmlEtc: function(){
	    return is.khtml() || is.webkit() || is.chromium();
	  },
	
	  ms: function(){
	     return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
	  },
	
	  windows: function(){
	    return navigator && navigator.appVersion.match(/Win/i);
	  },
	
	  mac: function(){
	    return navigator && navigator.appVersion.match(/Mac/i);
	  },
	
	  linux: function(){
	    return navigator && navigator.appVersion.match(/Linux/i);
	  },
	
	  unix: function(){
	    return navigator && navigator.appVersion.match(/X11/i);
	  }
	};
	
	module.exports = is;
	
	},{"./window":100}],78:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('./is');
	
	var cyReg = function( $ele ){
	  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};
	
	  return d;
	};
	
	var registerJquery = function( $, cytoscape ){
	  if( !$ ){ return; } // no jquery => don't need this
	
	  if( $.fn.cytoscape ){ return; } // already registered
	
	  // allow calls on a jQuery selector by proxying calls to $.cytoscape
	  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
	  $.fn.cytoscape = function(opts){
	    var $this = $(this);
	
	    // get object
	    if( opts === 'get' ){
	      return cyReg( $this ).cy;
	    }
	
	    // bind to ready
	    else if( is.fn(opts) ){
	
	      var ready = opts;
	      var cy = cyReg( $this ).cy;
	
	      if( cy && cy.isReady() ){ // already ready so just trigger now
	        cy.trigger('ready', [], ready);
	
	      } else { // not yet ready, so add to readies list
	        var data = cyReg( $this );
	        var readies = data.readies = data.readies || [];
	
	        readies.push( ready );
	      }
	
	    }
	
	    // proxy to create instance
	    else if( is.plainObject(opts) ){
	      return $this.each(function(){
	        var options = $.extend({}, opts, {
	          container: $(this)[0]
	        });
	
	        cytoscape(options);
	      });
	    }
	  };
	
	  // allow access to the global cytoscape object under jquery for legacy reasons
	  $.cytoscape = cytoscape;
	
	  // use short alias (cy) if not already defined
	  if( $.fn.cy == null && $.cy == null ){
	    $.fn.cy = $.fn.cytoscape;
	    $.cy = $.cytoscape;
	  }
	};
	
	module.exports = registerJquery;
	
	},{"./is":77}],79:[function(_dereq_,module,exports){
	'use strict';
	
	var math = {};
	
	math.signum = function(x){
	  if( x > 0 ){
	    return 1;
	  } else if( x < 0 ){
	    return -1;
	  } else {
	    return 0;
	  }
	};
	
	math.distance = function( p1, p2 ){
	  return Math.sqrt( math.sqDistance(p1, p2) );
	};
	
	math.sqDistance = function( p1, p2 ){
	  var dx = p2.x - p1.x;
	  var dy = p2.y - p1.y;
	
	  return dx*dx + dy*dy;
	};
	
	// from http://en.wikipedia.org/wiki/Bzier_curve#Quadratic_curves
	math.qbezierAt = function(p0, p1, p2, t){
	  return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
	};
	
	math.qbezierPtAt = function(p0, p1, p2, t){
	  return {
	    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
	    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
	  };
	};
	
	// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
	math.makeBoundingBox = function( bb ){
	  if( bb.x1 != null && bb.y1 != null ){
	    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
	      return {
	        x1: bb.x1,
	        y1: bb.y1,
	        x2: bb.x2,
	        y2: bb.y2,
	        w: bb.x2 - bb.x1,
	        h: bb.y2 - bb.y1
	      };
	    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
	      return {
	        x1: bb.x1,
	        y1: bb.y1,
	        x2: bb.x1 + bb.w,
	        y2: bb.y1 + bb.h,
	        w: bb.w,
	        h: bb.h
	      };
	    }
	  }
	};
	
	math.boundingBoxesIntersect = function( bb1, bb2 ){
	  // case: one bb to right of other
	  if( bb1.x1 > bb2.x2 ){ return false; }
	  if( bb2.x1 > bb1.x2 ){ return false; }
	
	  // case: one bb to left of other
	  if( bb1.x2 < bb2.x1 ){ return false; }
	  if( bb2.x2 < bb1.x1 ){ return false; }
	
	  // case: one bb above other
	  if( bb1.y2 < bb2.y1 ){ return false; }
	  if( bb2.y2 < bb1.y1 ){ return false; }
	
	  // case: one bb below other
	  if( bb1.y1 > bb2.y2 ){ return false; }
	  if( bb2.y1 > bb1.y2 ){ return false; }
	
	  // otherwise, must have some overlap
	  return true;
	};
	
	math.inBoundingBox = function( bb, x, y ){
	  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
	};
	
	math.pointInBoundingBox = function( bb, pt ){
	  return this.inBoundingBox( bb, pt.x, pt.y );
	};
	
	math.roundRectangleIntersectLine = function(
	  x, y, nodeX, nodeY, width, height, padding) {
	
	  var cornerRadius = this.getRoundRectangleRadius(width, height);
	
	  var halfWidth = width / 2;
	  var halfHeight = height / 2;
	
	  // Check intersections with straight line segments
	  var straightLineIntersections;
	
	  // Top segment, left to right
	  {
	    var topStartX = nodeX - halfWidth + cornerRadius - padding;
	    var topStartY = nodeY - halfHeight - padding;
	    var topEndX = nodeX + halfWidth - cornerRadius + padding;
	    var topEndY = topStartY;
	
	    straightLineIntersections = this.finiteLinesIntersect(
	      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
	
	    if (straightLineIntersections.length > 0) {
	      return straightLineIntersections;
	    }
	  }
	
	  // Right segment, top to bottom
	  {
	    var rightStartX = nodeX + halfWidth + padding;
	    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
	    var rightEndX = rightStartX;
	    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
	
	    straightLineIntersections = this.finiteLinesIntersect(
	      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
	
	    if (straightLineIntersections.length > 0) {
	      return straightLineIntersections;
	    }
	  }
	
	  // Bottom segment, left to right
	  {
	    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
	    var bottomStartY = nodeY + halfHeight + padding;
	    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
	    var bottomEndY = bottomStartY;
	
	    straightLineIntersections = this.finiteLinesIntersect(
	      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
	
	    if (straightLineIntersections.length > 0) {
	      return straightLineIntersections;
	    }
	  }
	
	  // Left segment, top to bottom
	  {
	    var leftStartX = nodeX - halfWidth - padding;
	    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
	    var leftEndX = leftStartX;
	    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
	
	    straightLineIntersections = this.finiteLinesIntersect(
	      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
	
	    if (straightLineIntersections.length > 0) {
	      return straightLineIntersections;
	    }
	  }
	
	  // Check intersections with arc segments
	  var arcIntersections;
	
	  // Top Left
	  {
	    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
	    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
	    arcIntersections = this.intersectLineCircle(
	      x, y, nodeX, nodeY,
	      topLeftCenterX, topLeftCenterY, cornerRadius + padding);
	
	    // Ensure the intersection is on the desired quarter of the circle
	    if (arcIntersections.length > 0
	      && arcIntersections[0] <= topLeftCenterX
	      && arcIntersections[1] <= topLeftCenterY) {
	      return [arcIntersections[0], arcIntersections[1]];
	    }
	  }
	
	  // Top Right
	  {
	    var topRightCenterX = nodeX + halfWidth - cornerRadius;
	    var topRightCenterY = nodeY - halfHeight + cornerRadius;
	    arcIntersections = this.intersectLineCircle(
	      x, y, nodeX, nodeY,
	      topRightCenterX, topRightCenterY, cornerRadius + padding);
	
	    // Ensure the intersection is on the desired quarter of the circle
	    if (arcIntersections.length > 0
	      && arcIntersections[0] >= topRightCenterX
	      && arcIntersections[1] <= topRightCenterY) {
	      return [arcIntersections[0], arcIntersections[1]];
	    }
	  }
	
	  // Bottom Right
	  {
	    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
	    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
	    arcIntersections = this.intersectLineCircle(
	      x, y, nodeX, nodeY,
	      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
	
	    // Ensure the intersection is on the desired quarter of the circle
	    if (arcIntersections.length > 0
	      && arcIntersections[0] >= bottomRightCenterX
	      && arcIntersections[1] >= bottomRightCenterY) {
	      return [arcIntersections[0], arcIntersections[1]];
	    }
	  }
	
	  // Bottom Left
	  {
	    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
	    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
	    arcIntersections = this.intersectLineCircle(
	      x, y, nodeX, nodeY,
	      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
	
	    // Ensure the intersection is on the desired quarter of the circle
	    if (arcIntersections.length > 0
	      && arcIntersections[0] <= bottomLeftCenterX
	      && arcIntersections[1] >= bottomLeftCenterY) {
	      return [arcIntersections[0], arcIntersections[1]];
	    }
	  }
	
	  return []; // if nothing
	};
	
	math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
	  var t = tolerance;
	
	  var x1 = Math.min(lx1, lx2);
	  var x2 = Math.max(lx1, lx2);
	  var y1 = Math.min(ly1, ly2);
	  var y2 = Math.max(ly1, ly2);
	
	  return x1 - t <= x && x <= x2 + t
	    && y1 - t <= y && y <= y2 + t;
	};
	
	math.inBezierVicinity = function(
	  x, y, x1, y1, x2, y2, x3, y3, tolerance) {
	
	  var bb = {
	    x1: Math.min( x1, x3, x2 ) - tolerance,
	    x2: Math.max( x1, x3, x2 ) + tolerance,
	    y1: Math.min( y1, y3, y2 ) - tolerance,
	    y2: Math.max( y1, y3, y2 ) + tolerance
	  };
	
	  // if outside the rough bounding box for the bezier, then it can't be a hit
	  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
	    // console.log('bezier out of rough bb')
	    return false;
	  } else {
	    // console.log('do more expensive check');
	    return true;
	  }
	
	};
	
	math.solveCubic = function(a, b, c, d, result) {
	
	  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
	  // r is the real component, i is the imaginary component
	
	  // An implementation of the Cardano method from the year 1545
	  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
	
	  b /= a;
	  c /= a;
	  d /= a;
	
	  var discriminant, q, r, dum1, s, t, term1, r13;
	
	  q = (3.0 * c - (b * b)) / 9.0;
	  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
	  r /= 54.0;
	
	  discriminant = q * q * q + r * r;
	  result[1] = 0;
	  term1 = (b / 3.0);
	
	  if (discriminant > 0) {
	    s = r + Math.sqrt(discriminant);
	    s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
	    t = r - Math.sqrt(discriminant);
	    t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
	    result[0] = -term1 + s + t;
	    term1 += (s + t) / 2.0;
	    result[4] = result[2] = -term1;
	    term1 = Math.sqrt(3.0) * (-t + s) / 2;
	    result[3] = term1;
	    result[5] = -term1;
	    return;
	  }
	
	  result[5] = result[3] = 0;
	
	  if (discriminant === 0) {
	    r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
	    result[0] = -term1 + 2.0 * r13;
	    result[4] = result[2] = -(r13 + term1);
	    return;
	  }
	
	  q = -q;
	  dum1 = q * q * q;
	  dum1 = Math.acos(r / Math.sqrt(dum1));
	  r13 = 2.0 * Math.sqrt(q);
	  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
	  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
	  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
	
	  return;
	};
	
	math.sqDistanceToQuadraticBezier = function(
	  x, y, x1, y1, x2, y2, x3, y3) {
	
	  // Find minimum distance by using the minimum of the distance
	  // function between the given point and the curve
	
	  // This gives the coefficients of the resulting cubic equation
	  // whose roots tell us where a possible minimum is
	  // (Coefficients are divided by 4)
	
	  var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
	    + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
	
	  var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
	    + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
	
	  var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
	    + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
	
	  var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
	    + y1*y2 - y1*y1 + y1*y - y2*y;
	
	  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
	
	  var roots = [];
	
	  // Use the cubic solving algorithm
	  this.solveCubic(a, b, c, d, roots);
	
	  var zeroThreshold = 0.0000001;
	
	  var params = [];
	
	  for (var index = 0; index < 6; index += 2) {
	    if (Math.abs(roots[index + 1]) < zeroThreshold
	        && roots[index] >= 0
	        && roots[index] <= 1.0) {
	      params.push(roots[index]);
	    }
	  }
	
	  params.push(1.0);
	  params.push(0.0);
	
	  var minDistanceSquared = -1;
	  var closestParam;
	
	  var curX, curY, distSquared;
	  for (var i = 0; i < params.length; i++) {
	    curX = Math.pow(1.0 - params[i], 2.0) * x1
	      + 2.0 * (1 - params[i]) * params[i] * x2
	      + params[i] * params[i] * x3;
	
	    curY = Math.pow(1 - params[i], 2.0) * y1
	      + 2 * (1.0 - params[i]) * params[i] * y2
	      + params[i] * params[i] * y3;
	
	    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
	    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
	    if (minDistanceSquared >= 0) {
	      if (distSquared < minDistanceSquared) {
	        minDistanceSquared = distSquared;
	        closestParam = params[i];
	      }
	    } else {
	      minDistanceSquared = distSquared;
	      closestParam = params[i];
	    }
	  }
	
	  return minDistanceSquared;
	};
	
	math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
	  var offset = [x - x1, y - y1];
	  var line = [x2 - x1, y2 - y1];
	
	  var lineSq = line[0] * line[0] + line[1] * line[1];
	  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
	
	  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
	  var adjSq = dotProduct * dotProduct / lineSq;
	
	  if (dotProduct < 0) {
	    return hypSq;
	  }
	
	  if (adjSq > lineSq) {
	    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
	  }
	
	  return hypSq - adjSq;
	};
	
	math.pointInsidePolygonPoints = function(x, y, points){
	  var x1, y1, x2, y2;
	  var y3;
	
	  // Intersect with vertical line through (x, y)
	  var up = 0;
	  var down = 0;
	  for (var i = 0; i < points.length / 2; i++) {
	
	    x1 = points[i * 2];
	    y1 = points[i * 2 + 1];
	
	    if (i + 1 < points.length / 2) {
	      x2 = points[(i + 1) * 2];
	      y2 = points[(i + 1) * 2 + 1];
	    } else {
	      x2 = points[(i + 1 - points.length / 2) * 2];
	      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
	    }
	
	    if (x1 == x && x2 == x) {
	
	    } else if ((x1 >= x && x >= x2)
	      || (x1 <= x && x <= x2)) {
	
	      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
	
	      if (y3 > y) {
	        up++;
	      }
	
	      if (y3 < y) {
	        down++;
	      }
	
	    } else {
	      continue;
	    }
	
	  }
	
	  if (up % 2 === 0) {
	    return false;
	  } else {
	    return true;
	  }
	};
	
	math.pointInsidePolygon = function(
	  x, y, basePoints, centerX, centerY, width, height, direction, padding) {
	
	  //var direction = arguments[6];
	  var transformedPoints = new Array(basePoints.length);
	
	  // Gives negative angle
	  var angle;
	
	  if( direction[0] != null ){
	    angle = Math.atan(direction[1] / direction[0]);
	
	    if (direction[0] < 0) {
	      angle = angle + Math.PI / 2;
	    } else {
	      angle = -angle - Math.PI / 2;
	    }
	  } else {
	    angle = direction;
	  }
	
	  var cos = Math.cos(-angle);
	  var sin = Math.sin(-angle);
	
	  //    console.log("base: " + basePoints);
	  for (var i = 0; i < transformedPoints.length / 2; i++) {
	    transformedPoints[i * 2] =
	      width / 2 * (basePoints[i * 2] * cos
	        - basePoints[i * 2 + 1] * sin);
	
	    transformedPoints[i * 2 + 1] =
	      height / 2 * (basePoints[i * 2 + 1] * cos
	        + basePoints[i * 2] * sin);
	
	    transformedPoints[i * 2] += centerX;
	    transformedPoints[i * 2 + 1] += centerY;
	  }
	
	  var points;
	
	  if (padding > 0) {
	    var expandedLineSet = this.expandPolygon(
	      transformedPoints,
	      -padding);
	
	    points = this.joinLines(expandedLineSet);
	  } else {
	    points = transformedPoints;
	  }
	
	  return math.pointInsidePolygonPoints( x, y, points );
	};
	
	math.joinLines = function(lineSet) {
	
	  var vertices = new Array(lineSet.length / 2);
	
	  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
	  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
	
	  for (var i = 0; i < lineSet.length / 4; i++) {
	    currentLineStartX = lineSet[i * 4];
	    currentLineStartY = lineSet[i * 4 + 1];
	    currentLineEndX = lineSet[i * 4 + 2];
	    currentLineEndY = lineSet[i * 4 + 3];
	
	    if (i < lineSet.length / 4 - 1) {
	      nextLineStartX = lineSet[(i + 1) * 4];
	      nextLineStartY = lineSet[(i + 1) * 4 + 1];
	      nextLineEndX = lineSet[(i + 1) * 4 + 2];
	      nextLineEndY = lineSet[(i + 1) * 4 + 3];
	    } else {
	      nextLineStartX = lineSet[0];
	      nextLineStartY = lineSet[1];
	      nextLineEndX = lineSet[2];
	      nextLineEndY = lineSet[3];
	    }
	
	    var intersection = this.finiteLinesIntersect(
	      currentLineStartX, currentLineStartY,
	      currentLineEndX, currentLineEndY,
	      nextLineStartX, nextLineStartY,
	      nextLineEndX, nextLineEndY,
	      true);
	
	    vertices[i * 2] = intersection[0];
	    vertices[i * 2 + 1] = intersection[1];
	  }
	
	  return vertices;
	};
	
	math.expandPolygon = function(points, pad) {
	
	  var expandedLineSet = new Array(points.length * 2);
	
	  var currentPointX, currentPointY, nextPointX, nextPointY;
	
	  for (var i = 0; i < points.length / 2; i++) {
	    currentPointX = points[i * 2];
	    currentPointY = points[i * 2 + 1];
	
	    if (i < points.length / 2 - 1) {
	      nextPointX = points[(i + 1) * 2];
	      nextPointY = points[(i + 1) * 2 + 1];
	    } else {
	      nextPointX = points[0];
	      nextPointY = points[1];
	    }
	
	    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
	
	    // Assume CCW polygon winding
	
	    var offsetX = (nextPointY - currentPointY);
	    var offsetY = -(nextPointX - currentPointX);
	
	    // Normalize
	    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
	    var normalizedOffsetX = offsetX / offsetLength;
	    var normalizedOffsetY = offsetY / offsetLength;
	
	    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
	    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
	    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
	    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
	  }
	
	  return expandedLineSet;
	};
	
	math.intersectLineEllipse = function(
	  x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
	
	  var dispX = centerX - x;
	  var dispY = centerY - y;
	
	  dispX /= ellipseWradius;
	  dispY /= ellipseHradius;
	
	  var len = Math.sqrt(dispX * dispX + dispY * dispY);
	
	  var newLength = len - 1;
	
	  if (newLength < 0) {
	    return [];
	  }
	
	  var lenProportion = newLength / len;
	
	  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
	};
	
	// Returns intersections of increasing distance from line's start point
	math.intersectLineCircle = function(
	  x1, y1, x2, y2, centerX, centerY, radius) {
	
	  // Calculate d, direction vector of line
	  var d = [x2 - x1, y2 - y1]; // Direction vector of line
	  var c = [centerX, centerY]; // Center of circle
	  var f = [x1 - centerX, y1 - centerY];
	
	  var a = d[0] * d[0] + d[1] * d[1];
	  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
	  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
	
	  var discriminant = b*b-4*a*c;
	
	  if (discriminant < 0) {
	    return [];
	  }
	
	  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
	  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
	
	  var tMin = Math.min(t1, t2);
	  var tMax = Math.max(t1, t2);
	  var inRangeParams = [];
	
	  if (tMin >= 0 && tMin <= 1) {
	    inRangeParams.push(tMin);
	  }
	
	  if (tMax >= 0 && tMax <= 1) {
	    inRangeParams.push(tMax);
	  }
	
	  if (inRangeParams.length === 0) {
	    return [];
	  }
	
	  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
	  var nearIntersectionY = inRangeParams[0] * d[1] + y1;
	
	  if (inRangeParams.length > 1) {
	
	    if (inRangeParams[0] == inRangeParams[1]) {
	      return [nearIntersectionX, nearIntersectionY];
	    } else {
	
	      var farIntersectionX = inRangeParams[1] * d[0] + x1;
	      var farIntersectionY = inRangeParams[1] * d[1] + y1;
	
	      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
	    }
	
	  } else {
	    return [nearIntersectionX, nearIntersectionY];
	  }
	
	};
	
	math.findCircleNearPoint = function(centerX, centerY,
	  radius, farX, farY) {
	
	  var displacementX = farX - centerX;
	  var displacementY = farY - centerY;
	  var distance = Math.sqrt(displacementX * displacementX
	    + displacementY * displacementY);
	
	  var unitDisplacementX = displacementX / distance;
	  var unitDisplacementY = displacementY / distance;
	
	  return [centerX + unitDisplacementX * radius,
	    centerY + unitDisplacementY * radius];
	};
	
	math.findMaxSqDistanceToOrigin = function(points) {
	  var maxSqDistance = 0.000001;
	  var sqDistance;
	
	  for (var i = 0; i < points.length / 2; i++) {
	
	    sqDistance = points[i * 2] * points[i * 2]
	      + points[i * 2 + 1] * points[i * 2 + 1];
	
	    if (sqDistance > maxSqDistance) {
	      maxSqDistance = sqDistance;
	    }
	  }
	
	  return maxSqDistance;
	};
	
	math.finiteLinesIntersect = function(
	  x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
	
	  var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
	  var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
	  var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	
	  if (u_b !== 0) {
	    var ua = ua_t / u_b;
	    var ub = ub_t / u_b;
	
	    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
	      return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
	
	    } else {
	      if (!infiniteLines) {
	        return [];
	      } else {
	        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
	      }
	    }
	  } else {
	    if (ua_t === 0 || ub_t === 0) {
	
	      // Parallel, coincident lines. Check if overlap
	
	      // Check endpoint of second line
	      if ([x1, x2, x4].sort()[1] === x4) {
	        return [x4, y4];
	      }
	
	      // Check start point of second line
	      if ([x1, x2, x3].sort()[1] === x3) {
	        return [x3, y3];
	      }
	
	      // Endpoint of first line
	      if ([x3, x4, x2].sort()[1] === x2) {
	        return [x2, y2];
	      }
	
	      return [];
	    } else {
	
	      // Parallel, non-coincident
	      return [];
	    }
	  }
	};
	
	math.polygonIntersectLine = function(
	  x, y, basePoints, centerX, centerY, width, height, padding) {
	
	  var intersections = [];
	  var intersection;
	
	  var transformedPoints = new Array(basePoints.length);
	
	  for (var i = 0; i < transformedPoints.length / 2; i++) {
	    transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
	    transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
	  }
	
	  var points;
	
	  if (padding > 0) {
	    var expandedLineSet = math.expandPolygon(
	      transformedPoints,
	      -padding);
	
	    points = math.joinLines(expandedLineSet);
	  } else {
	    points = transformedPoints;
	  }
	  // var points = transformedPoints;
	
	  var currentX, currentY, nextX, nextY;
	
	  for (var i = 0; i < points.length / 2; i++) {
	
	    currentX = points[i * 2];
	    currentY = points[i * 2 + 1];
	
	    if (i < points.length / 2 - 1) {
	      nextX = points[(i + 1) * 2];
	      nextY = points[(i + 1) * 2 + 1];
	    } else {
	      nextX = points[0];
	      nextY = points[1];
	    }
	
	    intersection = this.finiteLinesIntersect(
	      x, y, centerX, centerY,
	      currentX, currentY,
	      nextX, nextY);
	
	    if (intersection.length !== 0) {
	      intersections.push(intersection[0], intersection[1]);
	    }
	  }
	
	  return intersections;
	};
	
	math.shortenIntersection = function(
	  intersection, offset, amount) {
	
	  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
	
	  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
	
	  var lenRatio = (length - amount) / length;
	
	  if (lenRatio < 0) {
	    lenRatio = 0.00001;
	  }
	
	  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
	};
	
	math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
	  var points = math.generateUnitNgonPoints(sides, rotationRadians);
	  points = math.fitPolygonToSquare(points);
	
	  return points;
	};
	
	math.fitPolygonToSquare = function(points){
	  var x, y;
	  var sides = points.length/2;
	  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	
	  for (var i = 0; i < sides; i++) {
	    x = points[2 * i];
	    y = points[2 * i + 1];
	
	    minX = Math.min( minX, x );
	    maxX = Math.max( maxX, x );
	    minY = Math.min( minY, y );
	    maxY = Math.max( maxY, y );
	  }
	
	  // stretch factors
	  var sx = 2 / (maxX - minX);
	  var sy = 2 / (maxY - minY);
	
	  for (var i = 0; i < sides; i++){
	    x = points[2 * i] = points[2 * i] * sx;
	    y = points[2 * i + 1] = points[2 * i + 1] * sy;
	
	    minX = Math.min( minX, x );
	    maxX = Math.max( maxX, x );
	    minY = Math.min( minY, y );
	    maxY = Math.max( maxY, y );
	  }
	
	  if( minY < -1 ){
	    for (var i = 0; i < sides; i++){
	      y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
	    }
	  }
	
	  return points;
	};
	
	math.generateUnitNgonPoints = function(sides, rotationRadians) {
	
	  var increment = 1.0 / sides * 2 * Math.PI;
	  var startAngle = sides % 2 === 0 ?
	    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
	    //    console.log(nodeShapes['square']);
	  startAngle += rotationRadians;
	
	  var points = new Array(sides * 2);
	
	  var currentAngle, x, y;
	  for (var i = 0; i < sides; i++) {
	    currentAngle = i * increment + startAngle;
	
	    x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
	    y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
	  }
	
	  return points;
	};
	
	math.getRoundRectangleRadius = function(width, height) {
	
	  // Set the default radius, unless half of width or height is smaller than default
	  return Math.min(width / 4, height / 4, 8);
	};
	
	module.exports = math;
	
	},{}],80:[function(_dereq_,module,exports){
	/*!
	Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
	Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
	Licensed under The MIT License (http://opensource.org/licenses/MIT)
	*/
	
	'use strict';
	
	/*  promise states [Promises/A+ 2.1]  */
	var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
	var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
	var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */
	
	/*  promise object constructor  */
	var api = function (executor) {
	  /*  optionally support non-constructor/plain-function call  */
	  if (!(this instanceof api))
	    return new api(executor);
	
	  /*  initialize object  */
	  this.id           = "Thenable/1.0.7";
	  this.state        = STATE_PENDING; /*  initial state  */
	  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
	  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
	  this.onFulfilled  = [];            /*  initial handlers  */
	  this.onRejected   = [];            /*  initial handlers  */
	
	  /*  provide optional information-hiding proxy  */
	  this.proxy = {
	    then: this.then.bind(this)
	  };
	
	  /*  support optional executor function  */
	  if (typeof executor === "function")
	    executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
	};
	
	/*  promise API methods  */
	api.prototype = {
	  /*  promise resolving methods  */
	  fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
	  reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },
	
	  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
	  then: function (onFulfilled, onRejected) {
	    var curr = this;
	    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
	    curr.onFulfilled.push(
	      resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
	    curr.onRejected.push(
	      resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
	    execute(curr);
	    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
	  }
	};
	
	/*  deliver an action  */
	var deliver = function (curr, state, name, value) {
	  if (curr.state === STATE_PENDING) {
	    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
	    curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
	    execute(curr);
	  }
	  return curr;
	};
	
	/*  execute all handlers  */
	var execute = function (curr) {
	  if (curr.state === STATE_FULFILLED)
	    execute_handlers(curr, "onFulfilled", curr.fulfillValue);
	  else if (curr.state === STATE_REJECTED)
	    execute_handlers(curr, "onRejected",  curr.rejectReason);
	};
	
	/*  execute particular set of handlers  */
	var execute_handlers = function (curr, name, value) {
	  /* global setImmediate: true */
	  /* global setTimeout: true */
	
	  /*  short-circuit processing  */
	  if (curr[name].length === 0)
	    return;
	
	  /*  iterate over all handlers, exactly once  */
	  var handlers = curr[name];
	  curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
	  var func = function () {
	    for (var i = 0; i < handlers.length; i++)
	      handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
	  };
	
	  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
	  if (typeof setImmediate === "function")
	    setImmediate(func);
	  else
	    setTimeout(func, 0);
	};
	
	/*  generate a resolver function  */
	var resolver = function (cb, next, method) {
	  return function (value) {
	    if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
	      next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
	    else {
	      var result;
	      try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
	      catch (e) {
	        next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
	        return;
	      }
	      resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
	    }
	  };
	};
	
	/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
	var resolve = function (promise, x) {
	  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
	  if (promise === x || promise.proxy === x) {
	    promise.reject(new TypeError("cannot resolve promise with itself"));
	    return;
	  }
	
	  /*  surgically check for a "then" method
	    (mainly to just call the "getter" of "then" only once)  */
	  var then;
	  if ((typeof x === "object" && x !== null) || typeof x === "function") {
	    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
	    catch (e) {
	      promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
	      return;
	    }
	  }
	
	  /*  handle own Thenables    [Promises/A+ 2.3.2]
	    and similar "thenables" [Promises/A+ 2.3.3]  */
	  if (typeof then === "function") {
	    var resolved = false;
	    try {
	      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
	      then.call(x,
	        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
	        function (y) {
	          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
	          if (y === x)                                 /*  [Promises/A+ 3.6]  */
	            promise.reject(new TypeError("circular thenable chain"));
	          else
	            resolve(promise, y);
	        },
	
	        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
	        function (r) {
	          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
	          promise.reject(r);
	        }
	      );
	    }
	    catch (e) {
	      if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
	        promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
	    }
	    return;
	  }
	
	  /*  handle other values  */
	  promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
	};
	
	// use native promises where possible
	var Promise = typeof Promise === 'undefined' ? api : Promise;
	
	// so we always have Promise.all()
	Promise.all = Promise.all || function( ps ){
	  return new Promise(function( resolveAll, rejectAll ){
	    var vals = new Array( ps.length );
	    var doneCount = 0;
	
	    var fulfill = function( i, val ){
	      vals[i] = val;
	      doneCount++;
	
	      if( doneCount === ps.length ){
	        resolveAll( vals );
	      }
	    };
	
	    for( var i = 0; i < ps.length; i++ ){
	      (function( i ){
	        var p = ps[i];
	        var isPromise = p.then != null;
	
	        if( isPromise ){
	          p.then(function( val ){
	            fulfill( i, val );
	          }, function( err ){
	            rejectAll( err );
	          });
	        } else {
	          var val = p;
	          fulfill( i, val );
	        }
	      })( i );
	    }
	
	  });
	};
	
	module.exports = Promise;
	
	},{}],81:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('./is');
	var util = _dereq_('./util');
	
	var Selector = function( onlyThisGroup, selector ){
	
	  if( !(this instanceof Selector) ){
	    return new Selector(onlyThisGroup, selector);
	  }
	
	  if( selector === undefined && onlyThisGroup !== undefined ){
	    selector = onlyThisGroup;
	    onlyThisGroup = undefined;
	  }
	
	  var self = this;
	
	  self._private = {
	    selectorText: null,
	    invalid: true
	  };
	
	  if( !selector || ( is.string(selector) && selector.match(/^\s*$/) ) ){
	
	    if( onlyThisGroup == null ){
	      // ignore
	      self.length = 0;
	    } else {
	      self[0] = newQuery();
	      self[0].group = onlyThisGroup;
	      self.length = 1;
	    }
	
	  } else if( is.elementOrCollection( selector ) ){
	    var collection = selector.collection();
	
	    self[0] = newQuery();
	    self[0].collection = collection;
	    self.length = 1;
	
	  } else if( is.fn( selector ) ) {
	    self[0] = newQuery();
	    self[0].filter = selector;
	    self.length = 1;
	
	  } else if( is.string( selector ) ){
	
	    // the current subject in the query
	    var currentSubject = null;
	
	    // storage for parsed queries
	    var newQuery = function(){
	      return {
	        classes: [],
	        colonSelectors: [],
	        data: [],
	        group: null,
	        ids: [],
	        meta: [],
	
	        // fake selectors
	        collection: null, // a collection to match against
	        filter: null, // filter function
	
	        // these are defined in the upward direction rather than down (e.g. child)
	        // because we need to go up in Selector.filter()
	        parent: null, // parent query obj
	        ancestor: null, // ancestor query obj
	        subject: null, // defines subject in compound query (subject query obj; points to self if subject)
	
	        // use these only when subject has been defined
	        child: null,
	        descendant: null
	      };
	    };
	
	    // tokens in the query language
	    var tokens = {
	      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
	      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
	      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
	      string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
	      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
	      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
	      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
	      descendant: '\\s+',
	      child: '\\s+>\\s+',
	      subject: '\\$'
	    };
	    tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
	    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
	    tokens.className = tokens.variable; // a class name (follows variable conventions)
	    tokens.id = tokens.variable; // an element id (follows variable conventions)
	
	    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
	    // so that values get compared properly in Selector.filter()
	    var cleanMetaChars = function(str){
	      return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
	        return $1;
	      });
	    };
	
	    // add @ variants to comparatorOp
	    var ops = tokens.comparatorOp.split('|');
	    for( var i = 0; i < ops.length; i++ ){
	      var op = ops[i];
	      tokens.comparatorOp += '|@' + op;
	    }
	
	    // add ! variants to comparatorOp
	    var ops = tokens.comparatorOp.split('|');
	    for( var i = 0; i < ops.length; i++ ){
	      var op = ops[i];
	
	      if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
	      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined
	
	      tokens.comparatorOp += '|\\!' + op;
	    }
	
	    // NOTE: add new expression syntax here to have it recognised by the parser;
	    // - a query contains all adjacent (i.e. no separator in between) expressions;
	    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
	    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
	    // - when you add something here, also add to Selector.toString()
	    var exprs = [
	      {
	        name: 'group',
	        query: true,
	        regex: '(node|edge|\\*)',
	        populate: function( group ){
	          this.group = group == "*" ? group : group + 's';
	        }
	      },
	
	      {
	        name: 'state',
	        query: true,
	        // NB: if one colon selector is a substring of another from its start, place the longer one first
	        // e.g. :foobar|:foo
	        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
	        populate: function( state ){
	          this.colonSelectors.push( state );
	        }
	      },
	
	      {
	        name: 'id',
	        query: true,
	        regex: '\\#('+ tokens.id +')',
	        populate: function( id ){
	          this.ids.push( cleanMetaChars(id) );
	        }
	      },
	
	      {
	        name: 'className',
	        query: true,
	        regex: '\\.('+ tokens.className +')',
	        populate: function( className ){
	          this.classes.push( cleanMetaChars(className) );
	        }
	      },
	
	      {
	        name: 'dataExists',
	        query: true,
	        regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
	        populate: function( variable ){
	          this.data.push({
	            field: cleanMetaChars(variable)
	          });
	        }
	      },
	
	      {
	        name: 'dataCompare',
	        query: true,
	        regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
	        populate: function( variable, comparatorOp, value ){
	          var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;
	
	          if( valueIsString ){
	            value = value.substring(1, value.length - 1);
	          } else {
	            value = parseFloat(value);
	          }
	
	          this.data.push({
	            field: cleanMetaChars(variable),
	            operator: comparatorOp,
	            value: value
	          });
	        }
	      },
	
	      {
	        name: 'dataBool',
	        query: true,
	        regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
	        populate: function( boolOp, variable ){
	          this.data.push({
	            field: cleanMetaChars(variable),
	            operator: boolOp
	          });
	        }
	      },
	
	      {
	        name: 'metaCompare',
	        query: true,
	        regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
	        populate: function( meta, comparatorOp, number ){
	          this.meta.push({
	            field: cleanMetaChars(meta),
	            operator: comparatorOp,
	            value: parseFloat(number)
	          });
	        }
	      },
	
	      {
	        name: 'nextQuery',
	        separator: true,
	        regex: tokens.separator,
	        populate: function(){
	          // go on to next query
	          self[++i] = newQuery();
	          currentSubject = null;
	        }
	      },
	
	      {
	        name: 'child',
	        separator: true,
	        regex: tokens.child,
	        populate: function(){
	          // this query is the parent of the following query
	          var childQuery = newQuery();
	          childQuery.parent = this;
	          childQuery.subject = currentSubject;
	
	          // we're now populating the child query with expressions that follow
	          self[i] = childQuery;
	        }
	      },
	
	      {
	        name: 'descendant',
	        separator: true,
	        regex: tokens.descendant,
	        populate: function(){
	          // this query is the ancestor of the following query
	          var descendantQuery = newQuery();
	          descendantQuery.ancestor = this;
	          descendantQuery.subject = currentSubject;
	
	          // we're now populating the descendant query with expressions that follow
	          self[i] = descendantQuery;
	        }
	      },
	
	      {
	        name: 'subject',
	        modifier: true,
	        regex: tokens.subject,
	        populate: function(){
	          if( currentSubject != null && this.subject != this ){
	            util.error('Redefinition of subject in selector `' + selector + '`');
	            return false;
	          }
	
	          currentSubject = this;
	          this.subject = this;
	        }
	
	      }
	    ];
	
	    self._private.selectorText = selector;
	    var remaining = selector;
	    var i = 0;
	
	    // of all the expressions, find the first match in the remaining text
	    var consumeExpr = function( expectation ){
	      var expr;
	      var match;
	      var name;
	
	      for( var j = 0; j < exprs.length; j++ ){
	        var e = exprs[j];
	        var n = e.name;
	
	        // ignore this expression if it doesn't meet the expectation function
	        if( is.fn( expectation ) && !expectation(n, e) ){ continue; }
	
	        var m = remaining.match(new RegExp( '^' + e.regex ));
	
	        if( m != null ){
	          match = m;
	          expr = e;
	          name = n;
	
	          var consumed = m[0];
	          remaining = remaining.substring( consumed.length );
	
	          break; // we've consumed one expr, so we can return now
	        }
	      }
	
	      return {
	        expr: expr,
	        match: match,
	        name: name
	      };
	    };
	
	    // consume all leading whitespace
	    var consumeWhitespace = function(){
	      var match = remaining.match(/^\s+/);
	
	      if( match ){
	        var consumed = match[0];
	        remaining = remaining.substring( consumed.length );
	      }
	    };
	
	    self[0] = newQuery(); // get started
	
	    consumeWhitespace(); // get rid of leading whitespace
	    for(;;){
	      var check = consumeExpr();
	
	      if( check.expr == null ){
	        util.error('The selector `'+ selector +'`is invalid');
	        return;
	      } else {
	        var args = [];
	        for(var j = 1; j < check.match.length; j++){
	          args.push( check.match[j] );
	        }
	
	        // let the token populate the selector object (i.e. in self[i])
	        var ret = check.expr.populate.apply( self[i], args );
	
	        if( ret === false ){ return; } // exit if population failed
	      }
	
	      // we're done when there's nothing left to parse
	      if( remaining.match(/^\s*$/) ){
	        break;
	      }
	    }
	
	    self.length = i + 1;
	
	    // adjust references for subject
	    for(var j = 0; j < self.length; j++){
	      var query = self[j];
	
	      if( query.subject != null ){
	        // go up the tree until we reach the subject
	        for(;;){
	          if( query.subject == query ){ break; } // done if subject is self
	
	          if( query.parent != null ){ // swap parent/child reference
	            var parent = query.parent;
	            var child = query;
	
	            child.parent = null;
	            parent.child = child;
	
	            query = parent; // go up the tree
	          } else if( query.ancestor != null ){ // swap ancestor/descendant
	            var ancestor = query.ancestor;
	            var descendant = query;
	
	            descendant.ancestor = null;
	            ancestor.descendant = descendant;
	
	            query = ancestor; // go up the tree
	          } else {
	            util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
	            break;
	          }
	        } // for
	
	        self[j] = query.subject; // subject should be the root query
	      } // if
	    } // for
	
	    // make sure for each query that the subject group matches the implicit group if any
	    if( onlyThisGroup != null ){
	      for(var j = 0; j < self.length; j++){
	        if( self[j].group != null && self[j].group != onlyThisGroup ){
	          util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
	          return;
	        }
	
	        self[j].group = onlyThisGroup; // set to implicit group
	      }
	    }
	
	  } else {
	    util.error('A selector must be created from a string; found ' + selector);
	    return;
	  }
	
	  self._private.invalid = false;
	
	};
	
	var selfn = Selector.prototype;
	
	selfn.size = function(){
	  return this.length;
	};
	
	selfn.eq = function(i){
	  return this[i];
	};
	
	var queryMatches = function(query, element){
	  // check group
	  if( query.group != null && query.group != '*' && query.group != element._private.group ){
	    return false;
	  }
	
	  var cy = element.cy();
	
	  // check colon selectors
	  var allColonSelectorsMatch = true;
	  for(var k = 0; k < query.colonSelectors.length; k++){
	    var sel = query.colonSelectors[k];
	
	    switch(sel){
	    case ':selected':
	      allColonSelectorsMatch = element.selected();
	      break;
	    case ':unselected':
	      allColonSelectorsMatch = !element.selected();
	      break;
	    case ':selectable':
	      allColonSelectorsMatch = element.selectable();
	      break;
	    case ':unselectable':
	      allColonSelectorsMatch = !element.selectable();
	      break;
	    case ':locked':
	      allColonSelectorsMatch = element.locked();
	      break;
	    case ':unlocked':
	      allColonSelectorsMatch = !element.locked();
	      break;
	    case ':visible':
	      allColonSelectorsMatch = element.visible();
	      break;
	    case ':hidden':
	      allColonSelectorsMatch = !element.visible();
	      break;
	    case ':transparent':
	      allColonSelectorsMatch = element.transparent();
	      break;
	    case ':grabbed':
	      allColonSelectorsMatch = element.grabbed();
	      break;
	    case ':free':
	      allColonSelectorsMatch = !element.grabbed();
	      break;
	    case ':removed':
	      allColonSelectorsMatch = element.removed();
	      break;
	    case ':inside':
	      allColonSelectorsMatch = !element.removed();
	      break;
	    case ':grabbable':
	      allColonSelectorsMatch = element.grabbable();
	      break;
	    case ':ungrabbable':
	      allColonSelectorsMatch = !element.grabbable();
	      break;
	    case ':animated':
	      allColonSelectorsMatch = element.animated();
	      break;
	    case ':unanimated':
	      allColonSelectorsMatch = !element.animated();
	      break;
	    case ':parent':
	      allColonSelectorsMatch = element.isNode() && element.children().nonempty();
	      break;
	    case ':child':
	    case ':nonorphan':
	      allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
	      break;
	    case ':orphan':
	      allColonSelectorsMatch = element.isNode() && element.parent().empty();
	      break;
	    case ':loop':
	      allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
	      break;
	    case ':simple':
	      allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
	      break;
	    case ':active':
	      allColonSelectorsMatch = element.active();
	      break;
	    case ':inactive':
	      allColonSelectorsMatch = !element.active();
	      break;
	    case ':touch':
	      allColonSelectorsMatch = is.touch();
	      break;
	    case ':backgrounding':
	      allColonSelectorsMatch = element.backgrounding();
	      break;
	    case ':nonbackgrounding':
	      allColonSelectorsMatch = !element.backgrounding();
	      break;
	    }
	
	    if( !allColonSelectorsMatch ) break;
	  }
	  if( !allColonSelectorsMatch ) return false;
	
	  // check id
	  var allIdsMatch = true;
	  for(var k = 0; k < query.ids.length; k++){
	    var id = query.ids[k];
	    var actualId = element._private.data.id;
	
	    allIdsMatch = allIdsMatch && (id == actualId);
	
	    if( !allIdsMatch ) break;
	  }
	  if( !allIdsMatch ) return false;
	
	  // check classes
	  var allClassesMatch = true;
	  for(var k = 0; k < query.classes.length; k++){
	    var cls = query.classes[k];
	
	    allClassesMatch = allClassesMatch && element.hasClass(cls);
	
	    if( !allClassesMatch ) break;
	  }
	  if( !allClassesMatch ) return false;
	
	  // generic checking for data/metadata
	  var operandsMatch = function(params){
	    var allDataMatches = true;
	    for(var k = 0; k < query[params.name].length; k++){
	      var data = query[params.name][k];
	      var operator = data.operator;
	      var value = data.value;
	      var field = data.field;
	      var matches;
	
	      if( operator != null && value != null ){
	
	        var fieldVal = params.fieldValue(field);
	        var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
	        var valStr = '' + value;
	
	        var caseInsensitive = false;
	        if( operator.indexOf('@') >= 0 ){
	          fieldStr = fieldStr.toLowerCase();
	          valStr = valStr.toLowerCase();
	
	          operator = operator.replace('@', '');
	          caseInsensitive = true;
	        }
	
	        var notExpr = false;
	        var handledNotExpr = false;
	        if( operator.indexOf('!') >= 0 ){
	          operator = operator.replace('!', '');
	          notExpr = true;
	        }
	
	        // if we're doing a case insensitive comparison, then we're using a STRING comparison
	        // even if we're comparing numbers
	        if( caseInsensitive ){
	          value = valStr.toLowerCase();
	          fieldVal = fieldStr.toLowerCase();
	        }
	
	        switch(operator){
	        case '*=':
	          matches = fieldStr.search(valStr) >= 0;
	          break;
	        case '$=':
	          matches = new RegExp(valStr + '$').exec(fieldStr) != null;
	          break;
	        case '^=':
	          matches = new RegExp('^' + valStr).exec(fieldStr) != null;
	          break;
	        case '=':
	          matches = fieldVal === value;
	          break;
	        case '!=':
	          matches = fieldVal !== value;
	          break;
	        case '>':
	          matches = !notExpr ? fieldVal > value : fieldVal <= value;
	          handledNotExpr = true;
	          break;
	        case '>=':
	          matches = !notExpr ? fieldVal >= value : fieldVal < value;
	          handledNotExpr = true;
	          break;
	        case '<':
	          matches = !notExpr ? fieldVal < value : fieldVal >= value;
	          handledNotExpr = true;
	          break;
	        case '<=':
	          matches = !notExpr ? fieldVal <= value : fieldVal > value;
	          handledNotExpr = true;
	          break;
	        default:
	          matches = false;
	          break;
	
	        }
	      } else if( operator != null ){
	        switch(operator){
	        case '?':
	          matches = params.fieldTruthy(field);
	          break;
	        case '!':
	          matches = !params.fieldTruthy(field);
	          break;
	        case '^':
	          matches = params.fieldUndefined(field);
	          break;
	        }
	      } else {
	        matches = !params.fieldUndefined(field);
	      }
	
	      if( notExpr && !handledNotExpr ){
	        matches = !matches;
	        handledNotExpr = true;
	      }
	
	      if( !matches ){
	        allDataMatches = false;
	        break;
	      }
	    } // for
	
	    return allDataMatches;
	  }; // operandsMatch
	
	  // check data matches
	  var allDataMatches = operandsMatch({
	    name: 'data',
	    fieldValue: function(field){
	      return element._private.data[field];
	    },
	    fieldRef: function(field){
	      return 'element._private.data.' + field;
	    },
	    fieldUndefined: function(field){
	      return element._private.data[field] === undefined;
	    },
	    fieldTruthy: function(field){
	      if( element._private.data[field] ){
	        return true;
	      }
	      return false;
	    }
	  });
	
	  if( !allDataMatches ){
	    return false;
	  }
	
	  // check metadata matches
	  var allMetaMatches = operandsMatch({
	    name: 'meta',
	    fieldValue: function(field){
	      return element[field]();
	    },
	    fieldRef: function(field){
	      return 'element.' + field + '()';
	    },
	    fieldUndefined: function(field){
	      return element[field]() == null;
	    },
	    fieldTruthy: function(field){
	      if( element[field]() ){
	        return true;
	      }
	      return false;
	    }
	  });
	
	  if( !allMetaMatches ){
	    return false;
	  }
	
	  // check collection
	  if( query.collection != null ){
	    var matchesAny = query.collection._private.ids[ element.id() ] != null;
	
	    if( !matchesAny ){
	      return false;
	    }
	  }
	
	  // check filter function
	  if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
	    return false;
	  }
	
	
	  // check parent/child relations
	  var confirmRelations = function( query, elements ){
	    if( query != null ){
	      var matches = false;
	
	      if( !cy.hasCompoundNodes() ){
	        return false;
	      }
	
	      elements = elements(); // make elements functional so we save cycles if query == null
	
	      // query must match for at least one element (may be recursive)
	      for(var i = 0; i < elements.length; i++){
	        if( queryMatches( query, elements[i] ) ){
	          matches = true;
	          break;
	        }
	      }
	
	      return matches;
	    } else {
	      return true;
	    }
	  };
	
	  if (! confirmRelations(query.parent, function(){
	    return element.parent();
	  }) ){ return false; }
	
	  if (! confirmRelations(query.ancestor, function(){
	    return element.parents();
	  }) ){ return false; }
	
	  if (! confirmRelations(query.child, function(){
	    return element.children();
	  }) ){ return false; }
	
	  if (! confirmRelations(query.descendant, function(){
	    return element.descendants();
	  }) ){ return false; }
	
	  // we've reached the end, so we've matched everything for this query
	  return true;
	}; // queryMatches
	
	// filter an existing collection
	selfn.filter = function(collection){
	  var self = this;
	  var cy = collection.cy();
	
	  // don't bother trying if it's invalid
	  if( self._private.invalid ){
	    return cy.collection();
	  }
	
	  var selectorFunction = function(i, element){
	    for(var j = 0; j < self.length; j++){
	      var query = self[j];
	
	      if( queryMatches(query, element) ){
	        return true;
	      }
	    }
	
	    return false;
	  };
	
	  if( self._private.selectorText == null ){
	    selectorFunction = function(){ return true; };
	  }
	
	  var filteredCollection = collection.filter( selectorFunction );
	
	  return filteredCollection;
	}; // filter
	
	// does selector match a single element?
	selfn.matches = function(ele){
	  var self = this;
	
	  // don't bother trying if it's invalid
	  if( self._private.invalid ){
	    return false;
	  }
	
	  for(var j = 0; j < self.length; j++){
	    var query = self[j];
	
	    if( queryMatches(query, ele) ){
	      return true;
	    }
	  }
	
	  return false;
	}; // filter
	
	// ith query to string
	selfn.toString = selfn.selector = function(){
	
	  var str = '';
	
	  var clean = function(obj, isValue){
	    if( is.string(obj) ){
	      return isValue ? '"' + obj + '"' : obj;
	    }
	    return '';
	  };
	
	  var queryToString = function(query){
	    var str = '';
	
	    if( query.subject === query ){
	      str += '$';
	    }
	
	    var group = clean(query.group);
	    str += group.substring(0, group.length - 1);
	
	    for(var j = 0; j < query.data.length; j++){
	      var data = query.data[j];
	
	      if( data.value ){
	        str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
	      } else {
	        str += '[' + clean(data.operator) + data.field + ']';
	      }
	    }
	
	    for(var j = 0; j < query.meta.length; j++){
	      var meta = query.meta[j];
	      str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
	    }
	
	    for(var j = 0; j < query.colonSelectors.length; j++){
	      var sel = query.colonSelectors[i];
	      str += sel;
	    }
	
	    for(var j = 0; j < query.ids.length; j++){
	      var sel = '#' + query.ids[i];
	      str += sel;
	    }
	
	    for(var j = 0; j < query.classes.length; j++){
	      var sel = '.' + query.classes[j];
	      str += sel;
	    }
	
	    if( query.parent != null ){
	      str = queryToString( query.parent ) + ' > ' + str;
	    }
	
	    if( query.ancestor != null ){
	      str = queryToString( query.ancestor ) + ' ' + str;
	    }
	
	    if( query.child != null ){
	      str += ' > ' + queryToString( query.child );
	    }
	
	    if( query.descendant != null ){
	      str += ' ' + queryToString( query.descendant );
	    }
	
	    return str;
	  };
	
	  for(var i = 0; i < this.length; i++){
	    var query = this[i];
	
	    str += queryToString( query );
	
	    if( this.length > 1 && i < this.length - 1 ){
	      str += ', ';
	    }
	  }
	
	  return str;
	};
	
	module.exports = Selector;
	
	},{"./is":77,"./util":94}],82:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var styfn = {};
	
	// (potentially expensive calculation)
	// apply the style to the element based on
	// - its bypass
	// - what selectors match it
	styfn.apply = function( eles ){
	  var self = this;
	
	  if( self._private.newStyle ){ // clear style caches
	    this._private.contextStyles = {};
	    this._private.propDiffs = {};
	  }
	
	  for( var ie = 0; ie < eles.length; ie++ ){
	    var ele = eles[ie];
	    var cxtMeta = self.getContextMeta( ele );
	    var cxtStyle = self.getContextStyle( cxtMeta );
	    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );
	
	    self.updateTransitions( ele, app.diffProps );
	    self.updateStyleHints( ele );
	
	  } // for elements
	
	  self._private.newStyle = false;
	};
	
	styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
	  var self = this;
	  var cache = self._private.propDiffs = self._private.propDiffs || {};
	  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
	  var cachedVal = cache[dualCxtKey];
	
	  if( cachedVal ){
	    return cachedVal;
	  }
	
	  var diffProps = [];
	  var addedProp = {};
	
	  for( var i = 0; i < self.length; i++ ){
	    var cxt = self[i];
	    var oldHasCxt = oldCxtKey[i] === 't';
	    var newHasCxt = newCxtKey[i] === 't';
	    var cxtHasDiffed = oldHasCxt !== newHasCxt;
	    var cxtHasMappedProps = cxt.mappedProperties.length > 0;
	
	    if( cxtHasDiffed || cxtHasMappedProps ){
	      var props;
	
	      if( cxtHasDiffed && cxtHasMappedProps ){
	        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
	      } else if( cxtHasDiffed ){
	        props = cxt.properties; // need to check them all
	      } else if( cxtHasMappedProps ){
	        props = cxt.mappedProperties; // only need to check mapped
	      }
	
	      for( var j = 0; j < props.length; j++ ){
	        var prop = props[j];
	        var name = prop.name;
	
	        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
	        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
	        // is cached)
	        var laterCxtOverrides = false;
	        for( var k = i + 1; k < self.length; k++ ){
	          var laterCxt = self[k];
	          var hasLaterCxt = newCxtKey[k] === 't';
	
	          if( !hasLaterCxt ){ continue; } // can't override unless the context is active
	
	          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;
	
	          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
	        }
	
	        if( !addedProp[name] && !laterCxtOverrides ){
	          addedProp[name] = true;
	          diffProps.push( name );
	        }
	      } // for props
	    } // if
	
	  } // for contexts
	
	  cache[ dualCxtKey ] = diffProps;
	  return diffProps;
	};
	
	styfn.getContextMeta = function( ele ){
	  var self = this;
	  var cxtKey = '';
	  var diffProps;
	  var prevKey = ele._private.styleCxtKey || '';
	
	  if( self._private.newStyle ){
	    prevKey = ''; // since we need to apply all style if a fresh stylesheet
	  }
	
	  // get the cxt key
	  for( var i = 0; i < self.length; i++ ){
	    var context = self[i];
	    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'
	
	    if( contextSelectorMatches ){
	      cxtKey += 't';
	    } else {
	      cxtKey += 'f';
	    }
	  } // for context
	
	  diffProps = self.getPropertiesDiff( prevKey, cxtKey );
	
	  ele._private.styleCxtKey = cxtKey;
	
	  return {
	    key: cxtKey,
	    diffPropNames: diffProps
	  };
	};
	
	// gets a computed ele style object based on matched contexts
	styfn.getContextStyle = function( cxtMeta ){
	  var cxtKey = cxtMeta.key;
	  var self = this;
	  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};
	
	  // if already computed style, returned cached copy
	  if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }
	
	  var style = {
	    _private: {
	      key: cxtKey
	    }
	  };
	
	  for( var i = 0; i < self.length; i++ ){
	    var cxt = self[i];
	    var hasCxt = cxtKey[i] === 't';
	
	    if( !hasCxt ){ continue; }
	
	    for( var j = 0; j < cxt.properties.length; j++ ){
	      var prop = cxt.properties[j];
	      var styProp = style[ prop.name ] = prop;
	
	      styProp.context = cxt;
	    }
	  }
	
	  cxtStyles[cxtKey] = style;
	  return style;
	};
	
	styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
	  var self = this;
	  var diffProps = cxtMeta.diffPropNames;
	  var retDiffProps = {};
	
	  for( var i = 0; i < diffProps.length; i++ ){
	    var diffPropName = diffProps[i];
	    var cxtProp = cxtStyle[ diffPropName ];
	    var eleProp = ele._private.style[ diffPropName ];
	
	    // save cycles when the context prop doesn't need to be applied
	    if( !cxtProp || eleProp === cxtProp ){ continue; }
	
	    var retDiffProp = retDiffProps[ diffPropName ] = {
	      prev: eleProp
	    };
	
	    self.applyParsedProperty( ele, cxtProp );
	
	    retDiffProp.next = ele._private.style[ diffPropName ];
	
	    if( retDiffProp.next && retDiffProp.next.bypass ){
	      retDiffProp.next = retDiffProp.next.bypassed;
	    }
	  }
	
	  return {
	    diffProps: retDiffProps
	  };
	};
	
	styfn.updateStyleHints = function(ele){
	  var _p = ele._private;
	  var self = this;
	  var style = _p.style;
	
	  if( ele.removed() ){ return; }
	
	  // set whether has pie or not; for greater efficiency
	  var hasPie = false;
	  if( _p.group === 'nodes' && self._private.hasPie ){
	    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
	      var size = _p.style['pie-' + i + '-background-size'].value;
	
	      if( size > 0 ){
	        hasPie = true;
	        break;
	      }
	    }
	  }
	
	  _p.hasPie = hasPie;
	
	  var transform = style['text-transform'].strValue;
	  var content = style['label'].strValue;
	  var fStyle = style['font-style'].strValue;
	  var size = style['font-size'].pfValue + 'px';
	  var family = style['font-family'].strValue;
	  // var variant = style['font-variant'].strValue;
	  var weight = style['font-weight'].strValue;
	  var valign = style['text-valign'].strValue;
	  var halign = style['text-valign'].strValue;
	  var oWidth = style['text-outline-width'].pfValue;
	  var wrap = style['text-wrap'].strValue;
	  var wrapW = style['text-max-width'].pfValue;
	  _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
	  _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;
	
	  var width = style['width'].pfValue;
	  var height = style['height'].pfValue;
	  var borderW = style['border-width'].pfValue;
	  _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;
	
	  if( ele._private.group === 'edges' ){
	    var cpss = style['control-point-step-size'].pfValue;
	    var cpd = style['control-point-distances'] ? style['control-point-distances'].pfValue.join('_') : undefined;
	    var cpw = style['control-point-weights'].value.join('_');
	    var curve = style['curve-style'].strValue;
	    var sd = style['segment-distances'] ? style['segment-distances'].pfValue.join('_') : undefined;
	    var sw = style['segment-weights'].value.join('_');
	
	    _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ sd +'$'+ sw +'$'+ curve;
	  }
	
	  _p.styleKey = Date.now();
	};
	
	// apply a property to the style (for internal use)
	// returns whether application was successful
	//
	// now, this function flattens the property, and here's how:
	//
	// for parsedProp:{ bypass: true, deleteBypass: true }
	// no property is generated, instead the bypass property in the
	// element's style is replaced by what's pointed to by the `bypassed`
	// field in the bypass property (i.e. restoring the property the
	// bypass was overriding)
	//
	// for parsedProp:{ mapped: truthy }
	// the generated flattenedProp:{ mapping: prop }
	//
	// for parsedProp:{ bypass: true }
	// the generated flattenedProp:{ bypassed: parsedProp }
	styfn.applyParsedProperty = function( ele, parsedProp ){
	  var self = this;
	  var prop = parsedProp;
	  var style = ele._private.style;
	  var fieldVal, flatProp;
	  var types = self.types;
	  var type = self.properties[ prop.name ].type;
	  var propIsBypass = prop.bypass;
	  var origProp = style[ prop.name ];
	  var origPropIsBypass = origProp && origProp.bypass;
	  var _p = ele._private;
	
	  // can't apply auto to width or height unless it's a parent node
	  if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
	    if( parsedProp.value === 'auto' && !ele.isParent() ){
	      return false;
	    } else if( parsedProp.value !== 'auto' && ele.isParent() ){
	      prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
	    }
	  }
	
	  // check if we need to delete the current bypass
	  if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
	    var currentProp = style[ prop.name ];
	
	    // can only delete if the current prop is a bypass and it points to the property it was overriding
	    if( !currentProp ){
	      return true; // property is already not defined
	    } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original
	
	      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
	      style[ prop.name ] = currentProp.bypassed;
	      return true;
	
	    } else {
	      return false; // we're unsuccessful deleting the bypass
	    }
	  }
	
	  var printMappingErr = function(){
	    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
	  };
	
	  // put the property in the style objects
	  switch( prop.mapped ){ // flatten the property if mapped
	  case types.mapData:
	  case types.mapLayoutData:
	  case types.mapScratch:
	
	    var isLayout = prop.mapped === types.mapLayoutData;
	    var isScratch = prop.mapped === types.mapScratch;
	
	    // flatten the field (e.g. data.foo.bar)
	    var fields = prop.field.split(".");
	    var fieldVal;
	
	    if( isScratch || isLayout ){
	      fieldVal = _p.scratch;
	    } else {
	      fieldVal = _p.data;
	    }
	
	    for( var i = 0; i < fields.length && fieldVal; i++ ){
	      var field = fields[i];
	      fieldVal = fieldVal[ field ];
	    }
	
	    var percent;
	    if( !is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
	      percent = 0;
	    } else {
	      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
	    }
	
	    // make sure to bound percent value
	    if( percent < 0 ){
	      percent = 0;
	    } else if( percent > 1 ){
	      percent = 1;
	    }
	
	    if( type.color ){
	      var r1 = prop.valueMin[0];
	      var r2 = prop.valueMax[0];
	      var g1 = prop.valueMin[1];
	      var g2 = prop.valueMax[1];
	      var b1 = prop.valueMin[2];
	      var b2 = prop.valueMax[2];
	      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
	      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
	
	      var clr = [
	        Math.round( r1 + (r2 - r1)*percent ),
	        Math.round( g1 + (g2 - g1)*percent ),
	        Math.round( b1 + (b2 - b1)*percent ),
	        Math.round( a1 + (a2 - a1)*percent )
	      ];
	
	      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
	        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
	        name: prop.name,
	        value: clr,
	        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
	      };
	
	    } else if( type.number ){
	      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
	      flatProp = this.parse( prop.name, calcValue, prop.bypass, true );
	
	    } else {
	      return false; // can only map to colours and numbers
	    }
	
	    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
	      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
	    }
	
	    if( !flatProp ){ printMappingErr(); }
	    flatProp.mapping = prop; // keep a reference to the mapping
	    prop = flatProp; // the flattened (mapped) property is the one we want
	
	    break;
	
	  // direct mapping
	  case types.data:
	  case types.layoutData:
	  case types.scratch:
	    var isLayout = prop.mapped === types.layoutData;
	    var isScratch = prop.mapped === types.scratch;
	
	    // flatten the field (e.g. data.foo.bar)
	    var fields = prop.field.split(".");
	    var fieldVal;
	
	    if( isScratch || isLayout ){
	      fieldVal = _p.scratch;
	    } else {
	      fieldVal = _p.data;
	    }
	
	    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
	      var field = fields[i];
	      fieldVal = fieldVal[ field ];
	    } }
	
	    flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );
	
	    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
	      var flatPropVal = origProp ? origProp.strValue : '';
	
	      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
	    }
	
	    if( !flatProp ){ printMappingErr(); }
	    flatProp.mapping = prop; // keep a reference to the mapping
	    prop = flatProp; // the flattened (mapped) property is the one we want
	
	    break;
	
	  case types.fn:
	    var fn = prop.value;
	    var fnRetVal = fn( ele );
	
	    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
	    flatProp.mapping = prop; // keep a reference to the mapping
	    prop = flatProp; // the flattened (mapped) property is the one we want
	
	    break;
	
	  case undefined:
	    break; // just set the property
	
	  default:
	    return false; // not a valid mapping
	  }
	
	  // if the property is a bypass property, then link the resultant property to the original one
	  if( propIsBypass ){
	    if( origPropIsBypass ){ // then this bypass overrides the existing one
	      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
	    } else { // then link the orig prop to the new bypass
	      prop.bypassed = origProp;
	    }
	
	    style[ prop.name ] = prop; // and set
	
	  } else { // prop is not bypass
	    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
	      origProp.bypassed = prop;
	    } else { // then just replace the old prop with the new one
	      style[ prop.name ] = prop;
	    }
	  }
	
	  return true;
	};
	
	// updates the visual style for all elements (useful for manual style modification after init)
	styfn.update = function(){
	  var cy = this._private.cy;
	  var eles = cy.elements();
	
	  eles.updateStyle();
	};
	
	// just update the functional properties (i.e. mappings) in the elements'
	// styles (less expensive than recalculation)
	styfn.updateMappers = function( eles ){
	  var self = this;
	
	  for( var i = 0; i < eles.length; i++ ){ // for each ele
	    var ele = eles[i];
	    var style = ele._private.style;
	
	    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
	      var prop = self.properties[j];
	      var propInStyle = style[ prop.name ];
	
	      if( propInStyle && propInStyle.mapping ){
	        var mapping = propInStyle.mapping;
	        this.applyParsedProperty( ele, mapping ); // reapply the mapping property
	      }
	    }
	
	    this.updateStyleHints( ele );
	  }
	};
	
	// diffProps : { name => { prev, next } }
	styfn.updateTransitions = function( ele, diffProps, isBypass ){
	  var self = this;
	  var _p = ele._private;
	  var style = _p.style;
	  var props = style['transition-property'].value;
	  var duration = style['transition-duration'].pfValue;
	  var delay = style['transition-delay'].pfValue;
	  var css = {};
	
	  if( props.length > 0 && duration > 0 ){
	
	    // build up the style to animate towards
	    var anyPrev = false;
	    for( var i = 0; i < props.length; i++ ){
	      var prop = props[i];
	      var styProp = style[ prop ];
	      var diffProp = diffProps[ prop ];
	
	      if( !diffProp ){ continue; }
	
	      var prevProp = diffProp.prev;
	      var fromProp = prevProp;
	      var toProp = diffProp.next != null ? diffProp.next : styProp;
	      var diff = false;
	      var initVal;
	      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)
	
	      if( !fromProp ){ continue; }
	
	      // consider px values
	      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
	        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
	        initVal = fromProp.pfValue + initDt * diff;
	
	      // consider numerical values
	      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
	        diff = toProp.value - fromProp.value; // nonzero is truthy
	        initVal = fromProp.value + initDt * diff;
	
	      // consider colour values
	      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
	        diff = fromProp.value[0] !== toProp.value[0]
	          || fromProp.value[1] !== toProp.value[1]
	          || fromProp.value[2] !== toProp.value[2]
	        ;
	
	        initVal = fromProp.strValue;
	      }
	
	      // the previous value is good for an animation only if it's different
	      if( diff ){
	        css[ prop ] = toProp.strValue; // to val
	        this.applyBypass( ele, prop, initVal ); // from val
	        anyPrev = true;
	      }
	
	    } // end if props allow ani
	
	    // can't transition if there's nothing previous to transition from
	    if( !anyPrev ){ return; }
	
	    _p.transitioning = true;
	
	    ele.stop();
	
	    if( delay > 0 ){
	      ele.delay( delay );
	    }
	
	    ele.animate({
	      css: css
	    }, {
	      duration: duration,
	      easing: style['transition-timing-function'].value,
	      queue: false,
	      complete: function(){
	        if( !isBypass ){
	          self.removeBypasses( ele, props );
	        }
	
	        _p.transitioning = false;
	      }
	    });
	
	  } else if( _p.transitioning ){
	    ele.stop();
	
	    this.removeBypasses( ele, props );
	
	    _p.transitioning = false;
	  }
	};
	
	module.exports = styfn;
	
	},{"../is":77,"../util":94}],83:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var util = _dereq_('../util');
	
	var styfn = {};
	
	// bypasses are applied to an existing style on an element, and just tacked on temporarily
	// returns true iff application was successful for at least 1 specified property
	styfn.applyBypass = function( eles, name, value, updateTransitions ){
	  var self = this;
	  var props = [];
	  var isBypass = true;
	
	  // put all the properties (can specify one or many) in an array after parsing them
	  if( name === "*" || name === "**" ){ // apply to all property names
	
	    if( value !== undefined ){
	      for( var i = 0; i < self.properties.length; i++ ){
	        var prop = self.properties[i];
	        var name = prop.name;
	
	        var parsedProp = this.parse(name, value, true);
	
	        if( parsedProp ){
	          props.push( parsedProp );
	        }
	      }
	    }
	
	  } else if( is.string(name) ){ // then parse the single property
	    var parsedProp = this.parse(name, value, true);
	
	    if( parsedProp ){
	      props.push( parsedProp );
	    }
	  } else if( is.plainObject(name) ){ // then parse each property
	    var specifiedProps = name;
	    updateTransitions = value;
	
	    for( var i = 0; i < self.properties.length; i++ ){
	      var prop = self.properties[i];
	      var name = prop.name;
	      var value = specifiedProps[ name ];
	
	      if( value === undefined ){ // try camel case name too
	        value = specifiedProps[ util.dash2camel(name) ];
	      }
	
	      if( value !== undefined ){
	        var parsedProp = this.parse(name, value, true);
	
	        if( parsedProp ){
	          props.push( parsedProp );
	        }
	      }
	    }
	  } else { // can't do anything without well defined properties
	    return false;
	  }
	
	  // we've failed if there are no valid properties
	  if( props.length === 0 ){ return false; }
	
	  // now, apply the bypass properties on the elements
	  var ret = false; // return true if at least one succesful bypass applied
	  for( var i = 0; i < eles.length; i++ ){ // for each ele
	    var ele = eles[i];
	    var style = ele._private.style;
	    var diffProps = {};
	    var diffProp;
	
	    for( var j = 0; j < props.length; j++ ){ // for each prop
	      var prop = props[j];
	
	      if( updateTransitions ){
	        var prevProp = style[ prop.name ];
	        diffProp = diffProps[ prop.name ] = { prev: prevProp };
	      }
	
	      ret = this.applyParsedProperty( ele, prop ) || ret;
	
	      if( updateTransitions ){
	        diffProp.next = style[ prop.name ];
	      }
	
	    } // for props
	
	    if( ret ){
	      this.updateStyleHints( ele );
	    }
	
	    if( updateTransitions ){
	      this.updateTransitions( ele, diffProps, isBypass );
	    }
	  } // for eles
	
	  return ret;
	};
	
	// only useful in specific cases like animation
	styfn.overrideBypass = function( eles, name, value ){
	  name = util.camel2dash(name);
	
	  for( var i = 0; i < eles.length; i++ ){
	    var ele = eles[i];
	    var prop = ele._private.style[ name ];
	    var type = this.properties[ name ].type;
	    var isColor = type.color;
	    var isMulti = type.mutiple;
	
	    if( !prop.bypass ){ // need a bypass if one doesn't exist
	      this.applyBypass( ele, name, value );
	      continue;
	    }
	
	    prop.value = value;
	
	    if( prop.pfValue != null ){
	      prop.pfValue = value;
	    }
	
	    if( isColor ){
	      prop.strValue = 'rgb(' + value.join(',') + ')';
	    } else if( isMulti ){
	      prop.strValue = value.join(' ');
	    } else {
	      prop.strValue = '' + value;
	    }
	  }
	};
	
	styfn.removeAllBypasses = function( eles, updateTransitions ){
	  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
	};
	
	styfn.removeBypasses = function( eles, props, updateTransitions ){
	  var isBypass = true;
	
	  for( var j = 0; j < eles.length; j++ ){
	    var ele = eles[j];
	    var diffProps = {};
	    var style = ele._private.style;
	
	    for( var i = 0; i < props.length; i++ ){
	      var name = props[i];
	      var prop = this.properties[ name ];
	      var value = ''; // empty => remove bypass
	      var parsedProp = this.parse(name, value, true);
	      var prevProp = style[ prop.name ];
	      var diffProp = diffProps[ prop.name ] = { prev: prevProp };
	
	      this.applyParsedProperty(ele, parsedProp);
	
	      diffProp.next = style[ prop.name ];
	    } // for props
	
	    this.updateStyleHints( ele );
	
	    if( updateTransitions ){
	      this.updateTransitions( ele, diffProps, isBypass );
	    }
	  } // for eles
	};
	
	module.exports = styfn;
	
	},{"../is":77,"../util":94}],84:[function(_dereq_,module,exports){
	'use strict';
	
	var window = _dereq_('../window');
	
	var styfn = {};
	
	// gets what an em size corresponds to in pixels relative to a dom element
	styfn.getEmSizeInPixels = function(){
	  var px = this.containerCss('font-size');
	
	  if( px != null ){
	    return parseFloat( px );
	  } else {
	    return 1; // for headless
	  }
	};
	
	// gets css property from the core container
	styfn.containerCss = function( propName ){
	  var cy = this._private.cy;
	  var domElement = cy.container();
	
	  if( window && domElement && window.getComputedStyle ){
	    return window.getComputedStyle(domElement).getPropertyValue( propName );
	  }
	};
	
	module.exports = styfn;
	
	},{"../window":100}],85:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var styfn = {};
	
	// gets the rendered style for an element
	styfn.getRenderedStyle = function( ele ){
	  return this.getRawStyle( ele, true );
	};
	
	// gets the raw style for an element
	styfn.getRawStyle = function( ele, isRenderedVal ){
	  var self = this;
	  var ele = ele[0]; // insure it's an element
	
	  if( ele ){
	    var rstyle = {};
	
	    for( var i = 0; i < self.properties.length; i++ ){
	      var prop = self.properties[i];
	      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );
	
	      if( val ){
	        rstyle[ prop.name ] = val;
	        rstyle[ util.dash2camel(prop.name) ] = val;
	      }
	    }
	
	    return rstyle;
	  }
	};
	
	styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
	  var self = this;
	  var ele = ele[0]; // insure it's an element
	
	  if( ele ){
	    var style = ele._private.style;
	    var prop = self.properties[ propName ];
	    var type = prop.type;
	    var styleProp = style[ prop.name ];
	    var zoom = ele.cy().zoom();
	
	    if( styleProp ){
	      var units = styleProp.units ? type.implicitUnits || 'px' : null;
	      var val = units ? [].concat( styleProp.pfValue ).map(function( pfValue ){
	        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
	      }).join(' ') : styleProp.strValue;
	
	      return val;
	    }
	  }
	};
	
	// gets the value style for an element (useful for things like animations)
	styfn.getValueStyle = function( ele ){
	  var self = this;
	  var rstyle = {};
	  var style;
	  var isEle = is.element(ele);
	
	  if( isEle ){
	    style = ele._private.style;
	  } else {
	    style = ele; // just passed the style itself
	  }
	
	  if( style ){
	    for( var i = 0; i < self.properties.length; i++ ){
	      var prop = self.properties[i];
	      var styleProp = style[ prop.name ] || style[ util.dash2camel(prop.name) ];
	
	      if( styleProp !== undefined ){ // then make a prop of it
	        if( is.plainObject( styleProp ) ){
	          styleProp = this.parse( prop.name, styleProp.strValue );
	        } else {
	          styleProp = this.parse( prop.name, styleProp );
	        }
	      }
	
	      if( styleProp ){
	        rstyle[ prop.name ] = styleProp;
	        rstyle[ util.dash2camel(prop.name) ] = styleProp;
	      }
	    }
	  }
	
	  return rstyle;
	};
	
	styfn.getPropsList = function( propsObj ){
	  var self = this;
	  var rstyle = [];
	  var style = propsObj;
	  var props = self.properties;
	
	  if( style ){
	    for( var name in style ){
	      var val = style[name];
	      var prop = props[name] || props[ util.camel2dash(name) ];
	      var styleProp = this.parse( prop.name, val );
	
	      rstyle.push( styleProp );
	    }
	  }
	
	  return rstyle;
	};
	
	module.exports = styfn;
	
	},{"../is":77,"../util":94}],86:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var util = _dereq_('../util');
	var Selector = _dereq_('../selector');
	
	var Style = function( cy ){
	
	  if( !(this instanceof Style) ){
	    return new Style(cy);
	  }
	
	  if( !is.core(cy) ){
	    util.error('A style must have a core reference');
	    return;
	  }
	
	  this._private = {
	    cy: cy,
	    coreStyle: {},
	    newStyle: true
	  };
	
	  this.length = 0;
	
	  this.addDefaultStylesheet();
	};
	
	var styfn = Style.prototype;
	
	styfn.instanceString = function(){
	  return 'style';
	};
	
	// remove all contexts
	styfn.clear = function(){
	  for( var i = 0; i < this.length; i++ ){
	    this[i] = undefined;
	  }
	  this.length = 0;
	  this._private.newStyle = true;
	
	  return this; // chaining
	};
	
	styfn.resetToDefault = function(){
	  this.clear();
	  this.addDefaultStylesheet();
	
	  return this;
	};
	
	// builds a style object for the 'core' selector
	styfn.core = function(){
	  return this._private.coreStyle;
	};
	
	// create a new context from the specified selector string and switch to that context
	styfn.selector = function( selectorStr ){
	  // 'core' is a special case and does not need a selector
	  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );
	
	  var i = this.length++; // new context means new index
	  this[i] = {
	    selector: selector,
	    properties: [],
	    mappedProperties: [],
	    index: i
	  };
	
	  return this; // chaining
	};
	
	// add one or many css rules to the current context
	styfn.css = function(){
	  var self = this;
	  var args = arguments;
	
	  switch( args.length ){
	  case 1:
	    var map = args[0];
	
	    for( var i = 0; i < self.properties.length; i++ ){
	      var prop = self.properties[i];
	      var mapVal = map[ prop.name ];
	
	      if( mapVal === undefined ){
	        mapVal = map[ util.dash2camel(prop.name) ];
	      }
	
	      if( mapVal !== undefined ){
	        this.cssRule( prop.name, mapVal );
	      }
	    }
	
	    break;
	
	  case 2:
	    this.cssRule( args[0], args[1] );
	    break;
	
	  default:
	    break; // do nothing if args are invalid
	  }
	
	  return this; // chaining
	};
	styfn.style = styfn.css;
	
	// add a single css rule to the current context
	styfn.cssRule = function( name, value ){
	  // name-value pair
	  var property = this.parse( name, value );
	
	  // add property to current context if valid
	  if( property ){
	    var i = this.length - 1;
	    this[i].properties.push( property );
	    this[i].properties[ property.name ] = property; // allow access by name as well
	
	    if( property.name.match(/pie-(\d+)-background-size/) && property.value ){
	      this._private.hasPie = true;
	    }
	
	    if( property.mapped ){
	      this[i].mappedProperties.push( property );
	    }
	
	    // add to core style if necessary
	    var currentSelectorIsCore = !this[i].selector;
	    if( currentSelectorIsCore ){
	      this._private.coreStyle[ property.name ] = property;
	    }
	  }
	
	  return this; // chaining
	};
	
	// static function
	Style.fromJson = function( cy, json ){
	  var style = new Style( cy );
	
	  style.fromJson( json );
	
	  return style;
	};
	
	Style.fromString = function( cy, string ){
	  return new Style( cy ).fromString( string );
	};
	
	[
	  _dereq_('./apply'),
	  _dereq_('./bypass'),
	  _dereq_('./container'),
	  _dereq_('./get-for-ele'),
	  _dereq_('./json'),
	  _dereq_('./string-sheet'),
	  _dereq_('./properties'),
	  _dereq_('./parse')
	].forEach(function( props ){
	  util.extend( styfn, props );
	});
	
	
	Style.types = styfn.types;
	Style.properties = styfn.properties;
	
	module.exports = Style;
	
	},{"../is":77,"../selector":81,"../util":94,"./apply":82,"./bypass":83,"./container":84,"./get-for-ele":85,"./json":87,"./parse":88,"./properties":89,"./string-sheet":90}],87:[function(_dereq_,module,exports){
	'use strict';
	
	var styfn = {};
	
	styfn.applyFromJson = function( json ){
	  var style = this;
	
	  for( var i = 0; i < json.length; i++ ){
	    var context = json[i];
	    var selector = context.selector;
	    var props = context.style || context.css;
	
	    style.selector( selector ); // apply selector
	
	    for( var name in props ){
	      var value = props[name];
	
	      style.css( name, value ); // apply property
	    }
	  }
	
	  return style;
	};
	
	// accessible cy.style() function
	styfn.fromJson = function( json ){
	  var style = this;
	
	  style.resetToDefault();
	  style.applyFromJson( json );
	
	  return style;
	};
	
	// get json from cy.style() api
	styfn.json = function(){
	  var json = [];
	
	  for( var i = this.defaultLength; i < this.length; i++ ){
	    var cxt = this[i];
	    var selector = cxt.selector;
	    var props = cxt.properties;
	    var css = {};
	
	    for( var j = 0; j < props.length; j++ ){
	      var prop = props[j];
	      css[ prop.name ] = prop.strValue;
	    }
	
	    json.push({
	      selector: !selector ? 'core' : selector.toString(),
	      style: css
	    });
	  }
	
	  return json;
	};
	
	module.exports = styfn;
	
	},{}],88:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var is = _dereq_('../is');
	
	var styfn = {};
	
	// a caching layer for property parsing
	styfn.parse = function( name, value, propIsBypass, propIsFlat ){
	  var argHash = [ name, value, propIsBypass, propIsFlat ].join('$');
	  var propCache = this.propCache = this.propCache || {};
	  var ret;
	  var impl = parseImpl.bind( this );
	
	  if( !(ret = propCache[argHash]) ){
	    ret = propCache[argHash] = impl( name, value, propIsBypass, propIsFlat );
	  }
	
	  // always need a copy since props are mutated later in their lifecycles
	  ret = util.copy( ret );
	
	  if( ret ){
	    ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
	  }
	
	  return ret;
	};
	
	// parse a property; return null on invalid; return parsed property otherwise
	// fields :
	// - name : the name of the property
	// - value : the parsed, native-typed value of the property
	// - strValue : a string value that represents the property value in valid css
	// - bypass : true iff the property is a bypass property
	var parseImpl = function( name, value, propIsBypass, propIsFlat ){
	  var self = this;
	
	  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
	
	  var property = self.properties[ name ];
	  var passedValue = value;
	  var types = self.types;
	
	  if( !property ){ return null; } // return null on property of unknown name
	  if( value === undefined || value === null ){ return null; } // can't assign null
	
	  // the property may be an alias
	  if( property.alias ){
	    property = property.pointsTo;
	    name = property.name;
	  }
	
	  var valueIsString = is.string(value);
	  if( valueIsString ){ // trim the value to make parsing easier
	    value = value.trim();
	  }
	
	  var type = property.type;
	  if( !type ){ return null; } // no type, no luck
	
	  // check if bypass is null or empty string (i.e. indication to delete bypass property)
	  if( propIsBypass && (value === '' || value === null) ){
	    return {
	      name: name,
	      value: value,
	      bypass: true,
	      deleteBypass: true
	    };
	  }
	
	  // check if value is a function used as a mapper
	  if( is.fn(value) ){
	    return {
	      name: name,
	      value: value,
	      strValue: 'fn',
	      mapped: types.fn,
	      bypass: propIsBypass
	    };
	  }
	
	  // check if value is mapped
	  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
	  if( !valueIsString || propIsFlat ){
	    // then don't bother to do the expensive regex checks
	
	  } else if(
	    ( data = new RegExp( types.data.regex ).exec( value ) ) ||
	    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
	    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
	  ){
	    if( propIsBypass ){ return false; } // mappers not allowed in bypass
	
	    var mapped;
	    if( data ){
	      mapped = types.data;
	    } else if( layoutData ){
	      mapped = types.layoutData;
	    } else {
	      mapped = types.scratch;
	    }
	
	    data = data || layoutData || scratch;
	
	    return {
	      name: name,
	      value: data,
	      strValue: '' + value,
	      mapped: mapped,
	      field: data[1],
	      bypass: propIsBypass
	    };
	
	  } else if(
	    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
	    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
	    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
	  ){
	    if( propIsBypass ){ return false; } // mappers not allowed in bypass
	    if( type.multiple ){ return false; } // impossible to map to num
	
	    var mapped;
	    if( mapData ){
	      mapped = types.mapData;
	    } else if( mapLayoutData ){
	      mapped = types.mapLayoutData;
	    } else {
	      mapped = types.mapScratch;
	    }
	
	    mapData = mapData || mapLayoutData || mapScratch;
	
	    // we can map only if the type is a colour or a number
	    if( !(type.color || type.number) ){ return false; }
	
	    var valueMin = this.parse( name, mapData[4] ); // parse to validate
	    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped
	
	    var valueMax = this.parse( name, mapData[5] ); // parse to validate
	    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped
	
	    // check if valueMin and valueMax are the same
	    if( valueMin.value === valueMax.value ){
	      return false; // can't make much of a mapper without a range
	
	    } else if( type.color ){
	      var c1 = valueMin.value;
	      var c2 = valueMax.value;
	
	      var same = c1[0] === c2[0] // red
	        && c1[1] === c2[1] // green
	        && c1[2] === c2[2] // blue
	        && ( // optional alpha
	          c1[3] === c2[3] // same alpha outright
	          || (
	            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
	            &&
	            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
	          )
	        )
	      ;
	
	      if( same ){ return false; } // can't make a mapper without a range
	    }
	
	    return {
	      name: name,
	      value: mapData,
	      strValue: '' + value,
	      mapped: mapped,
	      field: mapData[1],
	      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
	      fieldMax: parseFloat( mapData[3] ),
	      valueMin: valueMin.value,
	      valueMax: valueMax.value,
	      bypass: propIsBypass
	    };
	  }
	
	  if( type.multiple && propIsFlat !== 'multiple' ){
	    var vals;
	
	    if( valueIsString ){
	      vals = value.split(/\s+/);
	    } else if( is.array(value) ){
	      vals = value;
	    } else {
	      vals = [ value ];
	    }
	
	    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }
	
	    var valArr = vals.map(function( v ){
	      var p = self.parse( name, v, propIsBypass, 'multiple' );
	
	      if( p.pfValue != null ){
	        return p.pfValue;
	      } else {
	        return p.value;
	      }
	    });
	
	    return {
	      name: name,
	      value: valArr,
	      pfValue: valArr,
	      strValue: valArr.join(' '),
	      bypass: propIsBypass,
	      units: type.number && !type.unitless ? type.implicitUnits || 'px' : undefined
	    };
	  }
	
	  // several types also allow enums
	  var checkEnums = function(){
	    for( var i = 0; i < type.enums.length; i++ ){
	      var en = type.enums[i];
	
	      if( en === value ){
	        return {
	          name: name,
	          value: value,
	          strValue: '' + value,
	          bypass: propIsBypass
	        };
	      }
	    }
	
	    return null;
	  };
	
	  // check the type and return the appropriate object
	  if( type.number ){
	    var units;
	    var implicitUnits = 'px'; // not set => px
	
	    if( type.units ){ // use specified units if set
	      units = type.units;
	    }
	
	    if( type.implicitUnits ){
	      implicitUnits = type.implicitUnits;
	    }
	
	    if( !type.unitless ){
	      if( valueIsString ){
	        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
	        if( units ){ unitsRegex = units; } // only allow explicit units if so set
	        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );
	
	        if( match ){
	          value = match[1];
	          units = match[2] || implicitUnits;
	        }
	
	      } else if( !units || type.implicitUnits ) {
	        units = implicitUnits; // implicitly px if unspecified
	      }
	    }
	
	    value = parseFloat( value );
	
	    // if not a number and enums not allowed, then the value is invalid
	    if( isNaN(value) && type.enums === undefined ){
	      return null;
	    }
	
	    // check if this number type also accepts special keywords in place of numbers
	    // (i.e. `left`, `auto`, etc)
	    if( isNaN(value) && type.enums !== undefined ){
	      value = passedValue;
	
	      return checkEnums();
	    }
	
	    // check if value must be an integer
	    if( type.integer && !is.integer(value) ){
	      return null;
	    }
	
	    // check value is within range
	    if( (type.min !== undefined && value < type.min)
	    || (type.max !== undefined && value > type.max)
	    ){
	      return null;
	    }
	
	    var ret = {
	      name: name,
	      value: value,
	      strValue: '' + value + (units ? units : ''),
	      units: units,
	      bypass: propIsBypass
	    };
	
	    // normalise value in pixels
	    if( type.unitless || (units !== 'px' && units !== 'em') ){
	      ret.pfValue = value;
	    } else {
	      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
	    }
	
	    // normalise value in ms
	    if( units === 'ms' || units === 's' ){
	      ret.pfValue = units === 'ms' ? value : 1000 * value;
	    }
	
	    // normalise value in rad
	    if( units === 'deg' || units === 'rad' ){
	      ret.pfValue = units === 'rad' ? value : value * Math.PI/180;
	    }
	
	    return ret;
	
	  } else if( type.propList ) {
	
	    var props = [];
	    var propsStr = '' + value;
	
	    if( propsStr === 'none' ){
	      // leave empty
	
	    } else { // go over each prop
	
	      var propsSplit = propsStr.split(',');
	      for( var i = 0; i < propsSplit.length; i++ ){
	        var propName = propsSplit[i].trim();
	
	        if( self.properties[propName] ){
	          props.push( propName );
	        }
	      }
	
	      if( props.length === 0 ){ return null; }
	    }
	
	    return {
	      name: name,
	      value: props,
	      strValue: props.length === 0 ? 'none' : props.join(', '),
	      bypass: propIsBypass
	    };
	
	  } else if( type.color ){
	    var tuple = util.color2tuple( value );
	
	    if( !tuple ){ return null; }
	
	    return {
	      name: name,
	      value: tuple,
	      strValue: '' + value,
	      bypass: propIsBypass,
	      roundValue: true
	    };
	
	  } else if( type.regex || type.regexes ){
	
	    // first check enums
	    if( type.enums ){
	      var enumProp = checkEnums();
	
	      if( enumProp ){ return enumProp; }
	    }
	
	    var regexes = type.regexes ? type.regexes : [ type.regex ];
	
	    for( var i = 0; i < regexes.length; i++ ){
	      var regex = new RegExp( regexes[i] ); // make a regex from the type string
	      var m = regex.exec( value );
	
	      if( m ){ // regex matches
	        return {
	          name: name,
	          value: m,
	          strValue: '' + value,
	          bypass: propIsBypass
	        };
	
	      }
	    }
	
	    return null; // didn't match any
	
	  } else if( type.string ){
	    // just return
	    return {
	      name: name,
	      value: value,
	      strValue: '' + value,
	      bypass: propIsBypass
	    };
	
	  } else if( type.enums ){ // check enums last because it's a combo type in others
	    return checkEnums();
	
	  } else {
	    return null; // not a type we can handle
	  }
	
	};
	
	module.exports = styfn;
	
	},{"../is":77,"../util":94}],89:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	
	var styfn = {};
	
	(function(){
	  var number = util.regex.number;
	  var rgba = util.regex.rgbaNoBackRefs;
	  var hsla = util.regex.hslaNoBackRefs;
	  var hex3 = util.regex.hex3;
	  var hex6 = util.regex.hex6;
	  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
	  var mapData = function( prefix ){
	    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
	    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
	  };
	
	  // each visual style property has a type and needs to be validated according to it
	  styfn.types = {
	    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
	    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
	    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
	    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
	    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
	    position: { enums: ['parent', 'origin'] },
	    nodeSize: { number: true, min: 0, enums: ['auto', 'label'] },
	    number: { number: true, unitless: true },
	    numbers: { number: true, unitless: true, multiple: true },
	    size: { number: true, min: 0 },
	    bidirectionalSize: { number: true }, // allows negative
	    bidirectionalSizes: { number: true, multiple: true }, // allows negative
	    bgSize: { number: true, min: 0, allowPercent: true },
	    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
	    bgPos: { number: true, allowPercent: true },
	    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
	    bgFit: { enums: ['none', 'contain', 'cover'] },
	    bgClip: { enums: ['none', 'node'] },
	    color: { color: true },
	    bool: { enums: ['yes', 'no'] },
	    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
	    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
	    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
	    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
	    fontVariant: { enums: ['small-caps', 'normal'] },
	    fontStyle: { enums: ['italic', 'normal', 'oblique'] },
	    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
	    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
	    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
	    textWrap: { enums: ['none', 'wrap'] },
	    textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
	    nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
	    compoundIncludeLabels: { enums: ['include', 'exclude'] },
	    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
	    arrowFill: { enums: ['filled', 'hollow'] },
	    display: { enums: ['element', 'none'] },
	    visibility: { enums: ['hidden', 'visible'] },
	    valign: { enums: ['top', 'center', 'bottom'] },
	    halign: { enums: ['left', 'center', 'right'] },
	    text: { string: true },
	    data: { mapping: true, regex: data('data') },
	    layoutData: { mapping: true, regex: data('layoutData') },
	    scratch: { mapping: true, regex: data('scratch') },
	    mapData: { mapping: true, regex: mapData('mapData') },
	    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
	    mapScratch: { mapping: true, regex: mapData('mapScratch') },
	    fn: { mapping: true, fn: true },
	    url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
	    propList: { propList: true },
	    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
	    textRotation: { enums: ['none', 'autorotate'] },
	    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
	    easing: {
	      regexes: [
	        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
	        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
	      ],
	      enums: [
	        'linear',
	        'ease', 'ease-in', 'ease-out', 'ease-in-out',
	        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
	        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
	        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
	        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
	        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
	        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
	        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
	      ]
	    }
	  };
	
	  // define visual style properties
	  var t = styfn.types;
	  var props = styfn.properties = [
	    // labels
	    { name: 'text-valign', type: t.valign },
	    { name: 'text-halign', type: t.halign },
	    { name: 'color', type: t.color },
	    { name: 'label', type: t.text },
	    { name: 'text-outline-color', type: t.color },
	    { name: 'text-outline-width', type: t.size },
	    { name: 'text-outline-opacity', type: t.zeroOneNumber },
	    { name: 'text-opacity', type: t.zeroOneNumber },
	    { name: 'text-background-color', type: t.color },
	    { name: 'text-background-opacity', type: t.zeroOneNumber },
	    { name: 'text-border-opacity', type: t.zeroOneNumber },
	    { name: 'text-border-color', type: t.color },
	    { name: 'text-border-width', type: t.size },
	    { name: 'text-border-style', type: t.borderStyle },
	    { name: 'text-background-shape', type: t.textBackgroundShape},
	    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
	    { name: 'text-transform', type: t.textTransform },
	    { name: 'text-wrap', type: t.textWrap },
	    { name: 'text-max-width', type: t.size },
	    { name: 'text-events', type: t.bool },
	
	    // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
	    { name: 'font-family', type: t.fontFamily },
	    { name: 'font-style', type: t.fontStyle },
	    // { name: 'font-variant', type: t.fontVariant }, // not useful
	    { name: 'font-weight', type: t.fontWeight },
	    { name: 'font-size', type: t.size },
	    { name: 'min-zoomed-font-size', type: t.size },
	    { name: 'edge-text-rotation', type: t.textRotation },
	
	    // behaviour
	    { name: 'events', type: t.bool },
	
	    // visibility
	    { name: 'display', type: t.display },
	    { name: 'visibility', type: t.visibility },
	    { name: 'opacity', type: t.zeroOneNumber },
	    { name: 'z-index', type: t.nonNegativeInt },
	
	    // overlays
	    { name: 'overlay-padding', type: t.size },
	    { name: 'overlay-color', type: t.color },
	    { name: 'overlay-opacity', type: t.zeroOneNumber },
	
	    // shadows
	    { name: 'shadow-blur', type: t.size },
	    { name: 'shadow-color', type: t.color },
	    { name: 'shadow-opacity', type: t.zeroOneNumber },
	    { name: 'shadow-offset-x', type: t.bidirectionalSize },
	    { name: 'shadow-offset-y', type: t.bidirectionalSize },
	
	    // label shadows
	    { name: 'text-shadow-blur', type: t.size },
	    { name: 'text-shadow-color', type: t.color },
	    { name: 'text-shadow-opacity', type: t.zeroOneNumber },
	    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },
	    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },
	
	    // transition anis
	    { name: 'transition-property', type: t.propList },
	    { name: 'transition-duration', type: t.time },
	    { name: 'transition-delay', type: t.time },
	    { name: 'transition-timing-function', type: t.easing },
	
	    // node body
	    { name: 'height', type: t.nodeSize },
	    { name: 'width', type: t.nodeSize },
	    { name: 'shape', type: t.nodeShape },
	    { name: 'shape-polygon-points', type: t.polygonPointList },
	    { name: 'background-color', type: t.color },
	    { name: 'background-opacity', type: t.zeroOneNumber },
	    { name: 'background-blacken', type: t.nOneOneNumber },
	    { name: 'padding-left', type: t.size },
	    { name: 'padding-right', type: t.size },
	    { name: 'padding-top', type: t.size },
	    { name: 'padding-bottom', type: t.size },
	
	    // node border
	    { name: 'border-color', type: t.color },
	    { name: 'border-opacity', type: t.zeroOneNumber },
	    { name: 'border-width', type: t.size },
	    { name: 'border-style', type: t.borderStyle },
	
	    // node background images
	    { name: 'background-image', type: t.url },
	    { name: 'background-image-opacity', type: t.zeroOneNumber },
	    { name: 'background-position-x', type: t.bgPos },
	    { name: 'background-position-y', type: t.bgPos },
	    { name: 'background-repeat', type: t.bgRepeat },
	    { name: 'background-fit', type: t.bgFit },
	    { name: 'background-clip', type: t.bgClip },
	    { name: 'background-width', type: t.bgWH },
	    { name: 'background-height', type: t.bgWH },
	
	    // compound props
	    { name: 'position', type: t.position },
	    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },
	
	    // edge line
	    { name: 'line-style', type: t.lineStyle },
	    { name: 'line-color', type: t.color },
	    { name: 'curve-style', type: t.curveStyle },
	    { name: 'haystack-radius', type: t.zeroOneNumber },
	    { name: 'control-point-step-size', type: t.size },
	    { name: 'control-point-distances', type: t.bidirectionalSizes },
	    { name: 'control-point-weights', type: t.numbers },
	    { name: 'segment-distances', type: t.bidirectionalSizes },
	    { name: 'segment-weights', type: t.numbers },
	
	    // these are just for the core
	    { name: 'selection-box-color', type: t.color },
	    { name: 'selection-box-opacity', type: t.zeroOneNumber },
	    { name: 'selection-box-border-color', type: t.color },
	    { name: 'selection-box-border-width', type: t.size },
	    { name: 'active-bg-color', type: t.color },
	    { name: 'active-bg-opacity', type: t.zeroOneNumber },
	    { name: 'active-bg-size', type: t.size },
	    { name: 'outside-texture-bg-color', type: t.color },
	    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
	  ];
	
	  // define aliases
	  var aliases = styfn.aliases = [
	    { name: 'content', pointsTo: 'label' },
	    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
	    { name: 'control-point-weight', pointsTo: 'control-point-weights' }
	  ];
	
	  // pie backgrounds for nodes
	  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
	  props.push({ name: 'pie-size', type: t.bgSize });
	  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
	    props.push({ name: 'pie-'+i+'-background-color', type: t.color });
	    props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
	    props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
	  }
	
	  // edge arrows
	  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
	  [
	    { name: 'arrow-shape', type: t.arrowShape },
	    { name: 'arrow-color', type: t.color },
	    { name: 'arrow-fill', type: t.arrowFill }
	  ].forEach(function( prop ){
	    arrowPrefixes.forEach(function( prefix ){
	      var name = prefix + '-' + prop.name;
	      var type = prop.type;
	
	      props.push({ name: name, type: type });
	    });
	  }, {});
	
	  // list of property names
	  styfn.propertyNames = props.map(function(p){ return p.name; });
	
	  // allow access of properties by name ( e.g. style.properties.height )
	  for( var i = 0; i < props.length; i++ ){
	    var prop = props[i];
	
	    props[ prop.name ] = prop; // allow lookup by name
	  }
	
	  // map aliases
	  for( var i = 0; i < aliases.length; i++ ){
	    var alias = aliases[i];
	    var pointsToProp = props[ alias.pointsTo ];
	    var aliasProp = {
	      name: alias.name,
	      alias: true,
	      pointsTo: pointsToProp
	    };
	
	    // add alias prop for parsing
	    props.push( aliasProp );
	
	    props[ alias.name ] = aliasProp; // allow lookup by name
	  }
	})();
	
	// adds the default stylesheet to the current style
	styfn.addDefaultStylesheet = function(){
	  // fill the style with the default stylesheet
	  this
	    .selector('node, edge') // common properties
	      .css( util.extend( {
	        'events': 'yes',
	        'text-events': 'no',
	        'text-valign': 'top',
	        'text-halign': 'center',
	        'color': '#000',
	        'text-outline-color': '#000',
	        'text-outline-width': 0,
	        'text-outline-opacity': 1,
	        'text-opacity': 1,
	        'text-decoration': 'none',
	        'text-transform': 'none',
	        'text-wrap': 'none',
	        'text-max-width': 9999,
	        'text-background-color': '#000',
	        'text-background-opacity': 0,
	        'text-border-opacity': 0,
	        'text-border-width': 0,
	        'text-border-style': 'solid',
	        'text-border-color':'#000',
	        'text-background-shape':'rectangle',
	        'font-family': 'Helvetica Neue, Helvetica, sans-serif',
	        'font-style': 'normal',
	        // 'font-variant': fontVariant,
	        'font-weight': 'normal',
	        'font-size': 16,
	        'min-zoomed-font-size': 0,
	        'edge-text-rotation': 'none',
	        'visibility': 'visible',
	        'display': 'element',
	        'opacity': 1,
	        'z-index': 0,
	        'label': '',
	        'overlay-opacity': 0,
	        'overlay-color': '#000',
	        'overlay-padding': 10,
	        'shadow-opacity': 0,
	        'shadow-color': '#000',
	        'shadow-blur': 10,
	        'shadow-offset-x': 0,
	        'shadow-offset-y': 0,
	        'text-shadow-opacity': 0,
	        'text-shadow-color': '#000',
	        'text-shadow-blur': 5,
	        'text-shadow-offset-x': 0,
	        'text-shadow-offset-y': 0,
	        'transition-property': 'none',
	        'transition-duration': 0,
	        'transition-delay': 0,
	        'transition-timing-function': 'linear',
	
	        // node props
	        'background-blacken': 0,
	        'background-color': '#888',
	        'background-opacity': 1,
	        'background-image': 'none',
	        'background-image-opacity': 1,
	        'background-position-x': '50%',
	        'background-position-y': '50%',
	        'background-repeat': 'no-repeat',
	        'background-fit': 'none',
	        'background-clip': 'node',
	        'background-width': 'auto',
	        'background-height': 'auto',
	        'border-color': '#000',
	        'border-opacity': 1,
	        'border-width': 0,
	        'border-style': 'solid',
	        'height': 30,
	        'width': 30,
	        'shape': 'ellipse',
	        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
	
	        // compound props
	        'padding-top': 0,
	        'padding-bottom': 0,
	        'padding-left': 0,
	        'padding-right': 0,
	        'position': 'origin',
	        'compound-sizing-wrt-labels': 'include'
	      }, {
	        // node pie bg
	        'pie-size': '100%'
	      }, [
	        { name: 'pie-{{i}}-background-color', value: 'black' },
	        { name: 'pie-{{i}}-background-size', value: '0%' },
	        { name: 'pie-{{i}}-background-opacity', value: 1 }
	      ].reduce(function( css, prop ){
	        for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
	          var name = prop.name.replace('{{i}}', i);
	          var val = prop.value;
	
	          css[ name ] = val;
	        }
	
	        return css;
	      }, {}), {
	        // edge props
	        'line-style': 'solid',
	        'line-color': '#ddd',
	        'control-point-step-size': 40,
	        'control-point-weights': 0.5,
	        'segment-weights': 0.5,
	        'segment-distances': 20,
	        'curve-style': 'bezier',
	        'haystack-radius': 0.8
	      }, [
	        { name: 'arrow-shape', value: 'none' },
	        { name: 'arrow-color', value: '#ddd' },
	        { name: 'arrow-fill', value: 'filled' }
	      ].reduce(function( css, prop ){
	        styfn.arrowPrefixes.forEach(function( prefix ){
	          var name = prefix + '-' + prop.name;
	          var val = prop.value;
	
	          css[ name ] = val;
	        });
	
	        return css;
	      }, {}) ) )
	    .selector('$node > node') // compound (parent) node properties
	      .css({
	        'width': 'auto',
	        'height': 'auto',
	        'shape': 'rectangle',
	        'padding-top': 10,
	        'padding-right': 10,
	        'padding-left': 10,
	        'padding-bottom': 10
	      })
	    .selector('edge') // just edge properties
	      .css({
	        'width': 1
	      })
	    .selector(':active')
	      .css({
	        'overlay-color': 'black',
	        'overlay-padding': 10,
	        'overlay-opacity': 0.25
	      })
	    .selector('core') // just core properties
	      .css({
	        'selection-box-color': '#ddd',
	        'selection-box-opacity': 0.65,
	        'selection-box-border-color': '#aaa',
	        'selection-box-border-width': 1,
	        'active-bg-color': 'black',
	        'active-bg-opacity': 0.15,
	        'active-bg-size': 30,
	        'outside-texture-bg-color': '#000',
	        'outside-texture-bg-opacity': 0.125
	      })
	  ;
	
	  this.defaultLength = this.length;
	};
	
	module.exports = styfn;
	
	},{"../util":94}],90:[function(_dereq_,module,exports){
	'use strict';
	
	var util = _dereq_('../util');
	var Selector = _dereq_('../selector');
	
	var styfn = {};
	
	styfn.applyFromString = function( string ){
	  var self = this;
	  var style = this;
	  var remaining = '' + string;
	  var selAndBlockStr;
	  var blockRem;
	  var propAndValStr;
	
	  // remove comments from the style string
	  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');
	
	  function removeSelAndBlockFromRemaining(){
	    // remove the parsed selector and block from the remaining text to parse
	    if( remaining.length > selAndBlockStr.length ){
	      remaining = remaining.substr( selAndBlockStr.length );
	    } else {
	      remaining = '';
	    }
	  }
	
	  function removePropAndValFromRem(){
	    // remove the parsed property and value from the remaining block text to parse
	    if( blockRem.length > propAndValStr.length ){
	      blockRem = blockRem.substr( propAndValStr.length );
	    } else {
	      blockRem = '';
	    }
	  }
	
	  while(true){
	    var nothingLeftToParse = remaining.match(/^\s*$/);
	    if( nothingLeftToParse ){ break; }
	
	    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
	
	    if( !selAndBlock ){
	      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
	      break;
	    }
	
	    selAndBlockStr = selAndBlock[0];
	
	    // parse the selector
	    var selectorStr = selAndBlock[1];
	    if( selectorStr !== 'core' ){
	      var selector = new Selector( selectorStr );
	      if( selector._private.invalid ){
	        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);
	
	        // skip this selector and block
	        removeSelAndBlockFromRemaining();
	        continue;
	      }
	    }
	
	    // parse the block of properties and values
	    var blockStr = selAndBlock[2];
	    var invalidBlock = false;
	    blockRem = blockStr;
	    var props = [];
	
	    while(true){
	      var nothingLeftToParse = blockRem.match(/^\s*$/);
	      if( nothingLeftToParse ){ break; }
	
	      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);
	
	      if( !propAndVal ){
	        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
	        invalidBlock = true;
	        break;
	      }
	
	      propAndValStr = propAndVal[0];
	      var propStr = propAndVal[1];
	      var valStr = propAndVal[2];
	
	      var prop = self.properties[ propStr ];
	      if( !prop ){
	        util.error('Skipping property: Invalid property name in: ' + propAndValStr);
	
	        // skip this property in the block
	        removePropAndValFromRem();
	        continue;
	      }
	
	      var parsedProp = style.parse( propStr, valStr );
	
	      if( !parsedProp ){
	        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);
	
	        // skip this property in the block
	        removePropAndValFromRem();
	        continue;
	      }
	
	      props.push({
	        name: propStr,
	        val: valStr
	      });
	      removePropAndValFromRem();
	    }
	
	    if( invalidBlock ){
	      removeSelAndBlockFromRemaining();
	      break;
	    }
	
	    // put the parsed block in the style
	    style.selector( selectorStr );
	    for( var i = 0; i < props.length; i++ ){
	      var prop = props[i];
	      style.css( prop.name, prop.val );
	    }
	
	    removeSelAndBlockFromRemaining();
	  }
	
	  return style;
	};
	
	styfn.fromString = function( string ){
	  var style = this;
	
	  style.resetToDefault();
	  style.applyFromString( string );
	
	  return style;
	};
	
	module.exports = styfn;
	
	},{"../selector":81,"../util":94}],91:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('./is');
	var util = _dereq_('./util');
	var Style = _dereq_('./style');
	
	// a dummy stylesheet object that doesn't need a reference to the core
	// (useful for init)
	var Stylesheet = function(){
	  if( !(this instanceof Stylesheet) ){
	    return new Stylesheet();
	  }
	
	  this.length = 0;
	};
	
	var sheetfn = Stylesheet.prototype;
	
	sheetfn.instanceString = function(){
	  return 'stylesheet';
	};
	
	// just store the selector to be parsed later
	sheetfn.selector = function( selector ){
	  var i = this.length++;
	
	  this[i] = {
	    selector: selector,
	    properties: []
	  };
	
	  return this; // chaining
	};
	
	// just store the property to be parsed later
	sheetfn.css = function( name, value ){
	  var i = this.length - 1;
	
	  if( is.string(name) ){
	    this[i].properties.push({
	      name: name,
	      value: value
	    });
	  } else if( is.plainObject(name) ){
	    var map = name;
	
	    for( var j = 0; j < Style.properties.length; j++ ){
	      var prop = Style.properties[j];
	      var mapVal = map[ prop.name ];
	
	      if( mapVal === undefined ){ // also try camel case name
	        mapVal = map[ util.dash2camel(prop.name) ];
	      }
	
	      if( mapVal !== undefined ){
	        var name = prop.name;
	        var value = mapVal;
	
	        this[i].properties.push({
	          name: name,
	          value: value
	        });
	      }
	    }
	  }
	
	  return this; // chaining
	};
	
	sheetfn.style = sheetfn.css;
	
	// generate a real style object from the dummy stylesheet
	sheetfn.generateStyle = function( cy ){
	  var style = new Style(cy);
	
	  for( var i = 0; i < this.length; i++ ){
	    var context = this[i];
	    var selector = context.selector;
	    var props = context.properties;
	
	    style.selector(selector); // apply selector
	
	    for( var j = 0; j < props.length; j++ ){
	      var prop = props[j];
	
	      style.css( prop.name, prop.value ); // apply property
	    }
	  }
	
	  return style;
	};
	
	module.exports = Stylesheet;
	
	},{"./is":77,"./style":86,"./util":94}],92:[function(_dereq_,module,exports){
	/*! Weaver licensed under MIT (https://tldrlegal.com/license/mit-license), copyright Max Franz */
	
	// cross-env thread/worker
	// NB : uses (heavyweight) processes on nodejs so best not to create too many threads
	
	'use strict';
	
	var window = _dereq_('./window');
	var util = _dereq_('./util');
	var Promise = _dereq_('./promise');
	var Event = _dereq_('./event');
	var define = _dereq_('./define');
	var is = _dereq_('./is');
	
	var Thread = function( opts ){
	  if( !(this instanceof Thread) ){
	    return new Thread( opts );
	  }
	
	  var _p = this._private = {
	    requires: [],
	    files: [],
	    queue: null,
	    pass: [],
	    disabled: false
	  };
	
	  if( is.plainObject(opts) ){
	    if( opts.disabled != null ){
	      _p.disabled = !!opts.disabled;
	    }
	  }
	
	};
	
	var thdfn = Thread.prototype; // short alias
	
	var stringifyFieldVal = function( val ){
	  var valStr = is.fn( val ) ? val.toString() : "JSON.parse('" + JSON.stringify(val) + "')";
	
	  return valStr;
	};
	
	// allows for requires with prototypes and subobjs etc
	var fnAsRequire = function( fn ){
	  var req;
	  var fnName;
	
	  if( is.object(fn) && fn.fn ){ // manual fn
	    req = fnAs( fn.fn, fn.name );
	    fnName = fn.name;
	    fn = fn.fn;
	  } else if( is.fn(fn) ){ // auto fn
	    req = fn.toString();
	    fnName = fn.name;
	  } else if( is.string(fn) ){ // stringified fn
	    req = fn;
	  } else if( is.object(fn) ){ // plain object
	    if( fn.proto ){
	      req = '';
	    } else {
	      req = fn.name + ' = {};';
	    }
	
	    fnName = fn.name;
	    fn = fn.obj;
	  }
	
	  req += '\n';
	
	  var protoreq = function( val, subname ){
	    if( val.prototype ){
	      var protoNonempty = false;
	      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line
	
	      if( protoNonempty ){
	        req += fnAsRequire( {
	          name: subname,
	          obj: val,
	          proto: true
	        }, val );
	      }
	    }
	  };
	
	  // pull in prototype
	  if( fn.prototype && fnName != null ){
	
	    for( var name in fn.prototype ){
	      var protoStr = '';
	
	      var val = fn.prototype[ name ];
	      var valStr = stringifyFieldVal( val );
	      var subname = fnName + '.prototype.' + name;
	
	      protoStr += subname + ' = ' + valStr + ';\n';
	
	      if( protoStr ){
	        req += protoStr;
	      }
	
	      protoreq( val, subname ); // subobject with prototype
	    }
	
	  }
	
	  // pull in properties for obj/fns
	  if( !is.string(fn) ){ for( var name in fn ){
	    var propsStr = '';
	
	    if( fn.hasOwnProperty(name) ){
	      var val = fn[ name ];
	      var valStr = stringifyFieldVal( val );
	      var subname = fnName + '["' + name + '"]';
	
	      propsStr += subname + ' = ' + valStr + ';\n';
	    }
	
	    if( propsStr ){
	      req += propsStr;
	    }
	
	    protoreq( val, subname ); // subobject with prototype
	  } }
	
	  return req;
	};
	
	var isPathStr = function( str ){
	  return is.string(str) && str.match(/\.js$/);
	};
	
	util.extend(thdfn, {
	
	  instanceString: function(){ return 'thread'; },
	
	  require: function( fn, as ){
	    var requires = this._private.requires;
	
	    if( isPathStr(fn) ){
	      this._private.files.push( fn );
	
	      return this;
	    }
	
	    if( as ){
	      if( is.fn(fn) ){
	        fn = { name: as, fn: fn };
	      } else {
	        fn = { name: as, obj: fn };
	      }
	    } else {
	      if( is.fn(fn) ){
	        if( !fn.name ){
	          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, "someFunction" )';
	        }
	
	        fn = { name: fn.name, fn: fn };
	      }
	    }
	
	    requires.push( fn );
	
	    return this; // chaining
	  },
	
	  pass: function( data ){
	    this._private.pass.push( data );
	
	    return this; // chaining
	  },
	
	  run: function( fn, pass ){ // fn used like main()
	    var self = this;
	    var _p = this._private;
	    pass = pass || _p.pass.shift();
	
	    if( _p.stopped ){
	      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';
	    }
	
	    if( _p.running ){
	      return ( _p.queue = _p.queue.then(function(){ // inductive step
	        return self.run( fn, pass );
	      }) );
	    }
	
	    var useWW = window != null && !_p.disabled;
	    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;
	
	    self.trigger('run');
	
	    var runP = new Promise(function( resolve, reject ){
	
	      _p.running = true;
	
	      var threadTechAlreadyExists = _p.ran;
	
	      var fnImplStr = is.string( fn ) ? fn : fn.toString();
	
	      // worker code to exec
	      var fnStr = '\n' + ( _p.requires.map(function( r ){
	        return fnAsRequire( r );
	      }) ).concat( _p.files.map(function( f ){
	        if( useWW ){
	          var wwifyFile = function( file ){
	            if( file.match(/^\.\//) || file.match(/^\.\./) ){
	              return window.location.origin + window.location.pathname + file;
	            } else if( file.match(/^\//) ){
	              return window.location.origin + '/' + file;
	            }
	            return file;
	          };
	
	          return 'importScripts("' + wwifyFile(f) + '");';
	        } else if( useNode ) {
	          return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
	        } else {
	          throw 'External file `' + f + '` can not be required without any threading technology.';
	        }
	      }) ).concat([
	        '( function(){',
	          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
	          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
	        '} )()\n'
	      ]).join('\n');
	
	      // because we've now consumed the requires, empty the list so we don't dupe on next run()
	      _p.requires = [];
	      _p.files = [];
	
	      if( useWW ){
	        var fnBlob, fnUrl;
	
	        // add normalised thread api functions
	        if( !threadTechAlreadyExists ){
	          var fnPre = fnStr + '';
	
	          fnStr = [
	            'function _ref_(o){ return eval(o); };',
	            'function broadcast(m){ return message(m); };', // alias
	            'function message(m){ postMessage(m); };',
	            'function listen(fn){',
	            '  self.addEventListener("message", function(m){ ',
	            '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
	            '    } else { ',
	            '      fn( m.data );',
	            '    }',
	            '  });',
	            '};',
	            'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
	            'function resolve(v){ postMessage({ $$resolve: v }); };',
	            'function reject(v){ postMessage({ $$reject: v }); };'
	          ].join('\n');
	
	          fnStr += fnPre;
	
	          fnBlob = new Blob([ fnStr ], {
	            type: 'application/javascript'
	          });
	          fnUrl = window.URL.createObjectURL( fnBlob );
	        }
	        // create webworker and let it exec the serialised code
	        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );
	
	        if( threadTechAlreadyExists ){ // then just exec new run() code
	          ww.postMessage({
	            $$eval: fnStr
	          });
	        }
	
	        // worker messages => events
	        var cb;
	        ww.addEventListener('message', cb = function( m ){
	          var isObject = is.object(m) && is.object( m.data );
	
	          if( isObject && ('$$resolve' in m.data) ){
	            ww.removeEventListener('message', cb); // done listening b/c resolve()
	
	            resolve( m.data.$$resolve );
	          } else if( isObject && ('$$reject' in m.data) ){
	            ww.removeEventListener('message', cb); // done listening b/c reject()
	
	            reject( m.data.$$reject );
	          } else {
	            self.trigger( new Event(m, { type: 'message', message: m.data }) );
	          }
	        }, false);
	
	        if( !threadTechAlreadyExists ){
	          ww.postMessage('$$start'); // start up the worker
	        }
	
	      } else if( useNode ){
	        // create a new process
	
	        if( !_p.child ){
	          _p.child = ( _dereq_('child_process').fork( _dereq_('path').join(__dirname, 'thread-node-fork') ) );
	        }
	
	        var child = _p.child;
	
	        // child process messages => events
	        var cb;
	        child.on('message', cb = function( m ){
	          if( is.object(m) && ('$$resolve' in m) ){
	            child.removeListener('message', cb); // done listening b/c resolve()
	
	            resolve( m.$$resolve );
	          } else if( is.object(m) && ('$$reject' in m) ){
	            child.removeListener('message', cb); // done listening b/c reject()
	
	            reject( m.$$reject );
	          } else {
	            self.trigger( new Event({}, { type: 'message', message: m }) );
	          }
	        });
	
	        // ask the child process to eval the worker code
	        child.send({
	          $$eval: fnStr
	        });
	
	      } else { // use a fallback mechanism using a timeout
	
	        var promiseResolve = resolve;
	        var promiseReject = reject;
	
	        var timer = _p.timer = _p.timer || {
	
	          listeners: [],
	
	          exec: function(){
	            // as a string so it can't be mangled by minifiers and processors
	            fnStr = [
	              'function _ref_(o){ return eval(o); };',
	              'function broadcast(m){ return message(m); };',
	              'function message(m){ self.trigger( new Event({}, { type: "message", message: m }) ); };',
	              'function listen(fn){ timer.listeners.push( fn ); };',
	              'function resolve(v){ promiseResolve(v); };',
	              'function reject(v){ promiseReject(v); };'
	            ].join('\n') + fnStr;
	
	            // the .run() code
	            eval( fnStr ); // jshint ignore:line
	          },
	
	          message: function( m ){
	            var ls = timer.listeners;
	
	            for( var i = 0; i < ls.length; i++ ){
	              var fn = ls[i];
	
	              fn( m );
	            }
	          }
	
	        };
	
	        timer.exec();
	      }
	
	    }).then(function( v ){
	      _p.running = false;
	      _p.ran = true;
	
	      self.trigger('ran');
	
	      return v;
	    });
	
	    if( _p.queue == null ){
	      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
	    }
	
	    return runP;
	  },
	
	  // send the thread a message
	  message: function( m ){
	    var _p = this._private;
	
	    if( _p.webworker ){
	      _p.webworker.postMessage( m );
	    }
	
	    if( _p.child ){
	      _p.child.send( m );
	    }
	
	    if( _p.timer ){
	      _p.timer.message( m );
	    }
	
	    return this; // chaining
	  },
	
	  stop: function(){
	    var _p = this._private;
	
	    if( _p.webworker ){
	      _p.webworker.terminate();
	    }
	
	    if( _p.child ){
	      _p.child.kill();
	    }
	
	    if( _p.timer ){
	      // nothing we can do if we've run a timeout
	    }
	
	    _p.stopped = true;
	
	    return this.trigger('stop'); // chaining
	  },
	
	  stopped: function(){
	    return this._private.stopped;
	  }
	
	});
	
	// turns a stringified function into a (re)named function
	var fnAs = function( fn, name ){
	  var fnStr = fn.toString();
	  fnStr = fnStr.replace(/function\s*?\S*?\s*?\(/, 'function ' + name + '(');
	
	  return fnStr;
	};
	
	var defineFnal = function( opts ){
	  opts = opts || {};
	
	  return function fnalImpl( fn, arg1 ){
	    var fnStr = fnAs( fn, '_$_$_' + opts.name );
	
	    this.require( fnStr );
	
	    return this.run( [
	      'function( data ){',
	      '  var origResolve = resolve;',
	      '  var res = [];',
	      '  ',
	      '  resolve = function( val ){',
	      '    res.push( val );',
	      '  };',
	      '  ',
	      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
	      '  ',
	      '  resolve = origResolve;',
	      '  resolve( res.length > 0 ? res : ret );',
	      '}'
	    ].join('\n') );
	  };
	};
	
	util.extend(thdfn, {
	  reduce: defineFnal({ name: 'reduce' }),
	
	  reduceRight: defineFnal({ name: 'reduceRight' }),
	
	  map: defineFnal({ name: 'map' })
	});
	
	// aliases
	var fn = thdfn;
	fn.promise = fn.run;
	fn.terminate = fn.halt = fn.stop;
	fn.include = fn.require;
	
	// pull in event apis
	util.extend(thdfn, {
	  on: define.on(),
	  one: define.on({ unbindSelfOnTrigger: true }),
	  off: define.off(),
	  trigger: define.trigger()
	});
	
	define.eventAliasesOn( thdfn );
	
	module.exports = Thread;
	
	},{"./define":41,"./event":42,"./is":77,"./promise":80,"./util":94,"./window":100,"child_process":undefined,"path":undefined}],93:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	
	module.exports = {
	  // get [r, g, b] from #abc or #aabbcc
	  hex2tuple: function( hex ){
	    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }
	
	    var shortHex = hex.length === 4;
	    var r, g, b;
	    var base = 16;
	
	    if( shortHex ){
	      r = parseInt( hex[1] + hex[1], base );
	      g = parseInt( hex[2] + hex[2], base );
	      b = parseInt( hex[3] + hex[3], base );
	    } else {
	      r = parseInt( hex[1] + hex[2], base );
	      g = parseInt( hex[3] + hex[4], base );
	      b = parseInt( hex[5] + hex[6], base );
	    }
	
	    return [r, g, b];
	  },
	
	  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
	  hsl2tuple: function( hsl ){
	    var ret;
	    var h, s, l, a, r, g, b;
	    function hue2rgb(p, q, t){
	      if(t < 0) t += 1;
	      if(t > 1) t -= 1;
	      if(t < 1/6) return p + (q - p) * 6 * t;
	      if(t < 1/2) return q;
	      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	      return p;
	    }
	
	    var m = new RegExp("^" + this.regex.hsla + "$").exec(hsl);
	    if( m ){
	
	      // get hue
	      h = parseInt( m[1] );
	      if( h < 0 ){
	        h = ( 360 - (-1*h % 360) ) % 360;
	      } else if( h > 360 ){
	        h = h % 360;
	      }
	      h /= 360; // normalise on [0, 1]
	
	      s = parseFloat( m[2] );
	      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
	      s = s/100; // normalise on [0, 1]
	
	      l = parseFloat( m[3] );
	      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
	      l = l/100; // normalise on [0, 1]
	
	      a = m[4];
	      if( a !== undefined ){
	        a = parseFloat( a );
	
	        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
	      }
	
	      // now, convert to rgb
	      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
	      if( s === 0 ){
	        r = g = b = Math.round(l * 255); // achromatic
	      } else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
	        g = Math.round( 255 * hue2rgb(p, q, h) );
	        b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
	      }
	
	      ret = [r, g, b, a];
	    }
	
	    return ret;
	  },
	
	  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
	  rgb2tuple: function( rgb ){
	    var ret;
	
	    var m = new RegExp("^" + this.regex.rgba + "$").exec(rgb);
	    if( m ){
	      ret = [];
	
	      var isPct = [];
	      for( var i = 1; i <= 3; i++ ){
	        var channel = m[i];
	
	        if( channel[ channel.length - 1 ] === "%" ){
	          isPct[i] = true;
	        }
	        channel = parseFloat( channel );
	
	        if( isPct[i] ){
	          channel = channel/100 * 255; // normalise to [0, 255]
	        }
	
	        if( channel < 0 || channel > 255 ){ return; } // invalid channel value
	
	        ret.push( Math.floor(channel) );
	      }
	
	      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
	      var allArePct = isPct[1] && isPct[2] && isPct[3];
	      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is
	
	      var alpha = m[4];
	      if( alpha !== undefined ){
	        alpha = parseFloat( alpha );
	
	        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value
	
	        ret.push( alpha );
	      }
	    }
	
	    return ret;
	  },
	
	  colorname2tuple: function( color ){
	    return this.colors[ color.toLowerCase() ];
	  },
	
	  color2tuple: function( color ){
	    return ( is.array(color) ? color : null )
	      || this.colorname2tuple(color)
	      || this.hex2tuple(color)
	      || this.rgb2tuple(color)
	      || this.hsl2tuple(color);
	  },
	
	  colors: {
	    // special colour names
	    transparent: [0, 0, 0, 0], // NB alpha === 0
	
	    // regular colours
	    aliceblue: [240, 248, 255],
	    antiquewhite: [250, 235, 215],
	    aqua: [0, 255, 255],
	    aquamarine: [127, 255, 212],
	    azure: [240, 255, 255],
	    beige: [245, 245, 220],
	    bisque: [255, 228, 196],
	    black: [0, 0, 0],
	    blanchedalmond: [255, 235, 205],
	    blue: [0, 0, 255],
	    blueviolet: [138, 43, 226],
	    brown: [165, 42, 42],
	    burlywood: [222, 184, 135],
	    cadetblue: [95, 158, 160],
	    chartreuse: [127, 255, 0],
	    chocolate: [210, 105, 30],
	    coral: [255, 127, 80],
	    cornflowerblue: [100, 149, 237],
	    cornsilk: [255, 248, 220],
	    crimson: [220, 20, 60],
	    cyan: [0, 255, 255],
	    darkblue: [0, 0, 139],
	    darkcyan: [0, 139, 139],
	    darkgoldenrod: [184, 134, 11],
	    darkgray: [169, 169, 169],
	    darkgreen: [0, 100, 0],
	    darkgrey: [169, 169, 169],
	    darkkhaki: [189, 183, 107],
	    darkmagenta: [139, 0, 139],
	    darkolivegreen: [85, 107, 47],
	    darkorange: [255, 140, 0],
	    darkorchid: [153, 50, 204],
	    darkred: [139, 0, 0],
	    darksalmon: [233, 150, 122],
	    darkseagreen: [143, 188, 143],
	    darkslateblue: [72, 61, 139],
	    darkslategray: [47, 79, 79],
	    darkslategrey: [47, 79, 79],
	    darkturquoise: [0, 206, 209],
	    darkviolet: [148, 0, 211],
	    deeppink: [255, 20, 147],
	    deepskyblue: [0, 191, 255],
	    dimgray: [105, 105, 105],
	    dimgrey: [105, 105, 105],
	    dodgerblue: [30, 144, 255],
	    firebrick: [178, 34, 34],
	    floralwhite: [255, 250, 240],
	    forestgreen: [34, 139, 34],
	    fuchsia: [255, 0, 255],
	    gainsboro: [220, 220, 220],
	    ghostwhite: [248, 248, 255],
	    gold: [255, 215, 0],
	    goldenrod: [218, 165, 32],
	    gray: [128, 128, 128],
	    grey: [128, 128, 128],
	    green: [0, 128, 0],
	    greenyellow: [173, 255, 47],
	    honeydew: [240, 255, 240],
	    hotpink: [255, 105, 180],
	    indianred: [205, 92, 92],
	    indigo: [75, 0, 130],
	    ivory: [255, 255, 240],
	    khaki: [240, 230, 140],
	    lavender: [230, 230, 250],
	    lavenderblush: [255, 240, 245],
	    lawngreen: [124, 252, 0],
	    lemonchiffon: [255, 250, 205],
	    lightblue: [173, 216, 230],
	    lightcoral: [240, 128, 128],
	    lightcyan: [224, 255, 255],
	    lightgoldenrodyellow: [250, 250, 210],
	    lightgray: [211, 211, 211],
	    lightgreen: [144, 238, 144],
	    lightgrey: [211, 211, 211],
	    lightpink: [255, 182, 193],
	    lightsalmon: [255, 160, 122],
	    lightseagreen: [32, 178, 170],
	    lightskyblue: [135, 206, 250],
	    lightslategray: [119, 136, 153],
	    lightslategrey: [119, 136, 153],
	    lightsteelblue: [176, 196, 222],
	    lightyellow: [255, 255, 224],
	    lime: [0, 255, 0],
	    limegreen: [50, 205, 50],
	    linen: [250, 240, 230],
	    magenta: [255, 0, 255],
	    maroon: [128, 0, 0],
	    mediumaquamarine: [102, 205, 170],
	    mediumblue: [0, 0, 205],
	    mediumorchid: [186, 85, 211],
	    mediumpurple: [147, 112, 219],
	    mediumseagreen: [60, 179, 113],
	    mediumslateblue: [123, 104, 238],
	    mediumspringgreen: [0, 250, 154],
	    mediumturquoise: [72, 209, 204],
	    mediumvioletred: [199, 21, 133],
	    midnightblue: [25, 25, 112],
	    mintcream: [245, 255, 250],
	    mistyrose: [255, 228, 225],
	    moccasin: [255, 228, 181],
	    navajowhite: [255, 222, 173],
	    navy: [0, 0, 128],
	    oldlace: [253, 245, 230],
	    olive: [128, 128, 0],
	    olivedrab: [107, 142, 35],
	    orange: [255, 165, 0],
	    orangered: [255, 69, 0],
	    orchid: [218, 112, 214],
	    palegoldenrod: [238, 232, 170],
	    palegreen: [152, 251, 152],
	    paleturquoise: [175, 238, 238],
	    palevioletred: [219, 112, 147],
	    papayawhip: [255, 239, 213],
	    peachpuff: [255, 218, 185],
	    peru: [205, 133, 63],
	    pink: [255, 192, 203],
	    plum: [221, 160, 221],
	    powderblue: [176, 224, 230],
	    purple: [128, 0, 128],
	    red: [255, 0, 0],
	    rosybrown: [188, 143, 143],
	    royalblue: [65, 105, 225],
	    saddlebrown: [139, 69, 19],
	    salmon: [250, 128, 114],
	    sandybrown: [244, 164, 96],
	    seagreen: [46, 139, 87],
	    seashell: [255, 245, 238],
	    sienna: [160, 82, 45],
	    silver: [192, 192, 192],
	    skyblue: [135, 206, 235],
	    slateblue: [106, 90, 205],
	    slategray: [112, 128, 144],
	    slategrey: [112, 128, 144],
	    snow: [255, 250, 250],
	    springgreen: [0, 255, 127],
	    steelblue: [70, 130, 180],
	    tan: [210, 180, 140],
	    teal: [0, 128, 128],
	    thistle: [216, 191, 216],
	    tomato: [255, 99, 71],
	    turquoise: [64, 224, 208],
	    violet: [238, 130, 238],
	    wheat: [245, 222, 179],
	    white: [255, 255, 255],
	    whitesmoke: [245, 245, 245],
	    yellow: [255, 255, 0],
	    yellowgreen: [154, 205, 50]
	  }
	};
	
	},{"../is":77}],94:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	var math = _dereq_('../math');
	
	var util = {
	
	  falsify: function(){ return false; },
	
	  zeroify: function(){ return 0; },
	
	  noop: function(){},
	
	  /* jshint ignore:start */
	  error: function( msg ){
	    if( console.error ){
	      console.error.apply( console, arguments );
	
	      if( console.trace ){ console.trace(); }
	    } else {
	      console.log.apply( console, arguments );
	
	      if( console.trace ){ console.trace(); }
	    }
	  },
	  /* jshint ignore:end */
	
	  clone: function( obj ){
	    return this.extend( {}, obj );
	  },
	
	  // gets a shallow copy of the argument
	  copy: function( obj ){
	    if( obj == null ){
	      return obj;
	    } if( is.array(obj) ){
	      return obj.slice();
	    } else if( is.plainObject(obj) ){
	      return this.clone( obj );
	    } else {
	      return obj;
	    }
	  }
	
	};
	
	util.makeBoundingBox = math.makeBoundingBox.bind( math );
	
	util._staticEmptyObject = {};
	
	util.staticEmptyObject = function(){
	  return util._staticEmptyObject;
	};
	
	util.extend = Object.assign != null ? Object.assign : function( tgt ){
	  var args = arguments;
	
	  for( var i = 1; i < args.length; i++ ){
	    var obj = args[i];
	
	    for( var k in obj ){
	      tgt[k] = obj[k];
	    }
	  }
	
	  return tgt;
	};
	
	[
	  _dereq_('./colors'),
	  _dereq_('./maps'),
	  { memoize: _dereq_('./memoize') },
	  _dereq_('./regex'),
	  _dereq_('./strings'),
	  _dereq_('./timing')
	].forEach(function( req ){
	  util.extend( util, req );
	});
	
	module.exports = util;
	
	},{"../is":77,"../math":79,"./colors":93,"./maps":95,"./memoize":96,"./regex":97,"./strings":98,"./timing":99}],95:[function(_dereq_,module,exports){
	'use strict';
	
	var is = _dereq_('../is');
	
	module.exports = {
	  // has anything been set in the map
	  mapEmpty: function( map ){
	    var empty = true;
	
	    if( map != null ){
	      for(var i in map){ // jshint ignore:line
	        empty = false;
	        break;
	      }
	    }
	
	    return empty;
	  },
	
	  // pushes to the array at the end of a map (map may not be built)
	  pushMap: function( options ){
	    var array = this.getMap(options);
	
	    if( array == null ){ // if empty, put initial array
	      this.setMap( this.extend({}, options, {
	        value: [ options.value ]
	      }) );
	    } else {
	      array.push( options.value );
	    }
	  },
	
	  // sets the value in a map (map may not be built)
	  setMap: function( options ){
	    var obj = options.map;
	    var key;
	    var keys = options.keys;
	    var l = keys.length;
	
	    for(var i = 0; i < l; i++){
	      var key = keys[i];
	
	      if( is.plainObject( key ) ){
	        this.error('Tried to set map with object key');
	      }
	
	      if( i < keys.length - 1 ){
	
	        // extend the map if necessary
	        if( obj[key] == null ){
	          obj[key] = {};
	        }
	
	        obj = obj[key];
	      } else {
	        // set the value
	        obj[key] = options.value;
	      }
	    }
	  },
	
	  // gets the value in a map even if it's not built in places
	  getMap: function( options ){
	    var obj = options.map;
	    var keys = options.keys;
	    var l = keys.length;
	
	    for(var i = 0; i < l; i++){
	      var key = keys[i];
	
	      if( is.plainObject( key ) ){
	        this.error('Tried to get map with object key');
	      }
	
	      obj = obj[key];
	
	      if( obj == null ){
	        return obj;
	      }
	    }
	
	    return obj;
	  },
	
	  // deletes the entry in the map
	  deleteMap: function( options ){
	    var obj = options.map;
	    var keys = options.keys;
	    var l = keys.length;
	    var keepChildren = options.keepChildren;
	
	    for(var i = 0; i < l; i++){
	      var key = keys[i];
	
	      if( is.plainObject( key ) ){
	        this.error('Tried to delete map with object key');
	      }
	
	      var lastKey = i === options.keys.length - 1;
	      if( lastKey ){
	
	        if( keepChildren ){ // then only delete child fields not in keepChildren
	          for( var child in obj ){
	            if( !keepChildren[child] ){
	              obj[child] = undefined;
	            }
	          }
	        } else {
	          obj[key] = undefined;
	        }
	
	      } else {
	        obj = obj[key];
	      }
	    }
	  }
	};
	
	},{"../is":77}],96:[function(_dereq_,module,exports){
	'use strict';
	
	module.exports = function memoize( fn, keyFn ){
	  var self = this;
	  var cache = {};
	
	  if( !keyFn ){
	    keyFn = function(){
	      if( arguments.length === 1 ){
	        return arguments[0];
	      }
	
	      var args = [];
	
	      for( var i = 0; i < arguments.length; i++ ){
	        args.push( arguments[i] );
	      }
	
	      return args.join('$');
	    };
	  }
	
	  return function memoizedFn(){
	    var args = arguments;
	    var ret;
	    var k = keyFn.apply( self, args );
	
	    if( !(ret = cache[k]) ){
	      ret = cache[k] = fn.apply( self, args );
	    }
	
	    return ret;
	  };
	};
	
	},{}],97:[function(_dereq_,module,exports){
	'use strict';
	
	var number = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";
	
	var rgba = "rgb[a]?\\(("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)(?:\\s*,\\s*("+ number +"))?\\)";
	var rgbaNoBackRefs = "rgb[a]?\\((?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)(?:\\s*,\\s*(?:"+ number +"))?\\)";
	
	var hsla = "hsl[a]?\\(("+ number +")\\s*,\\s*("+ number +"[%])\\s*,\\s*("+ number +"[%])(?:\\s*,\\s*("+ number +"))?\\)";
	var hslaNoBackRefs = "hsl[a]?\\((?:"+ number +")\\s*,\\s*(?:"+ number +"[%])\\s*,\\s*(?:"+ number +"[%])(?:\\s*,\\s*(?:"+ number +"))?\\)";
	
	var hex3 = "\\#[0-9a-fA-F]{3}";
	var hex6 = "\\#[0-9a-fA-F]{6}";
	
	module.exports = {
	  regex: {
	    number: number,
	    rgba: rgba,
	    rgbaNoBackRefs: rgbaNoBackRefs,
	    hsla: hsla,
	    hslaNoBackRefs: hslaNoBackRefs,
	    hex3: hex3,
	    hex6: hex6
	  }
	};
	
	},{}],98:[function(_dereq_,module,exports){
	'use strict';
	
	var memoize = _dereq_('./memoize');
	var is = _dereq_('../is');
	
	module.exports = {
	
	  camel2dash: memoize( function( str ){
	    return str.replace(/([A-Z])/g, function( v ){
	      return '-' + v.toLowerCase();
	    });
	  } ),
	
	  dash2camel: memoize( function( str ){
	    return str.replace(/(-\w)/g, function( v ){
	      return v[1].toUpperCase();
	    });
	  } ),
	
	  capitalize: function(str){
	    if( is.emptyString(str) ){
	      return str;
	    }
	
	    return str.charAt(0).toUpperCase() + str.substring(1);
	  }
	
	};
	
	},{"../is":77,"./memoize":96}],99:[function(_dereq_,module,exports){
	'use strict';
	
	var window = _dereq_('../window');
	var is = _dereq_('../is');
	var performance = window ? window.performance : null;
	
	var util = {};
	
	var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||
	      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );
	
	raf = raf || function( fn ){
	  if( fn ){
	    setTimeout(function(){
	      fn( pnow() );
	    }, 1000/60);
	  }
	};
	
	util.requestAnimationFrame = function(fn){
	  raf( fn );
	};
	
	var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };
	
	util.performanceNow = pnow;
	
	// ported lodash throttle function
	util.throttle = function(func, wait, options) {
	  var leading = true,
	      trailing = true;
	
	  if (options === false) {
	    leading = false;
	  } else if (is.plainObject(options)) {
	    leading = 'leading' in options ? options.leading : leading;
	    trailing = 'trailing' in options ? options.trailing : trailing;
	  }
	  options = options || {};
	  options.leading = leading;
	  options.maxWait = wait;
	  options.trailing = trailing;
	
	  return util.debounce(func, wait, options);
	};
	
	util.now = function(){
	  return Date.now();
	};
	
	util.debounce = function(func, wait, options) { // ported lodash debounce function
	  var util = this;
	  var args,
	      maxTimeoutId,
	      result,
	      stamp,
	      thisArg,
	      timeoutId,
	      trailingCall,
	      lastCalled = 0,
	      maxWait = false,
	      trailing = true;
	
	  if (!is.fn(func)) {
	    return;
	  }
	  wait = Math.max(0, wait) || 0;
	  if (options === true) {
	    var leading = true;
	    trailing = false;
	  } else if (is.plainObject(options)) {
	    leading = options.leading;
	    maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
	    trailing = 'trailing' in options ? options.trailing : trailing;
	  }
	  var delayed = function() {
	    var remaining = wait - (util.now() - stamp);
	    if (remaining <= 0) {
	      if (maxTimeoutId) {
	        clearTimeout(maxTimeoutId);
	      }
	      var isCalled = trailingCall;
	      maxTimeoutId = timeoutId = trailingCall = undefined;
	      if (isCalled) {
	        lastCalled = util.now();
	        result = func.apply(thisArg, args);
	        if (!timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	      }
	    } else {
	      timeoutId = setTimeout(delayed, remaining);
	    }
	  };
	
	  var maxDelayed = function() {
	    if (timeoutId) {
	      clearTimeout(timeoutId);
	    }
	    maxTimeoutId = timeoutId = trailingCall = undefined;
	    if (trailing || (maxWait !== wait)) {
	      lastCalled = util.now();
	      result = func.apply(thisArg, args);
	      if (!timeoutId && !maxTimeoutId) {
	        args = thisArg = null;
	      }
	    }
	  };
	
	  return function() {
	    args = arguments;
	    stamp = util.now();
	    thisArg = this;
	    trailingCall = trailing && (timeoutId || !leading);
	
	    if (maxWait === false) {
	      var leadingCall = leading && !timeoutId;
	    } else {
	      if (!maxTimeoutId && !leading) {
	        lastCalled = stamp;
	      }
	      var remaining = maxWait - (stamp - lastCalled),
	          isCalled = remaining <= 0;
	
	      if (isCalled) {
	        if (maxTimeoutId) {
	          maxTimeoutId = clearTimeout(maxTimeoutId);
	        }
	        lastCalled = stamp;
	        result = func.apply(thisArg, args);
	      }
	      else if (!maxTimeoutId) {
	        maxTimeoutId = setTimeout(maxDelayed, remaining);
	      }
	    }
	    if (isCalled && timeoutId) {
	      timeoutId = clearTimeout(timeoutId);
	    }
	    else if (!timeoutId && wait !== maxWait) {
	      timeoutId = setTimeout(delayed, wait);
	    }
	    if (leadingCall) {
	      isCalled = true;
	      result = func.apply(thisArg, args);
	    }
	    if (isCalled && !timeoutId && !maxTimeoutId) {
	      args = thisArg = null;
	    }
	    return result;
	  };
	};
	
	module.exports = util;
	
	},{"../is":77,"../window":100}],100:[function(_dereq_,module,exports){
	module.exports = ( typeof window === 'undefined' ? null : window );
	
	},{}]},{},[76])(76)
	});
	
	
	//# sourceMappingURL=cytoscape.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate, "/"))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, module) {var require;var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.1.2
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(25);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	      var state = parent._state;
	
	      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	        return this;
	      }
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	      var result = parent._result;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }
	
	      var length = entries.length;
	
	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }
	
	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }
	
	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }
	
	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	    var lib$es6$promise$promise$$counter = 0;
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (Array.isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, this._validationError());
	      }
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(23)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.e = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), (function() { return this; }()), __webpack_require__(7)(module)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// the whatwg-fetch polyfill installs the fetch() function
	// on the global object (window or self)
	//
	// Return that as the export for use in Webpack, Browserify etc.
	__webpack_require__(24);
	module.e = self.fetch.bind(self);


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(6);
	var EventEmitter = __webpack_require__(4).EventEmitter;
	
	module.e = Queue;
	
	function Queue(options) {
	  if (!(this instanceof Queue))
	    return new Queue(options);
	  
	  EventEmitter.call(this);
	  options = options || {};
	  this.concurrency = options.concurrency || Infinity;
	  this.timeout = options.timeout || 0;
	  this.pending = 0;
	  this.session = 0;
	  this.running = false;
	  this.jobs = [];
	}
	inherits(Queue, EventEmitter);
	
	var arrayMethods = [
	  'push',
	  'unshift',
	  'splice',
	  'pop',
	  'shift',
	  'slice',
	  'reverse',
	  'indexOf',
	  'lastIndexOf'
	];
	
	for (var method in arrayMethods) (function(method) {
	  Queue.prototype[method] = function() {
	    return Array.prototype[method].apply(this.jobs, arguments);
	  };
	})(arrayMethods[method]);
	
	Object.defineProperty(Queue.prototype, 'length', { get: function() {
	  return this.pending + this.jobs.length;
	}});
	
	Queue.prototype.start = function(cb) {
	  if (cb) {
	    callOnErrorOrEnd.call(this, cb);
	  }
	
	  if (this.pending === this.concurrency) {
	    return;
	  }
	  
	  if (this.jobs.length === 0) {
	    if (this.pending === 0) {
	      done.call(this);
	    }
	    return;
	  }
	  
	  var self = this;
	  var job = this.jobs.shift();
	  var once = true;
	  var session = this.session;
	  var timeoutId = null;
	  var didTimeout = false;
	  
	  function next(err, result) {
	    if (once && self.session === session) {
	      once = false;
	      self.pending--;
	      if (timeoutId !== null) {
	        clearTimeout(timeoutId);
	      }
	      
	      if (err) {
	        self.emit('error', err, job);
	      } else if (didTimeout === false) {
	        self.emit('success', result, job);
	      }
	      
	      if (self.session === session) {
	        if (self.pending === 0 && self.jobs.length === 0) {
	          done.call(self);
	        } else if (self.running) {
	          self.start();
	        }
	      }
	    }
	  }
	  
	  if (this.timeout) {
	    timeoutId = setTimeout(function() {
	      didTimeout = true;
	      if (self.listeners('timeout').length > 0) {
	        self.emit('timeout', next, job);
	      } else {
	        next();
	      }
	    }, this.timeout);
	  }
	  
	  this.pending++;
	  this.running = true;
	  job(next);
	  
	  if (this.jobs.length > 0) {
	    this.start();
	  }
	};
	
	Queue.prototype.stop = function() {
	  this.running = false;
	};
	
	Queue.prototype.end = function(err) {
	  this.jobs.length = 0;
	  this.pending = 0;
	  done.call(this, err);
	};
	
	function callOnErrorOrEnd(cb) {
	  var self = this;
	  this.on('error', onerror);
	  this.on('end', onend);
	
	  function onerror(err) { self.end(err); }
	  function onend(err) {
	    self.removeListener('error', onerror);
	    self.removeListener('end', onend);
	    cb(err);
	  }
	}
	
	function done(err) {
	  this.session++;
	  this.running = false;
	  this.emit('end', err);
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(3).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.e = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	module.e = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(21);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(6);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(0)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	module.e = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 24 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob();
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers;
	  self.Request = Request;
	  self.Response = Response;
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return;
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 25 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.e = __webpack_require__(8);


/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map